-- Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates.
-- All rights reserved.

-- @SINCE-LF 1.3
daml 1.2
module Map where

import DA.Next.Map as M
import DA.Assert

testEmpty = scenario do
  0 === size M.empty
  [] === toList (M.empty : Map Int Decimal)

testSize = scenario do
  0 === size (fromList ([] : [(Int, Decimal)]))
  3 === size (fromList [(1, 2.0), (2, 9.0), (3, 2.2)])

testToList = scenario do
  [(1, "c"), (2, "a"), (5, "b")] === toList (fromList [(2, "a"), (5, "b"), (1, "c")])

testFromList = scenario do
  False === member 2 (fromList [(1, "a"), (3, "b"), (4, "c")])
  True === member 3 (fromList [(1, "a"), (3, "b"), (4, "c")])
  [(1, "b")] === toList (fromList [(1, "a"), (1, "c"), (1, "b")])

testFromListWith = scenario do
  fromListWith (<>) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] === fromList [(3, "ba"), (5, "abc")]
  fromListWith (<>) [] === (M.empty : Map Int Text)

testMember = scenario do
  False === member "a" (fromList [("", 1.0), ("b", 2.0), ("c", 3.0)])
  True === member "" (fromList [("", 1.0), ("b", 2.0), ("c", 3.0)])
  False === member 2 (fromList [])

testLookup = scenario do
  None === M.lookup "a" (fromList [("", 1.0), ("b", 2.0), ("c", 3.0)])
  Some 1.0 === M.lookup "" (fromList [("", 1.0), ("b", 2.0), ("c", 3.0)])
  None === M.lookup 2 (fromList ([] : [(Int, Text)]))

testNull = scenario do
  True === M.null M.empty
  False === M.null (insert 5 "a" M.empty)
  False === M.null (fromList [(1, "a"), (2, "b"), (3, "c")])
  True === M.null (fromList ([] : [(Int, Party)]))

testInsert = scenario do
  [(1, True), (2, False), (3, True), (4, False), (5, False)] === toList
    (foldl (\a b -> uncurry insert b a) M.empty [(3, True), (1, False), (4, False), (2, True), (5, False), (2, False), (1, True)])

testFilterWithKey = scenario do
  [(1, True), (2, False), (3, True)] === toList (M.filterWithKey (\k v -> k < 3 || v) (fromList [(3, True), (1, False), (4, False), (2, True), (5, False), (2, False), (1, True)]))

testDelete = scenario do
  [(2, False), (3, True), (4, False), (5, False)] === toList (delete 1 (fromList [(3, True), (1, False), (4, False), (2, True), (5, False), (2, False), (1, True)]))
  [(1, False), (2, True)] === toList (delete 3 (fromList [(2, False), (1, True), (2, True), (1, False)]))

testMerge = scenario do
  let m1 = fromList [(3, "aa"), (1, "bb"), (4, "cc"), (2, "dd"), (6, "ee")]
  let m2 = fromList [(1, "a"), (3, "b"), (2, "c"), (5, "d"), (0, "e")]

  [] === toList (merge (\k v -> Some v) (\k v -> Some v) (\k v w -> Some v) M.empty (M.empty : Map Int Text))
  [] === toList (merge (\k v -> Some v) (\k v -> Some v) (\k v w -> None) m1 m1)
  [(1, "bb"), (3, "aa")] === toList (merge (\k v -> if v <= "bb" then Some v else None) (\k v -> Some v) (\k v w -> None) m1 M.empty)
  [(1, "a"), (3, "b")] === toList (merge (\k v -> Some v) (\k v -> if v <= "bb" then Some v else None) (\k v w -> None) M.empty m2)
  [(1,"bb"), (2,"dd"), (3,"aa")] === toList (merge (\k v -> None) (\k v -> None) (\k v w -> Some v) m1 m2)

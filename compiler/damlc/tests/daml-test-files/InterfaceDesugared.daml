-- Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- @SINCE-LF-FEATURE DAML_INTERFACE
-- @WARN Modules compiled with the DatatypeContexts language extension
{-# LANGUAGE DatatypeContexts #-}

-- | The "desugared" counterpart to Interface.daml
-- Please keep in sync with Interface.daml
module InterfaceDesugared where

import DA.Assert ((===))
import DA.Action (unless)

data GHC.Types.DamlInterface => Token = Token GHC.Types.Opaque

class IsToken t where
  toToken : t -> Token
  fromToken : Token -> Optional t
  toTokenContractId : ContractId t -> ContractId Token
  fromTokenContractId : ContractId Token -> Update (Optional (ContractId t))
  tokenTypeRep : t -> DA.Internal.Desugar.TypeRep
  getOwner : t -> Party
  getAmount : t -> Int
  setAmount : t -> Int -> Token
  splitImpl : t -> Int -> Update (ContractId Token, ContractId Token)
  transferImpl : t -> Party -> Update (ContractId Token)
  noopImpl : t -> () -> Update ()

instance HasCreate Token where
  create = GHC.Types.primitive @"UCreateInterface"
instance HasObserver Token where
  observer = GHC.Types.primitive @"EObserverInterface"
instance HasSignatory Token where
  signatory = GHC.Types.primitive @"ESignatoryInterface"

instance HasFetch Token where
  fetch = GHC.Types.primitive @"UFetchInterface"

instance IsToken Token where
  toToken = GHC.Types.primitive @"EToInterface"
  fromToken = GHC.Types.primitive @"EFromInterface"
  toTokenContractId = GHC.Types.primitive @"EToInterfaceContractId"
  fromTokenContractId = GHC.Types.primitive @"UFromInterfaceContractId"
  tokenTypeRep = GHC.Types.primitive @"$TO_TYPE_REP"
  getOwner = GHC.Types.primitiveInterface @"getOwner"
  getAmount = GHC.Types.primitiveInterface @"getAmount"
  setAmount = GHC.Types.primitiveInterface @"setAmount"
  noopImpl = GHC.Types.primitiveInterface @"noopImpl"
  transferImpl = GHC.Types.primitiveInterface @"transferImpl"
  splitImpl = GHC.Types.primitiveInterface @"splitImpl"

data GetRich = GetRich { byHowMuch : Int }
_choice_TokenGetRich :
  ( Token -> GetRich -> [DA.Internal.Desugar.Party]
  , DA.Internal.Desugar.ContractId Token -> Token -> GetRich -> DA.Internal.Desugar.Update (ContractId Token)
  , DA.Internal.Desugar.Consuming Token
  , DA.Internal.Desugar.Optional (Token -> GetRich -> [DA.Internal.Desugar.Party])
  )
_choice_TokenGetRich =
  ( \this _ -> [getOwner this]
  , \self this GetRich{byHowMuch} -> do
      assert (byHowMuch > 0)
      create $ setAmount this (getAmount this + byHowMuch)
  , DA.Internal.Desugar.Consuming
  , DA.Internal.Desugar.None
  )
instance IsToken t => HasExercise t GetRich (ContractId Token) where
  exercise cid = GHC.Types.primitive @"UExerciseInterface" (toTokenContractId cid)
instance IsToken t => HasToAnyChoice t GetRich (ContractId Token) where
  _toAnyChoice = GHC.Types.primitive @"EToAnyChoice"
instance IsToken t => HasFromAnyChoice t GetRich (ContractId Token) where
  _fromAnyChoice = GHC.Types.primitive @"EFromAnyChoice"

data Noop = Noop { nothing : () }
_choice_TokenNoop :
  ( Token -> Noop -> [DA.Internal.Desugar.Party]
  , DA.Internal.Desugar.ContractId Token -> Token -> Noop -> DA.Internal.Desugar.Update ()
  , DA.Internal.Desugar.NonConsuming Token
  , DA.Internal.Desugar.Optional (Token -> Noop -> [DA.Internal.Desugar.Party])
  )
_choice_TokenNoop
  = (\ this arg@Noop {..}
       -> let _ = this in
          let _ = arg in DA.Internal.Desugar.toParties (getOwner this),
     \ self this arg@Noop {..}
       -> let _ = self in
          let _ = this in let _ = arg in do noopImpl this nothing,
     DA.Internal.Desugar.NonConsuming, DA.Internal.Desugar.None)
instance (IsToken t) => HasToAnyChoice t Noop (()) where
  _toAnyChoice = GHC.Types.primitive @"EToAnyChoice"
instance (IsToken t) => HasFromAnyChoice t Noop (()) where
  _fromAnyChoice = GHC.Types.primitive @"EFromAnyChoice"
instance (IsToken t) => HasExercise t Noop (()) where
  exercise cid = GHC.Types.primitive @"UExerciseInterface" (toTokenContractId cid)

data Transfer = Transfer { newOwner : Party }
_choice_TokenTransfer :
  ( Token -> Transfer -> [DA.Internal.Desugar.Party]
  , DA.Internal.Desugar.ContractId Token -> Token -> Transfer -> DA.Internal.Desugar.Update (ContractId Token)
  , DA.Internal.Desugar.Consuming Token
  , DA.Internal.Desugar.Optional (Token -> Transfer -> [DA.Internal.Desugar.Party])
  )
_choice_TokenTransfer
  = (\ this arg@Transfer {..}
       -> let _ = this in
          let _ = arg
          in
            DA.Internal.Desugar.concat
              [DA.Internal.Desugar.toParties (getOwner this),
               DA.Internal.Desugar.toParties (newOwner)],
     \ self this arg@Transfer {..}
       -> let _ = self in
          let _ = this in let _ = arg in do transferImpl this newOwner,
     DA.Internal.Desugar.Consuming, DA.Internal.Desugar.None)
instance (IsToken t) => HasToAnyChoice t Transfer (ContractId Token) where
  _toAnyChoice = GHC.Types.primitive @"EToAnyChoice"
instance (IsToken t) => HasFromAnyChoice t Transfer (ContractId Token) where
  _fromAnyChoice = GHC.Types.primitive @"EFromAnyChoice"
instance (IsToken t) => HasExercise t Transfer (ContractId Token) where
  exercise cid = GHC.Types.primitive @"UExerciseInterface" (toTokenContractId cid)

data Split = Split { splitAmount : Int }
_choice_TokenSplit :
  ( Token -> Split -> [DA.Internal.Desugar.Party]
  , DA.Internal.Desugar.ContractId Token -> Token -> Split -> DA.Internal.Desugar.Update ((ContractId Token, ContractId Token))
  , DA.Internal.Desugar.Consuming Token
  , DA.Internal.Desugar.Optional (Token -> Split -> [DA.Internal.Desugar.Party])
  )
_choice_TokenSplit
  = (\ this arg@Split {..}
       -> let _ = this in
          let _ = arg in DA.Internal.Desugar.toParties (getOwner this),
     \ self this arg@Split {..}
       -> let _ = self in
          let _ = this in let _ = arg in do splitImpl this splitAmount,
     DA.Internal.Desugar.Consuming, DA.Internal.Desugar.None)
instance (IsToken t) => HasToAnyChoice t Split ((ContractId Token,
                                                      ContractId Token)) where
  _toAnyChoice = GHC.Types.primitive @"EToAnyChoice"
instance (IsToken t) => HasFromAnyChoice t Split ((ContractId Token,
                                                        ContractId Token)) where
  _fromAnyChoice = GHC.Types.primitive @"EFromAnyChoice"
instance (IsToken t) => HasExercise t Split ((ContractId Token,
                                                   ContractId Token)) where
  exercise cid = GHC.Types.primitive @"UExerciseInterface" (toTokenContractId cid)

data GHC.Types.DamlTemplate => Asset = Asset { amount : Int, issuer : Party, owner : Party }
  deriving (Eq, Show)

instance IsToken Asset where
  toToken = GHC.Types.primitive @"EToInterface"
  fromToken = GHC.Types.primitive @"EFromInterface"
  toTokenContractId = GHC.Types.primitive @"EToInterfaceContractId"
  fromTokenContractId = GHC.Types.primitive @"UFromInterfaceContractId"
  tokenTypeRep = GHC.Types.primitive @"$TO_TYPE_REP"
  getOwner Asset{..} = owner
  getAmount Asset{..} = amount
  setAmount this x = toToken (this with amount = x)
  splitImpl this@Asset {..}
    = \ splitAmount
        -> do assert (splitAmount < amount)
              cid1 <- create this {amount = splitAmount}
              cid2 <- create this {amount = amount - splitAmount}
              pure (toTokenContractId cid1, toTokenContractId cid2)
    where
        _ = this
  transferImpl this
    = \ newOwner
        -> do cid <- create this {owner = newOwner}
              pure (toTokenContractId cid)
    where
        _ = this
  noopImpl this
    = \ nothing -> do pure ()

_implements_AssetToken : DA.Internal.Desugar.Implements Asset Token
_implements_AssetToken = DA.Internal.Desugar.Implements

instance HasCreate Asset where
  create = GHC.Types.primitive @"UCreate"

instance HasSignatory Asset where
  signatory Asset{..} = [issuer, owner]

instance HasEnsure Asset where
  ensure _ = True

instance HasAgreement Asset where
  agreement _ = ""

instance HasObserver Asset where
  observer _ = []

instance HasFetch Asset where
  fetch = GHC.Types.primitive @"UFetch"

instance HasExercise Asset Archive () where
  exercise = GHC.Types.primitive @"UExercise"

instance HasArchive Asset where
  archive cid = exercise cid Archive

_choice_AssetArchive :
  ( Asset -> Archive -> [DA.Internal.Desugar.Party]
  , DA.Internal.Desugar.ContractId Asset -> Asset -> Archive -> DA.Internal.Desugar.Update ()
  , DA.Internal.Desugar.Consuming Asset
  , DA.Internal.Desugar.Optional (Asset -> Archive -> [DA.Internal.Desugar.Party])
  )
_choice_AssetArchive =
  ( \a _ -> signatory a
  , \_ _ _ -> pure ()
  , DA.Internal.Desugar.Consuming
  , DA.Internal.Desugar.None
  )

main = scenario do
  p <- getParty "Alice"
  p `submit` do
    cidAsset1 <- create Asset with
      issuer = p
      owner = p
      amount = 15
    let cidToken1 = toTokenContractId cidAsset1
    _ <- exercise cidToken1 (Noop ())
    (cidToken2, cidToken3) <- exercise cidToken1 (Split 10)
    token2 <- fetch cidToken2
    getAmount token2 === 10
    case fromToken token2 of
      None -> abort "expected Asset"
      Some Asset {amount} ->
        amount === 10
    token3 <- fetch cidToken3
    getAmount token3 === 5
    case fromToken token3 of
      None -> abort "expected Asset"
      Some Asset {amount} ->
        amount === 5

    cidToken4 <- exercise cidToken3 (GetRich 20)
    token4 <- fetch cidToken4
    getAmount token4 === 25
    case fromToken token4 of
      None -> abort "expected Asset"
      Some Asset {amount} ->
        amount === 25
    unless (tokenTypeRep token3 == tokenTypeRep token4) $ error "Type representations are different."

    pure ()

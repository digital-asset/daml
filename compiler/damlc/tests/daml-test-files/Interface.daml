-- Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- @SINCE-LF-FEATURE DAML_INTERFACE

module Interface where

import DA.Assert ((===))

interface Token where
  getOwner : Party
  getAmount : Int
  setAmount : Int -> Token

  choice Split : (ContractId Token, ContractId Token)
    with
      splitAmount : Int

  choice Transfer : ContractId Token
    with
      newOwner : Party

  nonconsuming choice Noop : ()
    with
      nothing : ()

-- TODO https://github.com/digital-asset/daml/issues/10810
--   Add HasCreate, HasSignatory, HasObserver instances in GHC parser
instance HasCreate Token where
  create x = GHC.Types.primitive @"$RESOLVE_VIRTUAL_CREATE" x x
instance HasObserver Token where
  observer x = GHC.Types.primitive @"$RESOLVE_VIRTUAL_OBSERVERS" x x
-- TODO https://github.com/digital-asset/daml/issues/11198
--   Instance disabled until issue is resolved.
-- instance HasSignatory Token where
--   signatory x = GHC.Types.primitive @"$RESOLVE_VIRTUAL_SIGNATORIES" x x

-- TODO https://github.com/digital-asset/daml/issues/11137
--   Implement fixed choices in GHC parser.
data GetRich = GetRich { byHowMuch : Int }
_choice_TokenGetRich :
  ( Token -> GetRich -> [DA.Internal.Desugar.Party]
  , DA.Internal.Desugar.ContractId Token -> Token -> GetRich -> DA.Internal.Desugar.Update (ContractId Token)
  , DA.Internal.Desugar.Consuming Token
  , DA.Internal.Desugar.Optional (Token -> GetRich -> [DA.Internal.Desugar.Party])
  )
_choice_TokenGetRich =
  ( \this _ -> [getOwner this]
  , \self this GetRich{byHowMuch} -> do
      assert (byHowMuch > 0)
      create $ setAmount this (getAmount this + byHowMuch)
  , DA.Internal.Desugar.Consuming
  , DA.Internal.Desugar.None
  )
instance IsToken t => HasExercise t GetRich (ContractId Token) where
  exercise cid = GHC.Types.primitive @"UExerciseInterface" (toTokenContractId cid)

template Asset
  with
    issuer : Party
    owner : Party
    amount : Int
  where
    signatory issuer, owner
    implements Token where
      let getOwner = owner
      let getAmount = amount
      let setAmount = \x -> toToken (this with amount = x)
        -- TODO https://github.com/digital-asset/daml/issues/10810
        --  (maybe) support `let setAmount x = ...` syntax.

      choice Split : (ContractId Token, ContractId Token)
        with
          splitAmount : Int
        controller owner
        do
          assert (splitAmount < amount)
          cid1 <- create this with amount = splitAmount
          cid2 <- create this with amount = amount - splitAmount
          pure (toTokenContractId cid1, toTokenContractId cid2)

      choice Transfer : ContractId Token
        with
          newOwner : Party
        controller owner, newOwner
        do
          cid <- create this with owner = newOwner
          pure (toTokenContractId cid)

      nonconsuming choice Noop : ()
        with
          nothing : ()
        controller owner
        do
          pure ()

main = scenario do
  p <- getParty "Alice"
  p `submit` do
    cidAsset1 <- create Asset with
      issuer = p
      owner = p
      amount = 15
    let cidToken1 = toTokenContractId cidAsset1
    _ <- exercise cidToken1 (Noop ())
    (cidToken2, cidToken3) <- exercise cidToken1 (Split 10)
    token2 <- fetch cidToken2
    getAmount token2 === 10
    case fromToken token2 of
      None -> abort "expected Asset"
      Some Asset {amount} ->
        amount === 10
    token3 <- fetch cidToken3
    getAmount token3 === 5
    case fromToken token3 of
      None -> abort "expected Asset"
      Some Asset {amount} ->
        amount === 5

    -- TODO https://github.com/digital-asset/daml/issues/11137
    --   uncomment once speedy supports fixed choices
    -- cidToken4 <- exercise cidToken3 (GetRich 20)
    -- token4 <- fetch cidToken4
    -- getAmount token4 === 25
    -- case fromToken token4 of
    --   None -> abort "expected Asset"
    --   Some Asset {amount} ->
    --     amount === 25

    pure ()

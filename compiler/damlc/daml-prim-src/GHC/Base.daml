-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE PolyKinds #-}

-- | MOVE Prelude
module GHC.Base
  ( otherwise
  , getTag
  , (++)
  , map
  , foldr
  , (.)
  , const
  , Functor(..)
  , ($)
  ) where

import GHC.Integer.Type() -- required so Integer optimisation works
import GHC.Prim
import GHC.Types

-- | Used as an alternative in conditions.
otherwise : Bool
otherwise = True

-- | HIDE
getTag : a -> Int#
getTag = magic @"getTag"

-- | HIDE This is referenced from error messages generated by ghc. Not
-- meant to be used in Daml, and not exported in Prelude. Use <> instead.
(++) : Text -> Text -> Text
(++) = primitive @"BEAppendText"
infixr 5 ++

-- | `map f xs` applies the function `f` to all elements of the list `xs`
--  and returns the list of results (in the same order as `xs`).
map : (a -> b) -> [a] -> [b]
map f = foldr (\x xs -> f x :: xs) []

-- | This function is a right fold, which you can use to manipulate lists.
-- `foldr f i xs` performs a right fold over the list `xs` using
-- the function `f`, using the starting value `i`.
--
-- Note that foldr works from right-to-left over the list elements.
foldr : (a -> b -> b) -> b -> [a] -> b
foldr = primitive @"BEFoldr"

-- | Composes two functions, i.e., `(f . g) x = f (g x)`.
(.)    : (b -> c) -> (a -> b) -> a -> c
(.) f g = \x -> f (g x)
infixr 9 .

-- | `const x` is a unary function which evaluates to `x` for all inputs.
--
-- ```
-- >>> const 42 "hello"
-- 42
-- ```
--
-- ```
-- >>> map (const 42) [0..3]
-- [42,42,42,42]
-- ```
const                   : a -> b -> a
const x _               =  x

-- | A `Functor` is a typeclass for things that can be mapped over (using
-- its `fmap` function. Examples include `Optional`, `[]` and `Update`).

-- For a detailed explanation, see
-- http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
class Functor f where
    -- | `fmap` takes a function of type `a -> b`, and turns it into a
    -- function of type `f a -> f b`, where `f` is the type which is an
    -- instance of `Functor`.
    --
    -- For example, `map` is an `fmap` that only works on lists.
    -- It takes a function `a -> b` and a `[a]`, and returns a `[b]`.
    fmap        : (a -> b) -> f a -> f b

    -- | Replace all locations in the input `f b` with the same value `a`.
    -- The default definition is `fmap . const`, but you can override
    -- this with a more efficient version.
    (<$)        : a -> f b -> f a
    (<$)        =  fmap . const

infixl 4  <$

infixr 0 $
-- | Take a function from `a` to `b` and a value of type `a`, and apply the
-- function to the value of type `a`, returning a value of type `b`.
-- This function has a very low precedence, which is why you might want to use
-- it instead of regular function application.
($) : forall r a (b : TYPE r). (a -> b) -> a -> b
f $ x =  f x

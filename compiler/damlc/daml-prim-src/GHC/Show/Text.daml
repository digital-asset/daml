-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE CPP #-}
{-# LANGUAGE NoImplicitPrelude #-}

{-
Note [newtype Chr debugging]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The macro `__DEBUG__SHOW_TEXT_CHR_NEWTYPE` can be `#define`d to switch to an
implementation where `Chr` is a newtype'd `Text`. This ensures that an
arbitrary-length `Text` can't be used as a `Chr` without going through a
conversion function, which can be useful during development.

Since Daml newtypes impose a performance penalty (unlike Haskell newtypes), the
implementation we actually use in `daml-prim` uses a type synonym instead
(corresponding to the case where the macro is not defined).
-}
-- #define __DEBUG__SHOW_TEXT_CHR_NEWTYPE

module GHC.Show.Text
  ( showsPrecText
  ) where

import GHC.Base (
#ifdef __DEBUG__SHOW_TEXT_CHR_NEWTYPE
    map,
#endif
    (.), (++), ($)
  )
import GHC.Classes (Eq (..), Ord (..), (&&))
import GHC.CString (fromString)
import GHC.Err (error)
import GHC.Types (Bool, Int, Text, primitive)

-- # Exported

showsPrecText : Int -> Text -> ShowS
showsPrecText _ x =
    showString "\""
  . showLitText x
  . showString "\""

-- # Primitives

primExplode : Text -> [Text]
primExplode = primitive @"BEExplodeText"

primTextToCodePoints : Text -> [Int]
primTextToCodePoints = primitive @"BETextToCodePoints"

primIntToText : Int -> Text
primIntToText = primitive @"BEToText"

-- # Internal

explode : Text -> [Chr]

-- See Note [newtype Chr debugging]
#ifdef __DEBUG__SHOW_TEXT_CHR_NEWTYPE

newtype Chr = MkChr Text
  deriving (Eq, Ord)

#define CH(t) (MkChr t)

explode = map MkChr . primExplode

#else

type Chr = Text

#define CH(t) t

explode = primExplode

#endif

startsWithDigit : Text -> Bool
startsWithDigit t = "0" <= t && t < ":" -- ':' immediately follows '9' in ASCII

startsWithUppercaseH : Text -> Bool
startsWithUppercaseH t = "H" <= t && t < "I"

ord : Chr -> Int
ord CH(t) = case primTextToCodePoints t of
  [p] -> p
  _ -> error $ "impossible: GHC.Show.Text.ord applied to argument with length /= 1, \"" ++ t ++ "\""

type ShowS = Text -> Text

showString : Text -> ShowS
showString = (++)

showInt : Int -> ShowS
showInt = showString . primIntToText

showLitText : Text -> ShowS
showLitText = showLitChrs . explode

showLitChrs : [Chr] -> ShowS
showLitChrs []               = \s -> s
showLitChrs (CH("\"") :: cs) = showString "\\\"" . showLitChrs cs
showLitChrs (c        :: cs) = showLitChr c . showLitChrs cs

showLitChr : Chr -> ShowS
showLitChr c | c > CH("\DEL")       = showString "\\" . showInt (ord c) . protectEsc startsWithDigit
showLitChr CH("\DEL")               = showString "\\DEL"
showLitChr CH("\\")                 = showString "\\\\"
showLitChr c@(CH(t)) | c >= CH(" ") = showString t
showLitChr CH("\a")                 = showString "\\a"
showLitChr CH("\b")                 = showString "\\b"
showLitChr CH("\f")                 = showString "\\f"
showLitChr CH("\n")                 = showString "\\n"
showLitChr CH("\r")                 = showString "\\r"
showLitChr CH("\t")                 = showString "\\t"
showLitChr CH("\v")                 = showString "\\v"
showLitChr CH("\SO")                = showString "\\SO" . protectEsc startsWithUppercaseH
showLitChr c                        = showString "\\" . showString (ascii c)

protectEsc : (Text -> Bool) -> ShowS
protectEsc p = cont
         where cont s | p s = showString "\\&" s
               cont s       = s

ascii : Chr -> Text
ascii c = case c of
  CH("\NUL") -> "NUL"; CH("\SOH") -> "SOH"; CH("\STX") -> "STX"; CH("\ETX") -> "ETX";
  CH("\EOT") -> "EOT"; CH("\ENQ") -> "ENQ"; CH("\ACK") -> "ACK"; CH("\BEL") -> "BEL";

  CH("\BS")  -> "BS";  CH("\HT")  -> "HT";  CH("\LF")  -> "LF";  CH("\VT")  -> "VT";
  CH("\FF")  -> "FF";  CH("\CR")  -> "CR";  CH("\SO")  -> "SO";  CH("\SI")  -> "SI";

  CH("\DLE") -> "DLE"; CH("\DC1") -> "DC1"; CH("\DC2") -> "DC2"; CH("\DC3") -> "DC3";
  CH("\DC4") -> "DC4"; CH("\NAK") -> "NAK"; CH("\SYN") -> "SYN"; CH("\ETB") -> "ETB";

  CH("\CAN") -> "CAN"; CH("\EM")  -> "EM";  CH("\SUB") -> "SUB"; CH("\ESC") -> "ESC";
  CH("\FS")  -> "FS";  CH("\GS")  -> "GS";  CH("\RS")  -> "RS";  CH("\US")  -> "US";

  CH("\SP")  -> "SP";

  _ -> ""

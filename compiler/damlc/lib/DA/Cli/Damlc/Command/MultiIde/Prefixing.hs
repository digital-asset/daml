-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DisambiguateRecordFields #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE GADTs #-}

-- This module handles prefixing of identifiers generated by the SubIDEs, so that they are unique to the client, but are returned in the same form to the servers.
module DA.Cli.Damlc.Command.MultiIde.Prefixing (
  addProgressTokenPrefixToServerMessage,
  addLspPrefixToServerMessage,
  removeLspPrefix,
  removeWorkDoneProgressCancelTokenPrefix,
) where

import Control.Concurrent.MVar
import Control.Lens
import Data.Foldable (find)
import qualified Data.Map as Map
import Data.Maybe (fromMaybe)
import qualified Data.Text as T
import qualified Language.LSP.Types as LSP
import qualified Language.LSP.Types.Lens as LSP
import DA.Cli.Damlc.Command.MultiIde.Types

-- ProgressToken Prefixing

-- We need to ensure all ProgressTokens from different subIDEs are unique to the client, so we prefix them.
-- We do not need to undo this transformation, as we'll store it and backwards lookup later.
addProgressTokenPrefix :: T.Text -> LSP.ProgressToken -> LSP.ProgressToken
addProgressTokenPrefix prefix (LSP.ProgressNumericToken t) = LSP.ProgressTextToken $ prefix <> "-" <> T.pack (show t)
addProgressTokenPrefix prefix (LSP.ProgressTextToken t) = LSP.ProgressTextToken $ prefix <> "-" <> t

-- Added to WindowWorkDoneProgressCreate and Progress
-- If its create, add to the var, if its progress, read from the var, fall back to current
addProgressTokenPrefixToServerMessage :: ServerCreatedProgressTokensVar -> FilePath -> T.Text -> LSP.FromServerMessage -> IO LSP.FromServerMessage
addProgressTokenPrefixToServerMessage tokensVar home prefix (LSP.FromServerMess LSP.SWindowWorkDoneProgressCreate req) = do
  let unPrefixedToken = req ^. LSP.params . LSP.token
      prefixedToken = addProgressTokenPrefix prefix unPrefixedToken
  modifyMVar_ tokensVar (pure . Map.insert (unPrefixedToken, home) prefixedToken)
  pure $ LSP.FromServerMess LSP.SWindowWorkDoneProgressCreate $ req & LSP.params . LSP.token .~ prefixedToken
addProgressTokenPrefixToServerMessage tokensVar home _ (LSP.FromServerMess LSP.SProgress notif) = do
  let unPrefixedToken = notif ^. LSP.params . LSP.token
  prefixedToken <- fromMaybe unPrefixedToken . Map.lookup (unPrefixedToken, home) <$> readMVar tokensVar
  case notif ^. LSP.params . LSP.value of
    LSP.End _ -> modifyMVar_ tokensVar (pure . Map.delete (unPrefixedToken, home))
    _ -> pure ()
  pure $ LSP.FromServerMess LSP.SProgress $ notif & LSP.params . LSP.token .~ prefixedToken
addProgressTokenPrefixToServerMessage _ _ _ msg = pure msg

findKeyByValue :: Eq v => v -> Map.Map k v -> Maybe k
findKeyByValue val = fmap fst . find ((==val) . snd) . Map.toList

-- Remove from WindowWorkDoneProgressCancel
removeWorkDoneProgressCancelTokenPrefix
  :: ServerCreatedProgressTokensVar
  -> LSP.NotificationMessage 'LSP.WindowWorkDoneProgressCancel
  -> IO (LSP.NotificationMessage 'LSP.WindowWorkDoneProgressCancel, Maybe FilePath)
removeWorkDoneProgressCancelTokenPrefix tokensVar notif = do
  let token = notif ^. LSP.params . LSP.token
  mKey <- findKeyByValue token <$> readMVar tokensVar
  case mKey of
    Nothing -> pure (notif, Nothing)
    Just key@(unPrefixedToken, home) -> do
      modifyMVar_ tokensVar (pure . Map.delete key)
      pure (notif & LSP.params . LSP.token .~ unPrefixedToken, Just home)

-- LspId Prefixing

-- We need to ensure all IDs from different subIDEs are unique to the client, so we prefix them.
-- Given IDs can be int or text, we encode them as text as well as a tag to say if the original was an int
-- Such that IdInt 10       -> IdString "iPREFIX-10"
--       and IdString "hello" -> IdString "tPREFIX-hello"
addLspPrefix
  :: forall (f :: LSP.From) (m :: LSP.Method f 'LSP.Request)
  .  T.Text
  -> LSP.LspId m
  -> LSP.LspId m
addLspPrefix prefix (LSP.IdInt t) = LSP.IdString $ "i" <> prefix <> "-" <> T.pack (show t)
addLspPrefix prefix (LSP.IdString t) = LSP.IdString $ "t" <> prefix <> "-" <> t

removeLspPrefix
  :: forall (f :: LSP.From) (m :: LSP.Method f 'LSP.Request)
  .  LSP.LspId m
  -> LSP.LspId m
removeLspPrefix (LSP.IdString (T.unpack -> ('i':rest))) = LSP.IdInt $ read $ tail $ dropWhile (/='-') rest
removeLspPrefix (LSP.IdString (T.uncons -> Just ('t', rest))) = LSP.IdString $ T.tail $ T.dropWhile (/='-') rest
-- Maybe this should error? This method should only be called on LspIds that we know have been prefixed
removeLspPrefix t = t

addLspPrefixToServerMessage :: SubIDE -> LSP.FromServerMessage -> LSP.FromServerMessage
addLspPrefixToServerMessage _ res@(LSP.FromServerRsp _ _) = res
addLspPrefixToServerMessage ide res@(LSP.FromServerMess method params) =
  case LSP.splitServerMethod method of
    LSP.IsServerReq -> LSP.FromServerMess method $ params & LSP.id %~ addLspPrefix (ideMessageIdPrefix ide)
    LSP.IsServerNot -> res
    LSP.IsServerEither ->
      case params of
        LSP.ReqMess params' -> LSP.FromServerMess method $ LSP.ReqMess $ params' & LSP.id %~ addLspPrefix (ideMessageIdPrefix ide)
        LSP.NotMess _ -> res

-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE CPP #-}

module DA.Numeric
 ( mul
 , div
 , cast
 , castAndRound
 , shift
 , pi
 , RoundingMode(..)
 , roundNumeric
) where

import GHC.Types (primitive)
import qualified DA.Map as M
import qualified DA.Optional as O

-- | Multiply two numerics. Both inputs and the output may have
-- different scales, unlike `(*)` which forces all numeric scales
-- to be the same. Raises an error on overflow, rounds to chosen
-- scale otherwise.
mul : forall n3 n1 n2. NumericScale n3 => Numeric n1 -> Numeric n2 -> Numeric n3
#ifndef DAML_NAT_TYPE_ERASURE
mul = primitive @"BEMulNumericLegacy"
#else
mul = primitive @"BEMulNumeric" (numericOne @n3)
#endif

-- | Divide two numerics. Both inputs and the output may have
-- different scales, unlike `(/)` which forces all numeric scales
-- to be the same. Raises an error on overflow, rounds to chosen
-- scale otherwise.
div : forall n3 n1 n2. NumericScale n3 => Numeric n1 -> Numeric n2 -> Numeric n3
#ifndef DAML_NAT_TYPE_ERASURE
div = primitive @"BEDivNumericLegacy"
#else
div = primitive @"BEDivNumeric" (numericOne @n3)
#endif

-- | Cast a Numeric. Raises an error on overflow or loss of precision.
cast : forall n2 n1. NumericScale n2 => Numeric n1 -> Numeric n2
#ifndef DAML_NAT_TYPE_ERASURE
cast = primitive @"BECastNumericLegacy"
#else
cast = primitive @"BECastNumeric" (numericOne @n2)
#endif

-- | Cast a Numeric. Raises an error on overflow, rounds to chosen
-- scale otherwise.
castAndRound : forall n2 n1. NumericScale n2 => Numeric n1 -> Numeric n2
castAndRound = mul (1.0 : Numeric 0)

-- | Move the decimal point left or right by multiplying the numeric
-- value by 10^(n1 - n2). Does not overflow or underflow.
shift : forall n2 n1. NumericScale n2 => Numeric n1 -> Numeric n2
#ifndef DAML_NAT_TYPE_ERASURE
shift = primitive @"BEShiftNumericLegacy"
#else
shift = primitive @"BEShiftNumeric" (numericOne @n2)
#endif

-- | The number pi.
pi : forall n. NumericScale n => Numeric n
pi = castAndRound (3.14159_26535_89793_23846_26433_83279_50288_41 : Numeric 37)

zero0 : Numeric 37
zero0 = 0.0

one : Numeric 0
one = 1.0

delta : Numeric 37
delta = shift one

roundHalfEven : forall n. NumericScale n => Numeric 37 -> Numeric n
roundHalfEven x = castAndRound @n x

roundCeiling : NumericScale n => Numeric 37 -> Numeric n
roundCeiling x =
   if (x <= cast r) then
    r
  else
    r + shift one
  where
    r = roundHalfEven x

roundFloor : NumericScale n => Numeric 37 -> Numeric n
roundFloor x =
    if (cast r <= x) then
      r
    else
      r - shift one
    where
      r = roundHalfEven x

roundUp : NumericScale n => Numeric 37 -> Numeric n
roundUp x =
    if (zero0 <= x) then
      roundCeiling x
    else
      roundFloor x

roundDown : NumericScale n => Numeric 37 -> Numeric n
roundDown x =
    if (zero0 <= x) then
      roundFloor x
    else
      roundCeiling x

roundHalfCeiling : NumericScale n => Numeric 37 -> Numeric n
roundHalfCeiling x =
    if (x <= cast r) then
      r
    else
      roundHalfEven (x + delta)
    where
      r = roundHalfEven x

roundHalfFloor : NumericScale n => Numeric 37 -> Numeric n
roundHalfFloor x =
    if (cast r <= x) then
      r
    else
      roundHalfEven (x - delta)
    where
      r = roundHalfEven x

roundHalfUp : NumericScale n => Numeric 37 -> Numeric n
roundHalfUp x =
    if (zero0 <= x) then
     roundHalfCeiling x
    else
      roundHalfFloor x

roundHalfDown : NumericScale n => Numeric 37 -> Numeric n
roundHalfDown x =
  if (zero0 <= x) then
    roundHalfFloor x
  else
    roundHalfCeiling x

roundUnnecessary : NumericScale n => Numeric 37 -> Numeric n
roundUnnecessary =
  cast

#ifndef DAML_BIGNUMERIC
-- | Rounding modes.
data RoundingMode
  = RoundingUp -- ^ Round away from zero.
  | RoundingDown -- ^ Round towards zero.
  | RoundingCeiling -- ^ Round towards positive infinity.
  | RoundingFloor -- ^ Round towards negative infinity.
  | RoundingHalfUp
      -- ^ Round towards the nearest neighbor unless both neighbors
      -- are equidistant, in which case round away from zero.
  | RoundingHalfDown
      -- ^ Round towards the nearest neighbor unless both neighbors
      -- are equidistant, in which case round towards zero.
  | RoundingHalfEven
      -- ^ Round towards the nearest neighbor unless both neighbors
      -- are equidistant, in which case round towards the even neighbor.
  | RoundingUnnecessary
      -- ^ Do not round. Raises an error if the result cannot
      -- be represented without rounding at the targeted scale.
#endif

round' : forall n. NumericScale n => RoundingMode -> Numeric 37 -> Numeric 37
round' RoundingUp x = cast $ roundUp @n x
round' RoundingDown x = cast $ roundDown @n x
round' RoundingCeiling x = cast $ roundCeiling @n x
round' RoundingFloor x = cast $ roundFloor @n x
round' RoundingHalfUp x = cast $ roundHalfUp @n x
round' RoundingHalfDown x = cast $ roundHalfDown @n x
round' RoundingHalfEven x = cast $ roundHalfEven @n x
round' RoundingUnnecessary x = cast $ roundUnnecessary @n x

roundMap : M.Map  Int (RoundingMode -> Numeric 37 -> Numeric 37)
roundMap = M.fromList
  [ (0, round' @0)
  , (1, round' @1)
  , (2, round' @2)
  , (3, round' @3)
  , (4, round' @4)
  , (5, round' @5)
  , (6, round' @6)
  , (7, round' @7)
  , (8, round' @8)
  , (9, round' @9)
  , (10, round' @10)
  , (11, round' @11)
  , (12, round' @12)
  , (13, round' @13)
  , (14, round' @14)
  , (15, round' @15)
  , (16, round' @16)
  , (17, round' @17)
  , (18, round' @18)
  , (19, round' @19)
  , (20, round' @20)
  , (21, round' @21)
  , (22, round' @22)
  , (23, round' @23)
  , (24, round' @24)
  , (25, round' @25)
  , (26, round' @26)
  , (27, round' @27)
  , (28, round' @28)
  , (29, round' @29)
  , (30, round' @30)
  , (31, round' @31)
  , (32, round' @32)
  , (33, round' @33)
  , (34, round' @34)
  , (35, round' @35)
  , (36, round' @36)
  , (37, const identity)
  ]

-- | Round a `Numeric` number. The value of `round n r a` is the value
-- of `a` rounded to `n` decimal places (i.e. scale), according to the rounding
-- mode `r`.
--
-- This will fail when using the `RoundingUnnecessary` mode for a number that cannot
-- be represented exactly with at most `n` decimal places.
roundNumeric: forall n. NumericScale n => Int -> RoundingMode -> Numeric n -> Numeric n
roundNumeric i m x =
    shift $ (O.fromSome $ M.lookup (37 - scale + i) roundMap) m (shift x)
  where 
    scale = 
#ifndef DAML_NAT_TYPE_ERASURE
      numericScale (aunit : Numeric n)
#else
      numericScale @n
#endif
      

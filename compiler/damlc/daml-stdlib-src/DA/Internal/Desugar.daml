-- Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE CPP #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE NoImplicitPrelude #-}


-- | HIDE Automatically imported qualified in every module.
module DA.Internal.Desugar (
    module DA.Internal.Template,
    module DA.Internal.Template.Functions,
    module DA.Internal.Exception,
    Eq(..), Show(..),
    Bool(..), Text, Optional(..),
    concat, magic,
    Party, ContractId, Update, Any,
    NonConsuming(..), PreConsuming(..), PostConsuming(..), Consuming(..),
    Implements(..),
    TypeRep,
    HasMethod,
    mkMethod,
) where

import DA.Internal.Prelude
import DA.Internal.Template
import DA.Internal.Template.Functions
import DA.Internal.LF
#ifndef DAML_EXCEPTIONS
import DA.Internal.Exception ()
#else
import DA.Internal.Exception
#endif
import GHC.Types (magic, Symbol)

-- These are only used as markers by desugaring, we do not translate them to LF.
data NonConsuming t = NonConsuming {}
data PreConsuming t = PreConsuming {}
data Consuming t = Consuming {}
data PostConsuming t = PostConsuming {}

class Implements t i where
  toInterface : t -> i
  fromInterface : i -> Optional t
  toInterfaceContractId : ContractId t -> ContractId i
  fromInterfaceContractId : ContractId i -> Update (Optional (ContractId t))
  interfaceTypeRep : t -> TypeRep

{-
Together, `HasMethod`, `Method` and `mkMethod` allow us to desugar the methods of
an interface implementation in `RdrHsSyn`, while ensuring that all implementations
have the same type.

Given

> interface Iface where
>   myMethod : MyMethodType

`RdrHsSyn` generates this instance of `HasMethod`

> instance HasMethod Iface "myMethod" MyMethodType

Meanwhile, given

> template Tplt
>   with
>     ...
>   where
>     ...
>     implements Iface where
>       let myMethod = myMethodImpl this

`RdrHsSyn` generates the following binding

> _method_Tplt_Iface_myMethod = mkMethod @Tplt @Iface @"myMethod" (\this -> myMethodImpl this)

Note that `RdrHsSyn` cannot give a type signature to `_method_Tplt_Iface_myMethod`, since
the type of the method is not available in the `implements` block.

Then how can we ensure that all implementations of that method have the right type?
By wrapping the method implementation in the `Method t i m r` type using the
`mkMethod` function with the necessary type applications, we bind the first three
type variables `t i m` to the template, interface and method name types, respectively.
Then, the functional dependency `i m -> r` in the `HasMethod` class guarantees
that for the given interface type and method name, the return type `r` is fixed.
Finally, the compiler has to unify the argument to `mkMethod` with the type
`t -> r`, guaranteeing that all implementations have the correct type.
-}

-- Read: Interface `i` has a method named `m` with return type `r`
class HasMethod i (m : Symbol) r | i m -> r

newtype Method t i (m : Symbol) r = Method { unMethod : t -> r }

mkMethod : (Implements t i, HasMethod i m r) => (t -> r) -> Method t i m r
mkMethod = Method

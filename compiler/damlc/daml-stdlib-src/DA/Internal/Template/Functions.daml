-- Copyright (c) 2020 The DAML Authors. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE ScopedTypeVariables #-}

daml 1.2
-- This is the companion module (is that a word? now it is!) to DA.Internal.Template
-- which provides functions and typeclasses.
-- DA.Internal.Template ends up in its own module with
-- a fixed package id so that the hash of the types does not change.
-- | MOVE Prelude DAML-LF primitives, just templates/contracts
module DA.Internal.Template.Functions where

#ifdef DAML_ANY_TYPE
import DA.Internal.Any
#endif
import DA.Internal.LF
import DA.Internal.Prelude
import DA.Internal.Template

#ifdef DAML_GENMAP && DAML_ANY_TYPE
import GHC.Types (primitive)
#endif

-- | Constraints satisfied by template types.
type Template t =
  ( HasSignatory t
  , HasObserver t
  , HasEnsure t
  , HasAgreement t
  , HasCreate t
  , HasFetch t
  , HasArchive t
#ifdef DAML_TYPE_REP
  , HasTemplateTypeRep t
#ifdef DAML_ANY_TYPE
  , HasToAnyTemplate t
  , HasFromAnyTemplate t
#endif
#endif
  )

class HasSignatory t where
  -- | The signatories of a contract.
  signatory : t -> [Party]

class HasObserver t where
  -- | The observers of a contract.
  observer : t -> [Party]

class HasEnsure t where
  -- | A predicate that must be true, otherwise contract creation will fail.
  ensure : t -> Bool

class HasAgreement t where
  -- | The agreement text of a contract.
  agreement : t -> Text

class HasCreate t where
  -- | Create a contract based on a template `t`.
  create : t -> Update (ContractId t)

class HasFetch t where
  -- | Fetch the contract data associated with the given contract ID.
  -- If the `ContractId t` supplied is not the contract ID of an active
  -- contract, this fails and aborts the entire transaction.
  fetch : ContractId t -> Update t

class HasArchive t where
  -- | Archive the contract with the given contract ID.
  archive : ContractId t -> Update ()

-- | The stakeholders of a contract: its signatories and observers.
stakeholder : (HasSignatory t, HasObserver t) => t -> [Party]
stakeholder t = signatory t ++ observer t

-- | Constraints satisfied by template choice types.
type Choice t c r =
  ( Template t
  , HasExercise t c r
#ifdef DAML_TYPE_REP && DAML_ANY_TYPE
  , HasToAnyChoice t c r
  , HasFromAnyChoice t c r
#endif
  )

class HasExercise t c r | t c -> r where
  -- | Exercise a choice on the contract with the given contract ID.
  exercise : ContractId t -> c -> Update r

-- | Constrants satisfied by template key types.
type TemplateKey t k =
  ( Template t
  , HasKey t k
  , HasLookupByKey t k
  , HasFetchByKey t k
  , HasMaintainer t k
#ifdef DAML_TYPE_REP && DAML_ANY_TYPE
  , HasToAnyContractKey t k
  , HasFromAnyContractKey t k
#endif
  )

class HasKey t k | t -> k where
  -- | The key of a contract.
  key : t -> k

class HasLookupByKey t k | t -> k where
  -- | Look up the contract ID `t` associated with a given contract key `k`.
  --
  -- You must pass the `t` using an explicit type application. For
  -- instance, if you want to look up a contract of template `Account` by its
  -- key `k`, you must call `lookupByKey @Account k`.
  lookupByKey : k -> Update (Optional (ContractId t))

class HasFetchByKey t k | t -> k where
  -- | Fetch the contract ID and contract data associated with a given
  -- contract key.
  --
  -- You must pass the `t` using an explicit type application. For
  -- instance, if you want to fetch a contract of template `Account` by its
  -- key `k`, you must call `fetchByKey @Account k`.
  fetchByKey : k -> Update (ContractId t, t)

class HasMaintainer t k | t -> k where
  -- NOTE(F. Mazzoli): the motivation for this function to return both the
  -- contract ID and the contract instance is that `fetchByKey` results in
  -- a fetch node in the transaction structure, and the fetch node
  -- contains the contract data, so we might as well include it here.
  --
  -- The reason why turning it into a fetch node is necessary is that:
  -- 1. We want to have it a more relaxed authorization rule than
  --    `lookupByKey`, which gets turned into a LookupByKey node;
  -- 2. We want it to have the same authorization rules of a normal
  --    fetch, and to implement _that_, we need to know what the
  --    stakeholders of the fetched contract are, which requires
  --    getting the contract instance.

  -- | The list of maintainers of a contract key.
  _maintainer : proxy t -> k -> [Party]

-- | The list of maintainers of a contract key.
maintainer : forall t k. HasMaintainer t k => k -> [Party]
maintainer = _maintainer ([] : [t])

-- | Exercise a choice on the contract associated with the given key.
--
-- You must pass the `t` using an explicit type application. For
-- instance, if you want to exercise a choice `Withdraw` on a contract of
-- template `Account` given by its key `k`, you must call
-- `exerciseByKey @Account k Withdraw`.
exerciseByKey : forall t k c r. (HasFetchByKey t k, HasExercise t c r) => k -> c -> Update r
exerciseByKey k c = do
    (cid, _) <- fetchByKey @t k
    exercise cid c

-- | Create a contract and exercise the choice on the newly created contract.
createAndExercise : forall t k c r. (HasCreate t, HasExercise t c r) => t -> c -> Update r
createAndExercise t c = do
    cid <- create t
    exercise cid c

-- | Accepted ways to specify a list of parties: either a single party, or a list of parties.
class IsParties a where
  -- | Convert to list of parties.
  toParties : a -> [Party]

instance IsParties Party where
  toParties p = [p]

instance IsParties [Party] where
  toParties ps = ps

instance IsParties (Optional Party) where
  toParties None = []
  toParties (Some p) = [p]

#ifdef DAML_GENMAP && DAML_ANY_TYPE

-- We do not separate generic equality from generic maps so this guards on DAML_GENMAP.

-- We do not have a general Eq instance for Any since Any is not exposed
-- to users directly and that instance will crash on some values but
-- we can have total Eq instances for AnyTemplate, AnyChoice and AnyContractKey
-- since those are guaranteed to be serializable.
eqAny : Any -> Any -> Bool
eqAny = primitive @"BEEqual"

instance Eq AnyTemplate where
  AnyTemplate a == AnyTemplate b = eqAny a b

instance Eq AnyChoice where
  AnyChoice aAny aRep == AnyChoice bAny bRep =
    eqAny aAny bAny && aRep == bRep

instance Eq AnyContractKey where
  AnyContractKey aAny aRep == AnyContractKey bAny bRep =
    eqAny aAny bAny && aRep == bRep
#endif

#ifdef DAML_TYPE_REP

class HasTemplateTypeRep t where
  -- | Generate a unique textual representation of the template Id.
  _templateTypeRep : proxy t -> TypeRep

-- | Generate a unique textual representation of the template Id.
templateTypeRep : forall t. HasTemplateTypeRep t => TemplateTypeRep
templateTypeRep = TemplateTypeRep (_templateTypeRep ([] : [t]))

instance Eq TemplateTypeRep where
  TemplateTypeRep a == TemplateTypeRep b = a == b

#ifdef DAML_ANY_TYPE

class HasToAnyTemplate t where
  _toAnyTemplate : t -> Any

class HasFromAnyTemplate t where
  _fromAnyTemplate : Any -> Optional t

class HasToAnyChoice t c r | t c -> r where
  _toAnyChoice : proxy t -> c -> Any

class HasFromAnyChoice t c r | t c -> r where
  _fromAnyChoice : proxy t -> Any -> Optional c

class HasToAnyContractKey t k | t -> k where
  _toAnyContractKey : proxy t -> k -> Any

class HasFromAnyContractKey t k | t -> k where
  _fromAnyContractKey : proxy t -> Any -> Optional k

-- | Wrap the template in AnyTemplate
toAnyTemplate : HasToAnyTemplate t => t -> AnyTemplate
toAnyTemplate x = AnyTemplate (_toAnyTemplate x)

-- | Extract the underlying template from AnyTemplate if the type matches
-- or return `None`.
fromAnyTemplate : HasFromAnyTemplate t => AnyTemplate -> Optional t
fromAnyTemplate (AnyTemplate x) = _fromAnyTemplate x

toAnyChoice : forall t c r. Choice t c r => c -> AnyChoice
toAnyChoice c =
  AnyChoice
    (_toAnyChoice ([] : [t]) c)
    (templateTypeRep @t)

fromAnyChoice : forall t c r. Choice t c r => AnyChoice -> Optional c
fromAnyChoice (AnyChoice any typeRep)
  | Some c <- _fromAnyChoice ([] : [t]) any
  , templateTypeRep @t == typeRep = Some c
  | otherwise = None

toAnyContractKey : forall t k. TemplateKey t k => k -> AnyContractKey
toAnyContractKey k =
  AnyContractKey
    (_toAnyContractKey ([] : [t]) k)
    (templateTypeRep @t)

fromAnyContractKey : forall t k. TemplateKey t k => AnyContractKey -> Optional k
fromAnyContractKey (AnyContractKey any rep)
  | Some k <- _fromAnyContractKey ([] : [t]) any
  , templateTypeRep @t == rep = Some k
  | otherwise = None
#endif
#endif

deriving instance Eq Archive
deriving instance Show Archive

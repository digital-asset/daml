-- Copyright (c) 2019 The DAML Authors. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE ScopedTypeVariables #-}

daml 1.2
-- | MOVE Prelude DAML-LF primitives, just templates/contracts
module DA.Internal.Template where

import DA.Internal.LF
import DA.Internal.Prelude

class Template t where

  -- | The signatories of a contract.
  signatory : t -> [Party]

  -- | The observers of a contract.
  observer : t -> [Party]

  -- | A predicate that must be true, otherwise contract creation will fail.
  ensure : t -> Bool

  -- | The agreement text of a contract.
  agreement : t -> Text

  -- | Create a contract based on a template `t`.
  create : t -> Update (ContractId t)

  -- | Fetch the contract data associated with the given contract ID.
  -- If the `ContractId t` supplied is not the contract ID of an active
  -- contract, this fails and aborts the entire transaction.
  fetch : ContractId t -> Update t

  -- | Archive the contract with the given contract ID.
  archive : ContractId t -> Update ()

  -- | Wrap the template in AnyTemplate
  toAnyTemplate : t -> AnyTemplate

  -- | Extract the underlying template from AnyTemplate if the type matches
  -- or return `None`.
  fromAnyTemplate : AnyTemplate -> Optional t

  -- | Generate a unique textual representation of the template Id.
  _templateTypeRep : proxy t -> TemplateTypeRep

-- | Generate a unique textual representation of the template Id.
templateTypeRep : forall t. Template t => TemplateTypeRep
templateTypeRep = _templateTypeRep ([] : [t])

-- | The stakeholders of a contract: its signatories and observers.
stakeholder : Template t => t -> [Party]
stakeholder t = signatory t ++ observer t

class Template t => Choice t c r | t c -> r where
  -- | Exercise a choice on the contract with the given contract ID.
  exercise : ContractId t -> c -> Update r
  _toAnyChoice : proxy t -> c -> Any
  _fromAnyChoice : proxy t -> Any -> Optional c

toAnyChoice : forall t c r. Choice t c r => c -> AnyChoice
toAnyChoice c =
  AnyChoice
    (_toAnyChoice ([] : [t]) c)
    (templateTypeRep @t)

fromAnyChoice : forall t c r. Choice t c r => AnyChoice -> Optional c
fromAnyChoice (AnyChoice any typeRep)
  | Some c <- _fromAnyChoice ([] : [t]) any
  , templateTypeRep @t == typeRep = Some c
  | otherwise = None

class Template t => TemplateKey t k | t -> k where
  -- | The key of a contract.
  key : t -> k

  -- | Look up the contract ID `t` associated with a given contract key `k`.
  --
  -- You must pass the `t` using an explicit type application. For
  -- instance, if you want to look up a contract of template `Account` by its
  -- key `k`, you must call `lookupByKey @Account k`.
  lookupByKey : k -> Update (Optional (ContractId t))

  -- | Fetch the contract ID and contract data associated with a given
  -- contract key.
  --
  -- You must pass the `t` using an explicit type application. For
  -- instance, if you want to fetch a contract of template `Account` by its
  -- key `k`, you must call `fetchByKey @Account k`.
  fetchByKey : k -> Update (ContractId t, t)
  -- NOTE(FM): the motivation for this function to return both the
  -- contract ID and the contract instance is that `fetchByKey` results in
  -- a fetch node in the transaction structure, and the fetch node
  -- contains the contract data, so we might as well include it here.
  --
  -- The reason why turning it into a fetch node is necessary is that:
  -- 1. We want to have it a more relaxed authorization rule than
  --    `lookupByKey`, which gets turned into a LookupByKey node;
  -- 2. We want it to have the same authorization rules of a normal
  --    fetch, and to implement _that_, we need to know what the
  --    stakeholders of the fetched contract are, which requires
  --    getting the contract instance.

  -- | The list of maintainers of a contract key.
  _maintainer : proxy t -> k -> [Party]

  _toAnyContractKey : proxy t -> k -> Any
  _fromAnyContractKey : proxy t -> Any -> Optional k

-- | The list of maintainers of a contract key.
maintainer : forall t k. TemplateKey t k => k -> [Party]
maintainer = _maintainer ([] : [t])

toAnyContractKey : forall t k. TemplateKey t k => k -> AnyContractKey
toAnyContractKey k =
  AnyContractKey
    (_toAnyContractKey ([] : [t]) k)
    (templateTypeRep @t)

fromAnyContractKey : forall t k. TemplateKey t k => AnyContractKey -> Optional k
fromAnyContractKey (AnyContractKey any rep)
  | Some k <- _fromAnyContractKey ([] : [t]) any
  , templateTypeRep @t == rep = Some k
  | otherwise = None

-- | Exercise a choice on the contract associated with the given key.
--
-- You must pass the `t` using an explicit type application. For
-- instance, if you want to exercise a choice `Withdraw` on a contract of
-- template `Account` given by its key `k`, you must call
-- `exerciseByKey @Account k Withdraw`.
exerciseByKey : forall t k c r. (TemplateKey t k, Choice t c r) => k -> c -> Update r
exerciseByKey k c = do
    (cid, _) <- fetchByKey @t k
    exercise cid c

-- | Create a contract and exercise the choice on the newly created contract.
createAndExercise : forall t k c r. Choice t c r => t -> c -> Update r
createAndExercise t c = do
    cid <- create t
    exercise cid c

data NonConsuming t = NonConsuming {}
data PreConsuming t = PreConsuming {}
data PostConsuming t = PostConsuming {}

-- | The data type corresponding to the implicit `Archive`
-- choice in every template.
data Archive = Archive {}
  deriving (Eq, Show)

-- | Accepted ways to specify a list of parties: either a single party, or a list of parties.
class IsParties a where
  -- | Convert to list of parties.
  toParties : a -> [Party]

instance IsParties Party where
  toParties p = [p]

instance IsParties [Party] where
  toParties ps = ps

instance IsParties (Optional Party) where
  toParties None = []
  toParties (Some p) = [p]

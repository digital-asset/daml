-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
-- | Math - Utility Math functions for `Int` and `Decimal`
module DA.Math
( Powerable(..)
) where

infixr 8 ^^
infixr 8 **


class (Multiplicative a, Fractional a) => Powerable a where
  -- | Take an integer power of a number. Example: `2.0 ^^ 2 == 4.0`.
  (^^) : a -> Int -> a
  -- | Take a power of a number Example: `2.0 ** 2.0 == 4.0`.
  (**) : a -> a -> a
  -- | The exponential function. Example: `exp 0.0 == 1.0`
  exp : a -> a
  -- | The natural logarithm. Example: `log 10.0 == 2.30258509299`
  log :a -> a
  -- | The logarithm of a number to a given base. Example: `log 10.0 100.0 == 2.0`
  logBase : a -> a -> a


instance Powerable Decimal where
  x ^^ n
    | n == 0 = 1.0
    | n < 0 = 1.0 / x ^^ (negate $ n)
    | otherwise = x * x ^^ (n - 1)

  x ** y = exp (y * log x)

  exp x
    | x == 0.0 = 1.0
    | x < 0.0 = 1.0 / exp (negate x)
    | otherwise =
      let (y, e) = expInner 1.0 1.0 x
      in y `e10` e

  log x = logt1000 x / 1000.0

  logBase b x = log x / log b

logt1000: Decimal -> Decimal
logt1000 x
  | x == 10.0 = ln10t1000
  | x > 10.0 = ln10t1000 + logt1000 (x / 10.0)
  | x < 0.1 = logt1000 (x * 10.0) - ln10t1000
  | x > 1.5 = ln2t1000 + logt1000 (x / 2.0)
  | x < 0.5 = logt1000 (x * 2.0) - ln2t1000
  | otherwise = logt1000Inner 10 x
  where
    ln10t1000 = 2302.5850929940456840
    ln2t1000 = 693.14718055994

logt1000Inner: Int -> Decimal -> Decimal
logt1000Inner n x 
  | n < 0 = 0.0
  | otherwise = let
      f = (x - 1.0) / (x + 1.0)
      p = (2 * n + 1)
      term = (2000.0 / intToDecimal p) * f ^^ p
    in
    term + logt1000Inner (n - 1) x

e10: Decimal -> Int -> Decimal
e10 x n
  | n == 0 = x
  | n > 0 = e10 (x * 10.0) (n - 1)
  | otherwise = e10 (x / 10.0) (n + 1)

to36dig: (Decimal, Int) -> (Decimal, Int)
to36dig (x, n)
  | x < 1.0 `e10` 25 = to36dig (x * 10.0, n - 1)
  | x > 1.0 `e10` 26 = to36dig (x / 10.0, n + 1)
  | otherwise = (x, n)

expInner: Decimal -> Decimal -> Decimal -> (Decimal, Int)
expInner n t x
  | t == 0.0 = (1.0, 0)
  | otherwise =
    let 
      (y, e) = expInner (n + 1.0) (t * x / n) x
      z = 1.0 `e10` (negate e)
    in to36dig (z + x * y / n, e)

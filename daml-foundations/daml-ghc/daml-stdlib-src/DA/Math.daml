-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
-- | Math - Utility Math functions for `Int` and `Decimal`
module DA.Math
( Powerable(..)
, sin
, cos
, tan
, pi
) where

import DA.List

infixr 8 ^^
infixr 8 **

class (Multiplicative a, Fractional a) => Powerable a where
  -- | Take an integer power of a number. Example: `2.0 ^^ 2 == 4.0`.
  (^^) : a -> Int -> a
  -- | Take a power of a number Example: `2.0 ** 2.0 == 4.0`.
  (**) : a -> a -> a
  -- | The exponential function. Example: `exp 0.0 == 1.0`
  exp : a -> a
  -- | The natural logarithm. Example: `log 10.0 == 2.30258509299`
  log :a -> a
  -- | The logarithm of a number to a given base. Example: `log 10.0 100.0 == 2.0`
  logBase : a -> a -> a

instance Powerable Decimal where
  x ^^ n
    | n == 0 = 1.0
    | n < 0 = 1.0 / x ^^ (negate $ n)
    | otherwise = x * x ^^ (n - 1)

  x ** y = exp (y * log x)

  exp x
    | x == 0.0 = 1.0
    | x < 0.0 = 1.0 / exp (negate x)
    | otherwise =
      let (y, e) = expInner 1.0 1.0 x
      in y `e10` e

  log x = logt10k x / 10000.0

  logBase b x = log x / log b

-- | `logt10k x` calculates 10000.0 * ln(x). The reason for
-- doing this is to preserve four additional decimal points
-- for precision.
-- The additive nature of `ln` is used to decompose
-- ln(x) == ln(10^m * 2^n * y) == m * ln(10) + n * ln(2) + ln(y)
-- where 0.5 < y < 1.5.
logt10k: Decimal -> Decimal
logt10k x
  | x == 1.0 = 0.0
  | x > 10.0 = ln10t10k + logt10k (x / 10.0)
  | x < 0.1 = logt10k (x * 10.0) - ln10t10k
  | x > 1.5 = ln2t10k + logt10k (x / 2.0)
  | x < 0.5 = logt10k (x * 2.0) - ln2t10k
  | otherwise = logt10kInner 10 x
  where
    ln10t10k = 23025.8509299405
    ln2t10k = 6931.4718055994

-- | `log10kInner n x` approximates 10000 * ln(x) using n terms of the
-- power series expansion of ln(x) = 2 * artanh((x - 1) / (x + 1)) 
logt10kInner: Int -> Decimal -> Decimal
logt10kInner n x 
  | n < 0 = 0.0
  | otherwise = let
      f = (x - 1.0) / (x + 1.0)
      p = (2 * n + 1)
      term = (20000.0 / intToDecimal p) * f ^^ p
    in
    term + logt10kInner (n - 1) x

-- | `e10` is used to shift the decimal point in decimal notation.
-- `e10 x n == x * intToDecimal (10 ^ n)`.
e10: Decimal -> Int -> Decimal
e10 x n
  | n == 0 = x
  | n > 0 = e10 (x * 10.0) (n - 1)
  | otherwise = e10 (x / 10.0) (n + 1)

-- | `Sci` represents a number in scientific notation. `(x, n)` is
-- to be read as `x * 10^n`.
type Sci = (Decimal, Int)

-- | `to36dig` tries to put a number in scientific notation in a form
-- where the `x` has order of magnitude 10^26. Given the fixed point
-- NUMBER(38,10) format of `Decimal` in DAML, this gives good
-- precision with a little bit of room to multiply with numbers less
-- than 100.
to36dig: Sci -> Sci
to36dig (x, n)
  | x < 1.0 `e10` 25 = to36dig (x * 10.0, n - 1)
  | x > 1.0 `e10` 26 = to36dig (x / 10.0, n + 1)
  | otherwise = (x, n)

-- | `expInner` calculates the expansion
-- 1 + x/n * (1 + x/(n+1) * (1 + x/(n+2) * ...))
-- to a depth where t * x^k * n! / k! < 10^-10.
-- The sole purpose is to calculate `exp = expInner 1.0 1.0`
-- In the most precision-preserving way.
expInner: Decimal -> Decimal -> Decimal -> Sci
expInner n t x
  | t == 0.0 = (1.0, 0)
  | otherwise =
    let 
      (y, e) = expInner (n + 1.0) (t * x / n) x
      z = 1.0 `e10` (negate e)
    in to36dig (z + x * y / n, e)

-- | `sin` is the sine function
sin: Decimal -> Decimal
sin x = snd $ cordic 34 x

-- | `cos` is the cosine function
cos: Decimal -> Decimal
cos x = fst $ cordic 34 x

-- | `tan` is the tangent function
tan: Decimal -> Decimal
tan x = s / c
  where
    (c, s) = cordic 34 x

-- | The number Pi
pi: () -> Decimal
pi () = 3.1415926536

-- | `cordic` is an implementation of the CORDIC algorithm.
-- | `cordic n r == (sin(r), cos(r))` computed to n iterations
cordic: Int -> Decimal -> (Decimal, Decimal)
cordic n r 
  | r < 0.0 = cordic n (r + 2.0 * pi)
  | r > 2.0 * pi = cordic n (r - 2.0 * pi)
  | r > pi =
    let (c, s) = cordic n (r - pi)
    in (-c, -s)
  | r > pi / 2.0 =
    let (c, s) = cordic n (pi - r)
    in (c, -s)
  | otherwise =
    let (c, s) = cordicInner n r (1.0, 0.0) 1.0 angles
    in (kn * c, kn * s)
  where
    pi = 3.14159265359
    angles =
      [ 0.78539816339745, 0.46364760900081, 0.24497866312686, 0.12435499454676
      , 0.06241880999596, 0.03123983343027, 0.01562372862048, 0.00781234106010
      , 0.00390623013197, 0.00195312251648, 0.00097656218956, 0.00048828121119
      , 0.00024414062015, 0.00012207031189, 0.00006103515617, 0.00003051757812
      , 0.00001525878906, 0.00000762939453, 0.00000381469727, 0.00000190734863
      , 0.00000095367432, 0.00000047683716, 0.00000023841858, 0.00000011920929
      , 0.00000005960464, 0.00000002980232, 0.00000001490116, 0.00000000745058
      , 0.0000000037253 , 0.0000000018626 , 0.00000000093132, 0.00000000046566
      , 0.00000000023283, 0.00000000011642 ]
  
    ks = 
      [ 0.70710678118655, 0.63245553203368, 0.61357199107790, 0.60883391251775
      , 0.60764825625617, 0.60735177014130, 0.60727764409353, 0.60725911229889
      , 0.60725447933256, 0.60725332108988, 0.60725303152913, 0.60725295913894
      , 0.60725294104140, 0.60725293651701, 0.60725293538591, 0.60725293510314
      , 0.60725293503245, 0.60725293501477, 0.60725293501035, 0.60725293500925
      , 0.60725293500897, 0.60725293500890, 0.60725293500889, 0.60725293500888 ]
    kn = if n < 24
      then ks !! n
      else last ks
    
-- | `cordicInner` implements the inner loop of the CORDIC algorithm
cordicInner: Int -> Decimal -> (Decimal, Decimal) -> Decimal -> [Decimal] -> (Decimal, Decimal)
cordicInner n r v pt angles
  | n == 1 = nv
  | otherwise = cordicInner (n-1) nr nv npt nangles
  where
    (nangles, angle) = case angles of
      [a] -> ([a / 2.0], a / 2.0)
      a :: as -> (as, a)
      _ -> error "empty angles"
    sigma = if r < 0.0 then negate 1.0 else 1.0
    f = sigma * pt
    nv = (fst v - f * snd v, f * fst v + snd v)
    nr = r - sigma * angle
    npt = pt / 2.0

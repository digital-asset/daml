-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
-- | Math - Utility Math functions for `Int` and `Decimal`
module DA.Math
( Powerable(..)
) where

infixr 8 ^^
infixr 8 **


class (Multiplicative a, Fractional a) => Powerable a where
  -- | Take an integer power of a number. Example: `2.0 ^^ 2 == 4.0`.
  (^^) : a -> Int -> a
  -- | Take a power of a number Example: `2.0 ** 2.0 == 4.0`.
  (**) : a -> a -> a
  -- | The exponential function. Example: `exp 0.0 == 1.0`
  exp : a -> a
  -- | The natural logarithm. Example: `log 10.0 == 2.30258509299`
  log :a -> a
  -- | The logarithm of a number to a given base. Example: `log 10.0 100.0 == 2.0`
  logBase : a -> a -> a


instance Powerable Decimal where
  x ^^ n
    | n == 0 = 1.0
    | n < 0 = 1.0 / x ^^ (negate $ n)
    | otherwise = x * x ^^ (n - 1)

  x ** y = exp (y * log x)

  exp x
    | x == 0.0 = 1.0
    | x < 0.0 = 1.0 / exp (negate x)
    | otherwise = 1.0 + expInner 1.0 1.0 x 1.0 x

  log x = logt100 x / 100.0

  logBase b x = log x / log b

logt100: Decimal -> Decimal
logt100 x
  | x == 10.0 = ln10t100
  | x > 10.0 = ln10t100 + logt100 (x / 10.0)
  | x < 0.1 = logt100 (x * 10.0) - ln10t100
  | x > 1.5 = ln2t100 + logt100 (x / 2.0)
  | x < 0.5 = logt100 (x * 2.0) - ln2t100
  | otherwise = logt100Inner 10 x
  where
    ln10t100 = 230.25850929940456840
    ln2t100 = 69.314718055994

logt100Inner: Int -> Decimal -> Decimal
logt100Inner n x 
  | n < 0 = 0.0
  | otherwise = let
      f = (x - 1.0) / (x + 1.0)
      p = (2 * n + 1)
      term = (200.0 / intToDecimal p) * f ^^ p
    in
    term + logt100Inner (n - 1) x
    

expInner: Decimal -> Decimal -> Decimal -> Decimal -> Decimal -> Decimal
-- | We keep track of nominator and denominator of term, but
-- | squash them once we get close to overflow
expInner n s xn nf x
  | term == 0.0 = 0.0
  -- Lots of rules to try balancing precision between s, xn and xf
  | nf > xn = expInner n (s / squashFactor) xn (nf / squashFactor) x
  | nf > expBound = expInner n s (xn / squashFactor) (nf / squashFactor) x
  | xn > expBound  && nf > squashFactor ^^ 2 = expInner n s (xn / squashFactor) (nf / squashFactor) x
  | s > squashFactor && nf > squashFactor ^^ 2= expInner n (s / squashFactor)xn (nf / squashFactor) x
  | xn > expBound  = expInner n (s * squashFactor) (xn / squashFactor) nf x
  | otherwise = term + expInner (n + 1.0) s (xn * x) (nf * (n + 1.0)) x 
  where
    term = s * (xn / nf)
    -- Constants controlling how precisions are balanced
    expBound = 10.0 ^^ 20
    squashFactor = 10.0 ^^ 5

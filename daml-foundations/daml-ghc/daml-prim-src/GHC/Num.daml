-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE NoImplicitPrelude #-}
daml 1.2

-- | MOVE Prelude
--   Has to live here so GHC can find it for deriving instances.
module GHC.Num
  ( Additive (..)
  , Multiplicative (..)
  , Fractional (..)
  , Signed (..)
  , Number (..)
  , (%)
  ) where

import GHC.Base
import GHC.Classes
import GHC.CString
import GHC.Err
import GHC.Integer.Type
import GHC.Real
import GHC.Types

default ()              -- Double isn't available yet,
                        -- and we shouldn't be using defaults anyway

infixl 6 -
infixl 6 +
infixl 7 *
infixr 8 ^
infixl 7 /
infixl 7 %

-- | Basic additive class.
-- Instances are expected to respect the following laws:
--
-- **Associativity of (+)**:`(x + y) + z` = `x + (y + z)`
--
-- **Commutativity of (+)**: `x + y` = `y + x`
--
-- `x + aunit` = `x`
--
-- `negate` **gives the additive inverse**: `x + negate x` = aunit
--
class Additive a  where
    {-# MINIMAL (+), aunit, (negate | (-)) #-}
    (+), (-)            : a -> a -> a
    -- Unary negation.
    negate              : a -> a

    aunit                : a

    {-# INLINE (-) #-}
    x - y               = x + negate y

    {-# INLINE negate #-}
    negate x            = aunit - x

-- | Basic multiplicative class.
-- Instances are expected to respect the following laws:
--
-- **Associativity of (*)**:`(x * y) * z` = `x * (y * z)`
--
-- **Commutativity of (*)**: `x * y` = `y * x`
--
-- `x * one` = `x`
--
class Multiplicative a where
    (*) : a -> a -> a
    munit : a
    -- | `x ^ n` raises `x` to the power of `n`.
    (^): a -> Int -> a

-- | Basic numeric class.
-- Instances are usually expected to respect the following law
-- (in addition to laws from being additive and multiplicative)
--
-- **Distributivity of (*) with respect to (+)**:
--     `a * (b + c)` = `(a * b) + (a * c)` and `(b + c) * a` = `(b * a) + (c * a)`
class (Additive a, Multiplicative a) => Number a where
  -- no methods

class Signed a where
    -- Sign of a number.
    -- For real numbers, the 'signum' is either `-1` (negative), `0` (zero)
    -- or `1` (positive).
    signum : a -> a

    -- | Absolute value.
    abs : a -> a

instance Additive Int where
    (+) = primitive @"BEAddInt64"
    (-) = primitive @"BESubInt64"
    negate x = 0 - x
    aunit = 0

instance Multiplicative Int where
    (*) = primitive @"BEMulInt64"
    munit = 1
    (^) = primitive @"BEExpInt64"

instance Number Int where
    -- no methods

instance Signed Int where
    signum x = if x == 0 then 0 else if x <= 0 then (-1) else 1
    abs x = if x <= 0 then negate x else x

instance Additive Decimal where
    (+) = primitive @"BEAddDecimal"
    (-) = primitive @"BESubDecimal"
    negate x = 0.0 - x
    aunit = 0.0

instance Multiplicative Decimal where
    (*) = primitive @"BEMulDecimal"
    munit = 1.0
    x ^ n
        | n == 0 = 1.0
        | n == 2 = x * x
        | n < 0 = 1.0 / x ^ (negate n)
        | n % 2 == 0 = (x ^ (n / 2)) ^ 2
        | otherwise = x * x ^ (n - 1)

instance Number Decimal where
    -- no methods

instance Signed Decimal where
    signum x = if x == 0.0 then 0.0 else if x <= 0.0 then (-1.0) else 1.0
    abs x = if x <= 0.0 then negate x else x

class (Multiplicative a) => Fractional a where
    -- | `x / y` divides `x` by `y`.
    (/)                 : a -> a -> a

    -- | Calculate the reciprocal: `recip x` is `1/x`.
    recip               : a -> a
    x / y               = x * recip y

instance Fractional Decimal where
    (/) = primitive @"BEDivDecimal"
    recip x = 1.0 / x

instance Fractional Int where
    (/) = primitive @"BEDivInt64"
    recip x = 1 / x

-- | `x % y` calculates the remainder of `x` by `y`
(%) : Int -> Int -> Int
(%) = primitive @"BEModInt64"

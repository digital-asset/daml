
// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package com.digitalasset.ledger.api.v1.admin;

option java_outer_classname = "PartyManagementServiceOuterClass";
option java_package = "com.digitalasset.ledger.api.v1.admin";

// Status: experimental interface, will change before it is deemed production
// ready

// Inspect the party management state of a ledger participant and modify the
// parts that are modifiable. We use 'backing participant' to refer to this
// specific participant in the methods of this API.
// When the participant is run in mode requiring authentication, all the calls 
// in this interface will respond with UNAUTHENTICATED, if the caller fails
// to provide a valid access token, and will respond with PERMISSION_DENIED, if
// the claims in the token are insufficient to perform a given operation.
// Subsequently, only specific errors of individual calls not related to 
// authorization will be described.
service PartyManagementService {

  // Return the identifier of the backing participant.
  // All horizontally scaled replicas should return the same id.
  // This method is expected to succeed provided the backing participant is 
  // healthy, otherwise it responds with INTERNAL grpc error.
  // daml-on-sql: returns an identifier supplied on command line at launch time
  // daml-on-kv-ledger: as above
  // canton: returns globally unique identifier of the backing participant
  rpc GetParticipantId (GetParticipantIdRequest) returns
    (GetParticipantIdResponse);

  // List the parties known by the backing participant.
  // The list returned contains parties whose ledger access is facilitated by
  // backing participant and the ones maintained elsewhere.
  // This request will always succeed.
  // TODO: Check what the use case is for listing non-local parties
  rpc ListKnownParties (ListKnownPartiesRequest) returns
    (ListKnownPartiesResponse);

  // Adds a new party to the set managed by the backing participant.
  // Caller specifies a party identifier suggestion, the actual identifier
  // allocated might be different and is implementation specific.
  // This call will either succeed or respond with ALREADY_EXISTS if given party
  // already exists and the party allocation scheme uses only request data to 
  // generate new stable identifiers.
  // daml-on-sql: suggestion's uniqueness is checked and call rejected if the
  // identifier is already present
  // daml-on-kv-ledger: suggestion's uniqueness is checked bby the validators in
  // the consensus layer and call rejected if the identifier is already present.
  // canton: completely different globally unique identifier is allocated.
  // Behind the scenes calls to an internal protocol are made. As that protocol
  // is richer than the the surface protocol, the arguments take implicit values
  rpc AllocateParty (AllocatePartyRequest) returns (AllocatePartyResponse);
}

message GetParticipantIdRequest {

  // Must correspond to the ledger ID reported by the Ledger Identification
  // Service.
  // Required
  string ledger_id = 1;
}

message GetParticipantIdResponse {

  // Identifier of the participant, which SHOULD be globally unique.
  string participant_id = 2;
}

message ListKnownPartiesRequest {

  // Must correspond to the ledger ID reported by the Ledger Identification
  // Service.
  // Required
  string ledger_id = 1;
}

message ListKnownPartiesResponse {

  // The details of all DAML parties hosted by the participant.
  // Required
  repeated PartyDetails party_details = 1;
}

message PartyDetails {

  // The stable unique identifier of a DAML party.
  // Required
  string party = 1;

  // Common name associated with the party.
  // Optional
  string common_name = 2;

  // id of the participant that this party is hosted on
  // Required
  string participant_id = 3;

  // Future extension: include metadata fields. There will be two categories
  // of such fields: common and implementation specific.
  // CommonMetadata common_metadata = 2;
  // bytes implementation_metadata = 3;
  
  // Canton-specific meta-data would contain the following:
  // string domain = 2;
  // string participant = 3;
  // com.digitalasset.canton.identity.v0.ParticipantPrivilege privilege = 4;
  // com.digitalasset.canton.identity.v0.TrustLevel trustLevel = 5;
}

message AllocatePartyRequest {

  // Must correspond to the ledger ID reported by the Ledger Identification
  // Service.
  // Required
  string ledger_id = 1;

  // Common name of the party to be added to the participant.
  // Required
  string common_name = 2;

  // Future extension: augment the request with additional meta-data containing
  // human readable party name, privileges, organization etc.
}

message AllocatePartyResponse {

  PartyDetails party_details = 1;
}
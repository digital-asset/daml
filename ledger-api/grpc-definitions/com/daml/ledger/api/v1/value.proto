// Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package com.daml.ledger.api.v1;

import "google/protobuf/empty.proto";

option java_outer_classname = "ValueOuterClass";
option java_package = "com.daml.ledger.api.v1";
option csharp_namespace = "Com.Daml.Ledger.Api.V1";

// Encodes values that the ledger accepts as command arguments and emits as contract arguments.
//
// The values encoding use different classes of non-empty strings as identifiers. Those classes are
// defined as follows:
// - NameStrings are strings with length <= 1000 that match the regexp ``[A-Za-z\$_][A-Za-z0-9\$_]*``.
// - PackageIdStrings are strings with length <= 64 that match the regexp ``[A-Za-z0-9\-_ ]+``.
// - PartyIdStrings are strings with length <= 256 that match the regexp ``[A-Za-z0-9:\-_ ]+``.
// - LedgerStrings are strings with length <= 256 that match the regexp ``[A-Za-z0-9#:\-_/ ]+``.
// - ApplicationIdStrings are strings with length <= 256 that match the regexp ``[A-Za-z0-9#:\-_/ @\|]+``.
//
message Value {
  oneof Sum {

    Record record = 1;

    Variant variant = 2;

    // Identifier of an on-ledger contract. Commands which reference an unknown or already archived contract ID will fail.
    // Must be a valid LedgerString.
    string contract_id = 3;

    // Represents a homogeneous list of values.
    List list = 4;

    sint64 int64 = 5 [jstype = JS_STRING];

    // A Numeric, that is a decimal value with precision 38 (at most 38 significant digits) and a
    // scale between 0 and 37 (significant digits on the right of the decimal point).
    // The field has to match the regex
    //   [+-]?\d{1,38}(.\d{0,37})?
    // and should be representable by a Numeric without loss of precision.
    string numeric = 6;

    // A string.
    string text = 8;

    // Microseconds since the UNIX epoch. Can go backwards. Fixed
    // since the vast majority of values will be greater than
    // 2^28, since currently the number of microseconds since the
    // epoch is greater than that. Range: 0001-01-01T00:00:00Z to
    // 9999-12-31T23:59:59.999999Z, so that we can convert to/from
    // https://www.ietf.org/rfc/rfc3339.txt
    sfixed64 timestamp = 9 [jstype = JS_STRING];

    // An agent operating on the ledger.
    // Must be a valid PartyIdString.
    string party = 11;

    // True or false.
    bool bool = 12;

    // This value is used for example for choices that don't take any arguments.
    google.protobuf.Empty unit = 13;

    // Days since the unix epoch. Can go backwards. Limited from
    // 0001-01-01 to 9999-12-31, also to be compatible with
    // https://www.ietf.org/rfc/rfc3339.txt
    int32 date = 14;

    // The Optional type, None or Some
    Optional optional = 15;

    // The Map type
    Map map = 16;

    // The Enum type
    Enum enum = 17;

    // The GenMap type
    GenMap gen_map = 18;
  }
}

// Contains nested values.
message Record {

  // Omitted from the update stream when verbose streaming is not enabled.
  // Optional when submitting commands.
  Identifier record_id = 1;

  // The nested values of the record.
  // Required
  repeated RecordField fields = 2;
}

// A named nested value within a record.
message RecordField {

  // When reading a update stream, it's omitted if verbose streaming is not enabled.
  // When submitting a commmand, it's optional:
  //   - if all keys within a single record are present, the order in which fields appear does not matter. however, each key must appear exactly once.
  //   - if any of the keys within a single record are omitted, the order of fields MUST match the order of declaration in the Daml template.
  // Must be a valid NameString
  string label = 1;

  // A nested value of a record.
  // Required
  Value value = 2;
}

// Unique identifier of an entity.
message Identifier {

  // The identifier of the Daml package that contains the entity.
  // Must be a valid PackageIdString.
  // Required
  string package_id = 1;

  reserved 2; // was `name` old compact representation of identifier.
              // removed in favor of  ``module_name`` and ``entity_name``.

  // The dot-separated module name of the identifier.
  // Required
  string module_name = 3;

  // The dot-separated name of the entity (e.g. record, template, ...) within the module.
  // Required
  string entity_name = 4;
}

// A value with alternative representations.
message Variant {

  // Omitted from the update stream when verbose streaming is not enabled.
  // Optional when submitting commands.
  Identifier variant_id = 1;

  // Determines which of the Variant's alternatives is encoded in this message.
  // Must be a valid NameString.
  // Required
  string constructor = 2;

  // The value encoded within the Variant.
  // Required
  Value value = 3;
}

// // A builtin exception value
// message BuiltinException {
//
//   // Determines the kind of builtin exception: ArithmeticError, GeneralError etc
//   // Required
//   string tag = 1;
//
//   // The value encoded within the Variant.
//   // Required
//   Value value = 2;
// }

// A value with finite set of alternative representations.
message Enum {

  // Omitted from the update stream when verbose streaming is not enabled.
  // Optional when submitting commands.
  Identifier enum_id = 1;

  // Determines which of the Variant's alternatives is encoded in this message.
  // Must be a valid NameString.
  // Required
  string constructor = 2;
}

// A homogenous collection of values.
message List {
  // The elements must all be of the same concrete value type.
  // Optional
  repeated Value elements = 1;
}

// Corresponds to Java's Optional type, Scala's Option, and Haskell's Maybe.
// The reason why we need to wrap this in an additional ``message`` is that we
// need to be able to encode the ``None`` case in the ``Value`` oneof.
message Optional {
  Value value = 1; // optional
}


message Map {
    message Entry {
        string key = 1;
        Value value = 2;
    }

    repeated Entry entries = 1;
}

message GenMap{
  message Entry {
    Value key = 1;
    Value value = 2;
  }

  repeated Entry entries = 1;
}

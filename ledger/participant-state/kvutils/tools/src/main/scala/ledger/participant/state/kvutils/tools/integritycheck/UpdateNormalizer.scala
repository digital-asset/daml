// Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.daml.ledger.participant.state.kvutils.tools.integritycheck

import com.daml.ledger.participant.state.v1.{RejectionReasonV0, Update}
import com.daml.lf.data.Time.Timestamp
import com.daml.lf.kv.TransactionNormalizer
import com.daml.lf.transaction.CommittedTransaction

/** Normalizes updates so that ones generated by different versions of the Daml SDK may be compared.
  * I.e., we just want to check the structured information.
  */
trait UpdateNormalizer {
  def normalize(update: Update): Update
}

object UpdateNormalizer {
  private val MandatoryNormalizers = List(
    RecordTimeNormalizer,
    RejectionReasonDescriptionNormalizer,
    ConfigurationChangeRejectionNormalizer,
  )

  def normalize(initialUpdate: Update, normalizers: Iterable[UpdateNormalizer]): Update = {
    (normalizers ++ MandatoryNormalizers).foldLeft(initialUpdate) { case (update, normalizer) =>
      normalizer.normalize(update)
    }
  }
}

/** Ignores the record time set later by post-execution because it's unimportant.
  * We only care about the update type and content.
  */
object RecordTimeNormalizer extends UpdateNormalizer {
  private val RecordTime = Timestamp.MinValue

  override def normalize(update: Update): Update = update match {
    case u: Update.ConfigurationChanged => u.copy(recordTime = RecordTime)
    case u: Update.ConfigurationChangeRejected => u.copy(recordTime = RecordTime)
    case u: Update.PartyAddedToParticipant => u.copy(recordTime = RecordTime)
    case u: Update.PartyAllocationRejected => u.copy(recordTime = RecordTime)
    case u: Update.PublicPackageUpload => u.copy(recordTime = RecordTime)
    case u: Update.PublicPackageUploadRejected => u.copy(recordTime = RecordTime)
    case u: Update.TransactionAccepted => u.copy(recordTime = RecordTime)
    case u: Update.CommandRejected => u.copy(recordTime = RecordTime)
  }
}

/** Rejection reason strings should always be ignored as they can change arbitrarily. */
object RejectionReasonDescriptionNormalizer extends UpdateNormalizer {
  override def normalize(update: Update): Update = update match {
    case commandRejected @ Update.CommandRejected(_, _, reason) =>
      val newReason = reason match {
        case RejectionReasonV0.Disputed(_) =>
          RejectionReasonV0.Disputed("")
        case RejectionReasonV0.Inconsistent(_) =>
          RejectionReasonV0.Inconsistent("")
        case RejectionReasonV0.InvalidLedgerTime(_) =>
          RejectionReasonV0.InvalidLedgerTime("")
        case RejectionReasonV0.PartyNotKnownOnLedger(_) =>
          RejectionReasonV0.PartyNotKnownOnLedger("")
        case RejectionReasonV0.ResourcesExhausted(_) =>
          RejectionReasonV0.ResourcesExhausted("")
        case RejectionReasonV0.SubmitterCannotActViaParticipant(_) =>
          RejectionReasonV0.SubmitterCannotActViaParticipant("")
        // don't map non V0 errors
        case x => x
      }
      commandRejected.copy(reason = newReason)
    case _ => update
  }
}

/** Rejection reason strings should always be ignored as they can change arbitrarily. */
object ConfigurationChangeRejectionNormalizer extends UpdateNormalizer {
  override def normalize(update: Update): Update = update match {
    case u: Update.ConfigurationChangeRejected => u.copy(rejectionReason = "")
    case _ => update
  }
}

/** We may not want to check blinding info as we haven't always populated these. */
object BlindingInfoNormalizer extends UpdateNormalizer {
  override def normalize(update: Update): Update = update match {
    case t: Update.TransactionAccepted => t.copy(blindingInfo = None)
    case _ => update
  }
}

/** We may not want to care about fetch and lookup-by-key nodes in the transaction tree attached to a
  * TransactionAccepted event as in some Daml SDK versions we are dropping them.
  */
object FetchAndLookupByKeyNodeNormalizer extends UpdateNormalizer {
  override def normalize(update: Update): Update = update match {
    case t: Update.TransactionAccepted =>
      t.copy(transaction = CommittedTransaction(TransactionNormalizer.normalize(t.transaction)))
    case _ => update
  }
}

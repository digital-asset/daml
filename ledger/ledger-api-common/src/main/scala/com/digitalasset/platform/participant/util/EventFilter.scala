// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.digitalasset.platform.participant.util

import com.daml.ledger.participant.state.index.v2.AcsUpdateEvent
import com.digitalasset.daml.lf.data.Ref
import com.digitalasset.daml.lf.data.Ref.Party
import com.digitalasset.ledger.api.domain.Event.{ArchivedEvent, CreateOrArchiveEvent, CreatedEvent}
import com.digitalasset.ledger.api.domain.TransactionFilter

import scala.collection.mutable.ArrayBuffer
import scala.collection.{breakOut, immutable}

object EventFilter {

  /**
    * Creates a filter which lets only such events through, where the template id is equal to the given one
    * and the interested party is affected.
    **/
  def byTemplates(transactionFilter: TransactionFilter): TemplateAwareFilter =
    TemplateAwareFilter(transactionFilter)

  final case class TemplateAwareFilter(transactionFilter: TransactionFilter) {

    def isSubmitterSubscriber(submitterParty: Party): Boolean =
      transactionFilter.filtersByParty.contains(submitterParty)

    private val subscribersByTemplateId: Map[Ref.Identifier, Set[Party]] = {
      val (specificSubscriptions, globalSubscriptions) = getSpecificAndGlobalSubscriptions(
        transactionFilter)
      specificSubscriptions
        .groupBy(_._1)
        .map { // Intentionally not using .mapValues to fully materialize the map
          case (templateId, pairs) =>
            val setOfParties: Set[Party] = pairs.map(_._2)(breakOut)
            templateId -> (setOfParties union globalSubscriptions)
        }
        .withDefaultValue(globalSubscriptions)
    }

    def filterCreateOrArchiveWitnesses(
        event: CreateOrArchiveEvent): Option[CreateOrArchiveEvent] = {
      applyRequestingWitnesses[CreateOrArchiveEvent](event, event.templateId, event.witnessParties) {
        case (ce: CreatedEvent, p) => ce.copy(witnessParties = p)
        case (ee: ArchivedEvent, p) => ee.copy(witnessParties = p)
      }
    }

    def filterActiveContractWitnesses(ac: AcsUpdateEvent.Create): Option[AcsUpdateEvent.Create] = {
      applyRequestingWitnesses(ac, ac.templateId, ac.stakeholders)(
        (c, p) => c.copy(stakeholders = p.toSet)
      )
    }

    private def applyRequestingWitnesses[A](a: A, tid: Ref.Identifier, parties: Set[Party])(
        partySetter: (A, Set[Party]) => A): Option[A] = {
      // The events are generated by the engine, then
      //  - we can assert identifier are always in `New Style`
      //  - witnesses are party
      val requestingWitnesses =
        parties.filter(e => subscribersByTemplateId(tid).contains(Party.assertFromString(e)))
      if (requestingWitnesses.nonEmpty)
        Some(partySetter(a, requestingWitnesses))
      else
        None
    }
  }

  private def getSpecificAndGlobalSubscriptions(
      transactionFilter: TransactionFilter): (ArrayBuffer[(Ref.Identifier, Party)], Set[Party]) = {
    val specificSubscriptions = new ArrayBuffer[(Ref.Identifier, Party)]
    val globalSubscriptions = immutable.Set.newBuilder[Party]
    transactionFilter.filtersByParty.foreach {
      case (party, filters) =>
        filters.inclusive.fold[Unit] {
          globalSubscriptions += party
        } { inclusive =>
          inclusive.templateIds.foreach { tid =>
            specificSubscriptions += tid -> party
          }
        }
    }
    (specificSubscriptions, globalSubscriptions.result())
  }
}

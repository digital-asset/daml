-- GENERATED by C->Haskell Compiler, version 0.28.6 Switcheroo, 25 November 2017 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}
{-# LANGUAGE RecordWildCards #-}

module Network.GRPC.Unsafe.ChannelArgs where
import qualified Foreign.C.String as C2HSImp
import qualified Foreign.C.Types as C2HSImp
import qualified Foreign.Ptr as C2HSImp
import qualified Foreign.Storable as C2HSImp



import           Control.Exception
import           Control.Monad
import           Foreign.Marshal.Alloc (malloc, free)
import           Foreign.Storable
import           Numeric.Natural







data ArgKey = CompressionAlgorithmKey
            | CompressionLevelKey
            | UserAgentPrefixKey
            | UserAgentSuffixKey
            | MaxReceiveMessageLengthKey
            | MaxMetadataSizeKey
  deriving (Show,Eq)
instance Enum ArgKey where
  succ CompressionAlgorithmKey = CompressionLevelKey
  succ CompressionLevelKey = UserAgentPrefixKey
  succ UserAgentPrefixKey = UserAgentSuffixKey
  succ UserAgentSuffixKey = MaxReceiveMessageLengthKey
  succ MaxReceiveMessageLengthKey = MaxMetadataSizeKey
  succ MaxMetadataSizeKey = error "ArgKey.succ: MaxMetadataSizeKey has no successor"

  pred CompressionLevelKey = CompressionAlgorithmKey
  pred UserAgentPrefixKey = CompressionLevelKey
  pred UserAgentSuffixKey = UserAgentPrefixKey
  pred MaxReceiveMessageLengthKey = UserAgentSuffixKey
  pred MaxMetadataSizeKey = MaxReceiveMessageLengthKey
  pred CompressionAlgorithmKey = error "ArgKey.pred: CompressionAlgorithmKey has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from MaxMetadataSizeKey

  fromEnum CompressionAlgorithmKey = 0
  fromEnum CompressionLevelKey = 1
  fromEnum UserAgentPrefixKey = 2
  fromEnum UserAgentSuffixKey = 3
  fromEnum MaxReceiveMessageLengthKey = 4
  fromEnum MaxMetadataSizeKey = 5

  toEnum 0 = CompressionAlgorithmKey
  toEnum 1 = CompressionLevelKey
  toEnum 2 = UserAgentPrefixKey
  toEnum 3 = UserAgentSuffixKey
  toEnum 4 = MaxReceiveMessageLengthKey
  toEnum 5 = MaxMetadataSizeKey
  toEnum unmatched = error ("ArgKey.toEnum: Cannot match " ++ show unmatched)

{-# LINE 17 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}


data CompressionAlgorithm = GrpcCompressNone
                          | GrpcCompressDeflate
                          | GrpcCompressGzip
                          | GrpcCompressStreamGzip
                          | GrpcCompressAlgorithmsCount
  deriving (Show,Eq)
instance Enum CompressionAlgorithm where
  succ GrpcCompressNone = GrpcCompressDeflate
  succ GrpcCompressDeflate = GrpcCompressGzip
  succ GrpcCompressGzip = GrpcCompressStreamGzip
  succ GrpcCompressStreamGzip = GrpcCompressAlgorithmsCount
  succ GrpcCompressAlgorithmsCount = error "CompressionAlgorithm.succ: GrpcCompressAlgorithmsCount has no successor"

  pred GrpcCompressDeflate = GrpcCompressNone
  pred GrpcCompressGzip = GrpcCompressDeflate
  pred GrpcCompressStreamGzip = GrpcCompressGzip
  pred GrpcCompressAlgorithmsCount = GrpcCompressStreamGzip
  pred GrpcCompressNone = error "CompressionAlgorithm.pred: GrpcCompressNone has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from GrpcCompressAlgorithmsCount

  fromEnum GrpcCompressNone = 0
  fromEnum GrpcCompressDeflate = 1
  fromEnum GrpcCompressGzip = 2
  fromEnum GrpcCompressStreamGzip = 3
  fromEnum GrpcCompressAlgorithmsCount = 4

  toEnum 0 = GrpcCompressNone
  toEnum 1 = GrpcCompressDeflate
  toEnum 2 = GrpcCompressGzip
  toEnum 3 = GrpcCompressStreamGzip
  toEnum 4 = GrpcCompressAlgorithmsCount
  toEnum unmatched = error ("CompressionAlgorithm.toEnum: Cannot match " ++ show unmatched)

{-# LINE 20 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}


data CompressionLevel = GrpcCompressLevelNone
                      | GrpcCompressLevelLow
                      | GrpcCompressLevelMed
                      | GrpcCompressLevelHigh
                      | GrpcCompressLevelCount
  deriving (Show,Eq)
instance Enum CompressionLevel where
  succ GrpcCompressLevelNone = GrpcCompressLevelLow
  succ GrpcCompressLevelLow = GrpcCompressLevelMed
  succ GrpcCompressLevelMed = GrpcCompressLevelHigh
  succ GrpcCompressLevelHigh = GrpcCompressLevelCount
  succ GrpcCompressLevelCount = error "CompressionLevel.succ: GrpcCompressLevelCount has no successor"

  pred GrpcCompressLevelLow = GrpcCompressLevelNone
  pred GrpcCompressLevelMed = GrpcCompressLevelLow
  pred GrpcCompressLevelHigh = GrpcCompressLevelMed
  pred GrpcCompressLevelCount = GrpcCompressLevelHigh
  pred GrpcCompressLevelNone = error "CompressionLevel.pred: GrpcCompressLevelNone has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from GrpcCompressLevelCount

  fromEnum GrpcCompressLevelNone = 0
  fromEnum GrpcCompressLevelLow = 1
  fromEnum GrpcCompressLevelMed = 2
  fromEnum GrpcCompressLevelHigh = 3
  fromEnum GrpcCompressLevelCount = 4

  toEnum 0 = GrpcCompressLevelNone
  toEnum 1 = GrpcCompressLevelLow
  toEnum 2 = GrpcCompressLevelMed
  toEnum 3 = GrpcCompressLevelHigh
  toEnum 4 = GrpcCompressLevelCount
  toEnum unmatched = error ("CompressionLevel.toEnum: Cannot match " ++ show unmatched)

{-# LINE 23 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}


type GrpcArg = C2HSImp.Ptr (())
{-# LINE 25 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}


data ChannelArgs = ChannelArgs {channelArgsN :: Int,
                                channelArgsArray :: GrpcArg}
  deriving (Show, Eq)

type GrpcChannelArgs = C2HSImp.Ptr (ChannelArgs)
{-# LINE 31 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}


instance Storable ChannelArgs where
  sizeOf _ = 16
{-# LINE 34 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}

  alignment _ = 8
{-# LINE 35 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}

  peek p = ChannelArgs <$> fmap fromIntegral
                                ((\ptr -> do {C2HSImp.peekByteOff ptr 0 :: IO C2HSImp.CULong}) p)
                       <*> ((\ptr -> do {C2HSImp.peekByteOff ptr 8 :: IO (GrpcArg)}) p)
  poke p ChannelArgs{..} = do
    (\ptr val -> do {C2HSImp.pokeByteOff ptr 0 (val :: C2HSImp.CULong)}) p $ fromIntegral channelArgsN
    (\ptr val -> do {C2HSImp.pokeByteOff ptr 8 (val :: (GrpcArg))}) p channelArgsArray

createArgArray :: (Int) -> IO ((GrpcArg))
createArgArray a1 =
  let {a1' = fromIntegral a1} in 
  createArgArray'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 43 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}


data ArgValue = StringArg String | IntArg Int
  deriving (Show, Eq)

-- | Supported arguments for a channel. More cases will be added as we figure
-- out what they are.
data Arg = CompressionAlgArg CompressionAlgorithm
         | CompressionLevelArg CompressionLevel
         | UserAgentPrefix String
         | UserAgentSuffix String
         | MaxReceiveMessageLength Natural
         | MaxMetadataSize Natural
  deriving (Show, Eq)

createStringArg :: (GrpcArg) -> (Int) -> (ArgKey) -> (String) -> IO ()
createStringArg a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = (fromIntegral . fromEnum) a3} in 
  C2HSImp.withCString a4 $ \a4' -> 
  createStringArg'_ a1' a2' a3' a4' >>
  return ()

{-# LINE 58 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}


createIntArg :: (GrpcArg) -> (Int) -> (ArgKey) -> (Int) -> IO ()
createIntArg a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = (fromIntegral . fromEnum) a3} in 
  let {a4' = fromIntegral a4} in 
  createIntArg'_ a1' a2' a3' a4' >>
  return ()

{-# LINE 60 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}


destroyArgArray :: (GrpcArg) -> (Int) -> IO ()
destroyArgArray a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  destroyArgArray'_ a1' a2' >>
  return ()

{-# LINE 62 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/ChannelArgs.chs" #-}


createArg :: GrpcArg -> Arg -> Int -> IO ()
createArg array (CompressionAlgArg alg) i =
  createIntArg array i CompressionAlgorithmKey (fromEnum alg)
createArg array (CompressionLevelArg lvl) i =
  createIntArg array i CompressionLevelKey (fromEnum lvl)
createArg array (UserAgentPrefix prefix) i =
  createStringArg array i UserAgentPrefixKey prefix
createArg array (UserAgentSuffix suffix) i =
  createStringArg array i UserAgentSuffixKey suffix
createArg array (MaxReceiveMessageLength n) i =
  createIntArg array i MaxReceiveMessageLengthKey $
    fromIntegral (min n (fromIntegral (maxBound :: Int)))
createArg array (MaxMetadataSize n) i =
  createIntArg array i MaxMetadataSizeKey $
    fromIntegral (min n (fromIntegral (maxBound :: Int)))

createChannelArgs :: [Arg] -> IO GrpcChannelArgs
createChannelArgs args = do
  let l = length args
  array <- createArgArray l
  forM_ (zip [0..l] args) $ \(i, arg) -> createArg array arg i
  ptr <- malloc
  poke ptr $ ChannelArgs l array
  return ptr

destroyChannelArgs :: GrpcChannelArgs -> IO ()
destroyChannelArgs ptr =
  do ChannelArgs{..} <- peek ptr
     destroyArgArray channelArgsArray channelArgsN
     free ptr

withChannelArgs :: [Arg] -> (GrpcChannelArgs -> IO a) -> IO a
withChannelArgs args f = bracket (createChannelArgs args) destroyChannelArgs f

foreign import ccall safe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_ChannelArgs.chs/Network/GRPC/Unsafe/ChannelArgs.chs.h create_arg_array"
  createArgArray'_ :: (C2HSImp.CULong -> (IO (GrpcArg)))

foreign import ccall safe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_ChannelArgs.chs/Network/GRPC/Unsafe/ChannelArgs.chs.h create_string_arg"
  createStringArg'_ :: ((GrpcArg) -> (C2HSImp.CULong -> (C2HSImp.CInt -> ((C2HSImp.Ptr C2HSImp.CChar) -> (IO ())))))

foreign import ccall safe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_ChannelArgs.chs/Network/GRPC/Unsafe/ChannelArgs.chs.h create_int_arg"
  createIntArg'_ :: ((GrpcArg) -> (C2HSImp.CULong -> (C2HSImp.CInt -> (C2HSImp.CInt -> (IO ())))))

foreign import ccall safe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_ChannelArgs.chs/Network/GRPC/Unsafe/ChannelArgs.chs.h destroy_arg_array"
  destroyArgArray'_ :: ((GrpcArg) -> (C2HSImp.CULong -> (IO ())))

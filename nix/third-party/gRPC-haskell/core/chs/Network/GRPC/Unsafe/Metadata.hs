-- GENERATED by C->Haskell Compiler, version 0.28.6 Switcheroo, 25 November 2017 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TupleSections      #-}
{-# LANGUAGE TypeFamilies       #-}

module Network.GRPC.Unsafe.Metadata where
import qualified Foreign.C.Types as C2HSImp
import qualified Foreign.Ptr as C2HSImp



import Network.GRPC.Unsafe.Slice
{-# LINE 7 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


import Control.Exception
import Control.Monad
import Data.Function (on)
import Data.ByteString (ByteString, useAsCString,
                        useAsCStringLen)
import Data.List (sortBy, groupBy)
import qualified Data.SortedList as SL
import qualified Data.Map.Strict as M
import Data.Ord (comparing)
import Foreign.C.String
import Foreign.Ptr
import Foreign.Storable
import GHC.Exts






-- | Represents metadata for a given RPC, consisting of key-value pairs. Keys
-- are allowed to be repeated. Since repeated keys are unlikely in practice,
-- the 'IsList' instance uses key-value pairs as items. For example,
-- @fromList [("key1","val1"),("key2","val2"),("key1","val3")]@.
newtype MetadataMap = MetadataMap {unMap :: M.Map ByteString (SL.SortedList ByteString)}
  deriving Eq

instance Show MetadataMap where
  show m = "fromList " ++ show (M.toList (unMap m))

instance Semigroup MetadataMap where
  (MetadataMap m1) <> (MetadataMap m2) =
    MetadataMap $ M.unionWith mappend m1 m2

instance Monoid MetadataMap where
  mempty = MetadataMap $ M.empty
  mappend = (<>)

instance IsList MetadataMap where
  type Item MetadataMap = (ByteString, ByteString)
  fromList = MetadataMap
             . M.fromList
             . map (\xs -> ((fst . head) xs, fromList $ map snd xs))
             . groupBy ((==) `on` fst)
             . sortBy (comparing fst)
  toList = concatMap (\(k,vs) -> map (k,) vs)
           . map (fmap toList)
           . M.toList
           . unMap

-- | Represents a pointer to one or more metadata key/value pairs. This type
-- is intended to be used when sending metadata.
newtype MetadataKeyValPtr = MetadataKeyValPtr (C2HSImp.Ptr (MetadataKeyValPtr))
{-# LINE 60 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


deriving instance Show MetadataKeyValPtr

-- | Represents a pointer to a grpc_metadata_array. Must be destroyed with
-- 'metadataArrayDestroy'. This type is intended for receiving metadata.
-- This can be populated by passing it to e.g. 'grpcServerRequestCall'.
newtype MetadataArray = MetadataArray (C2HSImp.Ptr (MetadataArray))
{-# LINE 67 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


deriving instance Show MetadataArray

metadataArrayGetMetadata :: (MetadataArray) -> IO ((MetadataKeyValPtr))
metadataArrayGetMetadata a1 =
  let {a1' = id a1} in 
  metadataArrayGetMetadata'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 72 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


-- | Overwrites the metadata in the given 'MetadataArray'. The given
-- 'MetadataKeyValPtr' *must* have been created with 'createMetadata' in this
-- module.
metadataArraySetMetadata :: (MetadataArray) -> (MetadataKeyValPtr) -> IO ()
metadataArraySetMetadata a1 a2 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  metadataArraySetMetadata'_ a1' a2' >>
  return ()

{-# LINE 78 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


metadataArrayGetCount :: (MetadataArray) -> IO ((Int))
metadataArrayGetCount a1 =
  let {a1' = id a1} in 
  metadataArrayGetCount'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 80 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


metadataArrayGetCapacity :: (MetadataArray) -> IO ((Int))
metadataArrayGetCapacity a1 =
  let {a1' = id a1} in 
  metadataArrayGetCapacity'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 82 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


instance Storable MetadataArray where
  sizeOf (MetadataArray r) = sizeOf r
  alignment (MetadataArray r) = alignment r
  peek p = fmap MetadataArray (peek (castPtr p))
  poke p (MetadataArray r) = poke (castPtr p) r

-- | Create an empty 'MetadataArray'. Returns a pointer to it so that we can
-- pass it to the appropriate op creation functions.
metadataArrayCreate :: IO ((Ptr MetadataArray))
metadataArrayCreate =
  metadataArrayCreate'_ >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 92 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


metadataArrayDestroy :: (Ptr MetadataArray) -> IO ()
metadataArrayDestroy a1 =
  let {a1' = id a1} in 
  metadataArrayDestroy'_ a1' >>
  return ()

{-# LINE 94 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


-- Note: I'm pretty sure we must call out to C to allocate these
-- because they are nested structs.
-- | Allocates space for exactly n metadata key/value pairs.
metadataAlloc :: (Int) -> IO ((MetadataKeyValPtr))
metadataAlloc a1 =
  let {a1' = fromIntegral a1} in 
  metadataAlloc'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 99 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


metadataFree :: (MetadataKeyValPtr) -> IO ()
metadataFree a1 =
  let {a1' = id a1} in 
  metadataFree'_ a1' >>
  return ()

{-# LINE 101 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


-- | Sets a metadata key/value pair at the given index in the
-- 'MetadataKeyValPtr'. No error checking is performed to ensure the index is
-- in bounds!
setMetadataKeyVal' :: (ByteString) -> (CString) -> (Int) -> (MetadataKeyValPtr) -> (Int) -> IO ()
setMetadataKeyVal' a1 a2 a3 a4 a5 =
  useAsCString a1 $ \a1' -> 
  (flip ($)) a2 $ \a2' -> 
  let {a3' = fromIntegral a3} in 
  let {a4' = id a4} in 
  let {a5' = fromIntegral a5} in 
  setMetadataKeyVal''_ a1' a2' a3' a4' a5' >>
  return ()

{-# LINE 108 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


setMetadataKeyVal :: ByteString
                     -> ByteString
                     -> MetadataKeyValPtr
                     -> Int
                     -> IO ()
setMetadataKeyVal k v m i =
  useAsCStringLen v $ \(vStr, vLen) -> setMetadataKeyVal' k vStr vLen m i

getMetadataKey' :: (MetadataKeyValPtr) -> (Int) -> IO ((Slice))
getMetadataKey' a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  getMetadataKey''_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 119 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


getMetadataVal' :: (MetadataKeyValPtr) -> (Int) -> IO ((Slice))
getMetadataVal' a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  getMetadataVal''_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 122 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Metadata.chs" #-}


withMetadataArrayPtr :: (Ptr MetadataArray -> IO a) -> IO a
withMetadataArrayPtr = bracket metadataArrayCreate metadataArrayDestroy

withMetadataKeyValPtr :: Int -> (MetadataKeyValPtr -> IO a) -> IO a
withMetadataKeyValPtr i f = bracket (metadataAlloc i) metadataFree f

getMetadataKey :: MetadataKeyValPtr -> Int -> IO ByteString
getMetadataKey m = getMetadataKey' m >=> sliceToByteString

getMetadataVal :: MetadataKeyValPtr -> Int -> IO ByteString
getMetadataVal m i = do vStr <- getMetadataVal' m i
                        sliceToByteString vStr

createMetadata :: MetadataMap -> IO (MetadataKeyValPtr, Int)
createMetadata m = do
  let indexedKeyVals = zip [0..] $ toList m
      l = length indexedKeyVals
  metadata <- metadataAlloc l
  forM_ indexedKeyVals $ \(i,(k,v)) -> setMetadataKeyVal k v metadata i
  return (metadata, l)

withPopulatedMetadataKeyValPtr :: MetadataMap
                                  -> ((MetadataKeyValPtr, Int) -> IO a)
                                  -> IO a
withPopulatedMetadataKeyValPtr m = bracket (createMetadata m)
                                           (metadataFree . fst)

getAllMetadataArray :: MetadataArray -> IO MetadataMap
getAllMetadataArray m = do
  kvs <- metadataArrayGetMetadata m
  l <- metadataArrayGetCount m
  getAllMetadata kvs l

getAllMetadata :: MetadataKeyValPtr -> Int -> IO MetadataMap
getAllMetadata m count = do
  let indices = [0..count-1]
  fmap fromList $ forM indices $
    \i -> liftM2 (,) (getMetadataKey m i) (getMetadataVal m i)

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Metadata.chs/Network/GRPC/Unsafe/Metadata.chs.h metadata_array_get_metadata"
  metadataArrayGetMetadata'_ :: ((MetadataArray) -> (IO (MetadataKeyValPtr)))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Metadata.chs/Network/GRPC/Unsafe/Metadata.chs.h metadata_array_set_metadata"
  metadataArraySetMetadata'_ :: ((MetadataArray) -> ((MetadataKeyValPtr) -> (IO ())))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Metadata.chs/Network/GRPC/Unsafe/Metadata.chs.h metadata_array_get_count"
  metadataArrayGetCount'_ :: ((MetadataArray) -> (IO C2HSImp.CULong))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Metadata.chs/Network/GRPC/Unsafe/Metadata.chs.h metadata_array_get_capacity"
  metadataArrayGetCapacity'_ :: ((MetadataArray) -> (IO C2HSImp.CULong))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Metadata.chs/Network/GRPC/Unsafe/Metadata.chs.h metadata_array_create"
  metadataArrayCreate'_ :: (IO (C2HSImp.Ptr (MetadataArray)))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Metadata.chs/Network/GRPC/Unsafe/Metadata.chs.h metadata_array_destroy"
  metadataArrayDestroy'_ :: ((C2HSImp.Ptr (MetadataArray)) -> (IO ()))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Metadata.chs/Network/GRPC/Unsafe/Metadata.chs.h metadata_alloc"
  metadataAlloc'_ :: (C2HSImp.CULong -> (IO (MetadataKeyValPtr)))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Metadata.chs/Network/GRPC/Unsafe/Metadata.chs.h metadata_free"
  metadataFree'_ :: ((MetadataKeyValPtr) -> (IO ()))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Metadata.chs/Network/GRPC/Unsafe/Metadata.chs.h set_metadata_key_val"
  setMetadataKeyVal''_ :: ((C2HSImp.Ptr C2HSImp.CChar) -> ((C2HSImp.Ptr C2HSImp.CChar) -> (C2HSImp.CULong -> ((MetadataKeyValPtr) -> (C2HSImp.CULong -> (IO ()))))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Metadata.chs/Network/GRPC/Unsafe/Metadata.chs.h get_metadata_key"
  getMetadataKey''_ :: ((MetadataKeyValPtr) -> (C2HSImp.CULong -> (IO (Slice))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Metadata.chs/Network/GRPC/Unsafe/Metadata.chs.h get_metadata_val"
  getMetadataVal''_ :: ((MetadataKeyValPtr) -> (C2HSImp.CULong -> (IO (Slice))))

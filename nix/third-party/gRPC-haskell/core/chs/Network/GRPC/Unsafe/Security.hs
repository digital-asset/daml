-- GENERATED by C->Haskell Compiler, version 0.28.6 Switcheroo, 25 November 2017 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}
{-# LANGUAGE OverloadedStrings  #-}
{-# LANGUAGE RecordWildCards    #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TupleSections      #-}

module Network.GRPC.Unsafe.Security where
import qualified Foreign.C.Types as C2HSImp
import qualified Foreign.Ptr as C2HSImp
import qualified Foreign.Storable as C2HSImp



import Control.Exception (bracket)
import Data.ByteString (ByteString, useAsCString, packCString, packCStringLen)
import Data.Coerce (coerce)
import Foreign.C.String (CString)
import Foreign.C.Types
import Foreign.Storable
import Foreign.Marshal.Alloc (free)
import Foreign.Ptr (nullPtr, FunPtr, Ptr, castPtr)





import Network.GRPC.Unsafe
{-# LINE 21 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}

import Network.GRPC.Unsafe.ChannelArgs
{-# LINE 22 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}

import Network.GRPC.Unsafe.Metadata
{-# LINE 23 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}

import Network.GRPC.Unsafe.Op
{-# LINE 24 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}



{-# LINE 26 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


-- * Types

-- | Context for auth. This is essentially just a set of key-value pairs that
-- can be mutated.
-- Note: it appears that any keys set or modified on this object do not
-- appear in the AuthContext of the peer, so you must send along auth info
-- in the metadata. It's currently unclear to us what
-- the purpose of modifying this is, but we offer the ability for the sake of
-- completeness.
newtype AuthContext = AuthContext (C2HSImp.Ptr (AuthContext))
{-# LINE 37 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


deriving instance Show AuthContext

instance Storable AuthContext where
  sizeOf (AuthContext p) = sizeOf p
  alignment (AuthContext p) = alignment p
  peek p = AuthContext <$> peek (castPtr p)
  poke p (AuthContext r) = poke (castPtr p) r

newtype AuthPropertyIterator = AuthPropertyIterator (C2HSImp.Ptr (AuthPropertyIterator))
{-# LINE 47 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


newtype CallCredentials = CallCredentials (C2HSImp.Ptr (CallCredentials))
{-# LINE 49 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


newtype ChannelCredentials = ChannelCredentials (C2HSImp.Ptr (ChannelCredentials))
{-# LINE 51 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


newtype ServerCredentials = ServerCredentials (C2HSImp.Ptr (ServerCredentials))
{-# LINE 53 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


withAuthPropertyIterator :: AuthContext
                            -> (AuthPropertyIterator -> IO a)
                            -> IO a
withAuthPropertyIterator ctx = bracket (authContextPropertyIterator ctx)
                                       (free . coerce)

-- | Represents one key/value pair in an 'AuthContext'.
data AuthProperty = AuthProperty
  {authPropName :: ByteString,
   authPropValue :: ByteString}
  deriving (Show, Eq)

marshalAuthProperty :: Ptr AuthProperty -> IO AuthProperty
marshalAuthProperty p = do
  n <- packCString =<< ((\ptr -> do {C2HSImp.peekByteOff ptr 0 :: IO (C2HSImp.Ptr C2HSImp.CChar)}) p)
  vl <- fromIntegral <$> (\ptr -> do {C2HSImp.peekByteOff ptr 16 :: IO C2HSImp.CULong}) p
  v <- packCStringLen . (,vl) =<< (\ptr -> do {C2HSImp.peekByteOff ptr 8 :: IO (C2HSImp.Ptr C2HSImp.CChar)}) p
  return $ AuthProperty n v

-- | The context which a client-side auth metadata plugin sees when it runs.
data AuthMetadataContext = AuthMetadataContext
  {serviceURL :: ByteString,
   -- ^ The URL of the service the current call is going to.
   methodName :: ByteString,
   -- ^ The method that is being invoked with the current call. It appears that
   -- the gRPC 0.15 core is not populating this correctly, because it's an empty
   -- string in my tests so far.
   channelAuthContext :: AuthContext
 }
  deriving Show

authMetadataContextMarshal :: Ptr AuthMetadataContext -> IO AuthMetadataContext
authMetadataContextMarshal p =
  AuthMetadataContext
   <$> (((\ptr -> do {C2HSImp.peekByteOff ptr 0 :: IO (C2HSImp.Ptr C2HSImp.CChar)}) p) >>= packCString)
   <*> (((\ptr -> do {C2HSImp.peekByteOff ptr 8 :: IO (C2HSImp.Ptr C2HSImp.CChar)}) p) >>= packCString)
   <*> ((\ptr -> do {C2HSImp.peekByteOff ptr 16 :: IO (AuthContext)}) p)

newtype MetadataCredentialsPlugin = MetadataCredentialsPlugin (C2HSImp.Ptr (MetadataCredentialsPlugin))
{-# LINE 93 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


newtype AuthMetadataProcessor = AuthMetadataProcessor (C2HSImp.Ptr (AuthMetadataProcessor))
{-# LINE 95 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


data SslClientCertificateRequestType = SslDontRequestClientCertificate
                                     | SslRequestClientCertificateButDontVerify
                                     | SslRequestClientCertificateAndVerify
                                     | SslRequestAndRequireClientCertificateButDontVerify
                                     | SslRequestAndRequireClientCertificateAndVerify
  deriving (Enum,Eq,Ord,Bounded,Show)

{-# LINE 98 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


-- * Auth Contexts

-- | If used, the 'AuthContext' must be released with 'AuthContextRelease'.
callAuthContext :: (Call) -> IO ((AuthContext))
callAuthContext a1 =
  let {a1' = id a1} in 
  callAuthContext'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 104 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


authContextRelease :: (AuthContext) -> IO ()
authContextRelease a1 =
  let {a1' = id a1} in 
  authContextRelease'_ a1' >>
  return ()

{-# LINE 107 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


addAuthProperty' :: (AuthContext) -> (ByteString) -> (ByteString) -> IO ()
addAuthProperty' a1 a2 a3 =
  let {a1' = id a1} in 
  useAsCString a2 $ \a2' -> 
  useAsCString a3 $ \a3' -> 
  addAuthProperty''_ a1' a2' a3' >>
  return ()

{-# LINE 113 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


-- | Adds a new property to the given 'AuthContext'.
addAuthProperty :: AuthContext -> AuthProperty -> IO ()
addAuthProperty ctx prop =
  addAuthProperty' ctx (authPropName prop) (authPropValue prop)

{-
TODO: The functions for getting and setting peer identities cause
unpredictable crashes when used in conjunction with other, more general
auth property getter/setter functions. If we end needing these, we should
investigate further.

coercePack :: Ptr a -> IO ByteString
coercePack = packCString . coerce

{#fun unsafe grpc_auth_context_peer_identity_property_name
  as getPeerIdentityPropertyName
  {`AuthContext'} -> `ByteString' coercePack* #}

{#fun unsafe auth_context_set_peer_identity_property_name
  as setPeerIdentity
  {`AuthContext', useAsCString* `ByteString'} -> `()'#}

{#fun unsafe auth_context_peer_identity as getPeerIdentity
  {`AuthContext'} -> `ByteString' coercePack* #}
-}
-- * Property Iteration

authContextPropertyIterator :: (AuthContext) -> IO ((AuthPropertyIterator))
authContextPropertyIterator a1 =
  let {a1' = id a1} in 
  authContextPropertyIterator'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 143 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


authPropertyIteratorNext :: (AuthPropertyIterator) -> IO ((Ptr AuthProperty))
authPropertyIteratorNext a1 =
  let {a1' = id a1} in 
  authPropertyIteratorNext'_ a1' >>= \res ->
  let {res' = coerce res} in
  return (res')

{-# LINE 146 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


getAuthProperties :: AuthContext -> IO [AuthProperty]
getAuthProperties ctx = withAuthPropertyIterator ctx $ \i -> do
  go i
  where go :: AuthPropertyIterator -> IO [AuthProperty]
        go i = do p <- authPropertyIteratorNext i
                  if p == nullPtr
                     then return []
                     else do props <- go i
                             prop <- marshalAuthProperty p
                             return (prop:props)

-- * Channel Credentials

channelCredentialsRelease :: (ChannelCredentials) -> IO ()
channelCredentialsRelease a1 =
  let {a1' = id a1} in 
  channelCredentialsRelease'_ a1' >>
  return ()

{-# LINE 162 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


compositeChannelCredentialsCreate :: (ChannelCredentials) -> (CallCredentials) -> (Reserved) -> IO ((ChannelCredentials))
compositeChannelCredentialsCreate a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = unReserved a3} in 
  compositeChannelCredentialsCreate'_ a1' a2' a3' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 166 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


sslCredentialsCreateInternal :: (CString) -> (CString) -> (CString) -> IO ((ChannelCredentials))
sslCredentialsCreateInternal a1 a2 a3 =
  (flip ($)) a1 $ \a1' -> 
  (flip ($)) a2 $ \a2' -> 
  (flip ($)) a3 $ \a3' -> 
  sslCredentialsCreateInternal'_ a1' a2' a3' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 169 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


sslChannelCredentialsCreate :: Maybe ByteString
                               -> Maybe ByteString
                               -> Maybe ByteString
                               -> IO ChannelCredentials
sslChannelCredentialsCreate (Just s) Nothing Nothing =
  useAsCString s $ \s' -> sslCredentialsCreateInternal s' nullPtr nullPtr
sslChannelCredentialsCreate Nothing (Just s1) (Just s2) =
  useAsCString s1 $ \s1' -> useAsCString s2 $ \s2' ->
  sslCredentialsCreateInternal nullPtr s1' s2'
sslChannelCredentialsCreate (Just s1) (Just s2) (Just s3) =
  useAsCString s1 $ \s1' -> useAsCString s2 $ \s2' -> useAsCString s3 $ \s3' ->
  sslCredentialsCreateInternal s1' s2' s3'
sslChannelCredentialsCreate (Just s1) _ _ =
  useAsCString s1 $ \s1' ->
  sslCredentialsCreateInternal s1' nullPtr nullPtr
sslChannelCredentialsCreate _ _ _ =
  sslCredentialsCreateInternal nullPtr nullPtr nullPtr

withChannelCredentials :: Maybe ByteString
                          -> Maybe ByteString
                          -> Maybe ByteString
                          -> (ChannelCredentials -> IO a)
                          -> IO a
withChannelCredentials x y z = bracket (sslChannelCredentialsCreate x y z)
                                       channelCredentialsRelease

-- * Call Credentials

callSetCredentials :: (Call) -> (CallCredentials) -> IO ((CallError))
callSetCredentials a1 a2 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  callSetCredentials'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 200 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


callCredentialsRelease :: (CallCredentials) -> IO ()
callCredentialsRelease a1 =
  let {a1' = id a1} in 
  callCredentialsRelease'_ a1' >>
  return ()

{-# LINE 203 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


compositeCallCredentialsCreate :: (CallCredentials) -> (CallCredentials) -> (Reserved) -> IO ((CallCredentials))
compositeCallCredentialsCreate a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = unReserved a3} in 
  compositeCallCredentialsCreate'_ a1' a2' a3' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 207 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


-- * Server Credentials

serverCredentialsRelease :: (ServerCredentials) -> IO ()
serverCredentialsRelease a1 =
  let {a1' = id a1} in 
  serverCredentialsRelease'_ a1' >>
  return ()

{-# LINE 212 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


sslServerCredentialsCreateInternal :: (CString) -> (ByteString) -> (ByteString) -> (SslClientCertificateRequestType) -> IO ((ServerCredentials))
sslServerCredentialsCreateInternal a1 a2 a3 a4 =
  (flip ($)) a1 $ \a1' -> 
  useAsCString a2 $ \a2' -> 
  useAsCString a3 $ \a3' -> 
  let {a4' = (fromIntegral . fromEnum) a4} in 
  sslServerCredentialsCreateInternal'_ a1' a2' a3' a4' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 219 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


sslServerCredentialsCreate :: Maybe ByteString
                              -- ^ PEM encoding of the client root certificates.
                              -- Can be 'Nothing' if SSL authentication of
                              -- clients is not desired.
                              -> ByteString
                              -- ^ Server private key.
                              -> ByteString
                              -- ^ Server certificate.
                              -> SslClientCertificateRequestType
                              -- ^ How to handle client certificates.
                              -> IO ServerCredentials
sslServerCredentialsCreate Nothing k c t =
  sslServerCredentialsCreateInternal nullPtr k c t
sslServerCredentialsCreate (Just cc) k c t =
  useAsCString cc $ \cc' -> sslServerCredentialsCreateInternal cc' k c t

withServerCredentials :: Maybe ByteString
                         -- ^ PEM encoding of the client root certificates.
                         -- Can be 'Nothing' if SSL authentication of
                         -- clients is not desired.
                         -> ByteString
                         -- ^ Server private key.
                         -> ByteString
                         -- ^ Server certificate.
                         -> SslClientCertificateRequestType
                         -- ^ How to handle client certificates.
                         -> (ServerCredentials -> IO a)
                         -> IO a
withServerCredentials a b c d = bracket (sslServerCredentialsCreate a b c d)
                                        serverCredentialsRelease

-- * Creating Secure Clients/Servers

serverAddSecureHttp2Port :: (Server) -> (ByteString) -> (ServerCredentials) -> IO ((Int))
serverAddSecureHttp2Port a1 a2 a3 =
  let {a1' = id a1} in 
  useAsCString a2 $ \a2' -> 
  let {a3' = id a3} in 
  serverAddSecureHttp2Port'_ a1' a2' a3' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 255 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


secureChannelCreate :: (ChannelCredentials) -> (ByteString) -> (GrpcChannelArgs) -> (Reserved) -> IO ((Channel))
secureChannelCreate a1 a2 a3 a4 =
  let {a1' = id a1} in 
  useAsCString a2 $ \a2' -> 
  let {a3' = id a3} in 
  let {a4' = unReserved a4} in 
  secureChannelCreate'_ a1' a2' a3' a4' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 259 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


-- * Custom metadata processing -- server side

-- | Type synonym for the raw function pointer we pass to C to handle custom
-- server-side metadata auth processing.
type CAuthProcess = Ptr ()
                 -> AuthContext
                 -> MetadataKeyValPtr
                 -> CSize
                 -> FunPtr CDoneCallback
                 -> Ptr ()
                 -> IO ()

foreign import ccall "wrapper"
  mkAuthProcess :: CAuthProcess -> IO (FunPtr CAuthProcess)

type CDoneCallback = Ptr ()
                   -> MetadataKeyValPtr
                   -> CSize
                   -> MetadataKeyValPtr
                   -> CSize
                   -> CInt -- ^ statuscode
                   -> CString -- ^ status details
                   -> IO ()

foreign import ccall "dynamic"
  unwrapDoneCallback :: FunPtr CDoneCallback -> CDoneCallback

serverCredentialsSetAuthMetadataProcessor :: (ServerCredentials) -> (AuthMetadataProcessor) -> IO ()
serverCredentialsSetAuthMetadataProcessor a1 a2 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  serverCredentialsSetAuthMetadataProcessor'_ a1' a2' >>
  return ()

{-# LINE 289 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


foreign import ccall "grpc_haskell.h mk_auth_metadata_processor"
  mkAuthMetadataProcessor :: FunPtr CAuthProcess -> IO AuthMetadataProcessor

data AuthProcessorResult = AuthProcessorResult
  { resultConsumedMetadata :: MetadataMap
  -- ^ Metadata to remove from the request before passing to the handler.
  , resultResponseMetadata :: MetadataMap
  -- ^ Metadata to add to the response.
  , resultStatus :: StatusCode
  -- ^ StatusOk if auth was successful. Using any other status code here will
  -- cause the request to be rejected without reaching a handler.
  -- For rejected requests, it's suggested that this
  -- be StatusUnauthenticated or StatusPermissionDenied.
  -- NOTE: if you are using the low-level interface and the request is rejected,
  -- then handling functions in the low-level
  -- interface such as 'serverHandleNormalCall' will not unblock until they
  -- receive another request that is not rejected. So, if you write a buggy
  -- auth plugin that rejects all requests, your server could hang.
  , resultStatusDetails :: StatusDetails}

-- | A custom auth metadata processor. This can be used to implement customized
-- auth schemes based on the metadata in the request.
type ProcessMeta = AuthContext
                   -> MetadataMap
                   -> IO AuthProcessorResult

convertProcessor :: ProcessMeta -> CAuthProcess
convertProcessor f = \_state authCtx inMeta numMeta callBack userDataPtr -> do
  meta <- getAllMetadata inMeta (fromIntegral numMeta)
  AuthProcessorResult{..} <- f authCtx meta
  let cb = unwrapDoneCallback callBack
  let status = (fromEnum resultStatus)
  withPopulatedMetadataKeyValPtr resultConsumedMetadata $ \(conMeta, conLen) ->
    withPopulatedMetadataKeyValPtr resultResponseMetadata $ \(resMeta, resLen) ->
    useAsCString (unStatusDetails resultStatusDetails) $ \dtls -> do
      cb userDataPtr
         conMeta
         (fromIntegral conLen)
         resMeta
         (fromIntegral resLen)
         (fromIntegral status)
         dtls

-- | Sets the custom metadata processor for the given server credentials.
setMetadataProcessor :: ServerCredentials -> ProcessMeta -> IO ()
setMetadataProcessor creds processor = do
  let rawProcessor = convertProcessor processor
  rawProcessorPtr <- mkAuthProcess rawProcessor
  metaProcessor <- mkAuthMetadataProcessor rawProcessorPtr
  serverCredentialsSetAuthMetadataProcessor creds metaProcessor

-- * Client-side metadata plugins

type CGetMetadata = Ptr AuthMetadataContext
                 -> FunPtr CGetMetadataCallBack
                 -> Ptr ()
                -- ^ user data ptr (opaque, but must be passed on)
                 -> IO ()

foreign import ccall "wrapper"
  mkCGetMetadata :: CGetMetadata -> IO (FunPtr CGetMetadata)

type CGetMetadataCallBack = Ptr ()
                         -> MetadataKeyValPtr
                         -> CSize
                         -> CInt
                         -> CString
                         -> IO ()

foreign import ccall "dynamic"
  unwrapGetMetadataCallback :: FunPtr CGetMetadataCallBack
                            -> CGetMetadataCallBack

data ClientMetadataCreateResult = ClientMetadataCreateResult
  { clientResultMetadata :: MetadataMap
    -- ^ Additional metadata to add to the call.
  , clientResultStatus   :: StatusCode
   -- ^ if not 'StatusOk', causes the call to fail with the given status code.
   -- NOTE: if the auth fails, the call will not get sent to the server. So, if
   -- you're writing a test, your server might wait for a request forever.
  , clientResultDetails  :: StatusDetails }

-- | Optional plugin for attaching custom auth metadata to each call.
type ClientMetadataCreate = AuthMetadataContext
                            -> IO ClientMetadataCreateResult

convertMetadataCreate :: ClientMetadataCreate -> CGetMetadata
convertMetadataCreate f = \authCtxPtr doneCallback userDataPtr -> do
  authCtx <- authMetadataContextMarshal authCtxPtr
  ClientMetadataCreateResult{..} <- f authCtx
  let cb = unwrapGetMetadataCallback doneCallback
  withPopulatedMetadataKeyValPtr clientResultMetadata $ \(meta,metaLen) ->
    useAsCString (unStatusDetails clientResultDetails) $ \details -> do
      let status = fromIntegral $ fromEnum clientResultStatus
      cb userDataPtr meta (fromIntegral metaLen) status details

foreign import ccall "grpc_haskell.h mk_metadata_client_plugin"
  mkMetadataClientPlugin :: FunPtr CGetMetadata -> IO MetadataCredentialsPlugin

metadataCredentialsCreateFromPlugin :: (MetadataCredentialsPlugin) -> IO ((CallCredentials))
metadataCredentialsCreateFromPlugin a1 =
  let {a1' = id a1} in 
  metadataCredentialsCreateFromPlugin'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 391 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Security.chs" #-}


createCustomCallCredentials :: ClientMetadataCreate -> IO CallCredentials
createCustomCallCredentials create = do
  let rawCreate = convertMetadataCreate create
  rawCreatePtr <- mkCGetMetadata rawCreate
  plugin <- mkMetadataClientPlugin rawCreatePtr
  metadataCredentialsCreateFromPlugin plugin

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_call_auth_context"
  callAuthContext'_ :: ((Call) -> (IO (AuthContext)))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_auth_context_release"
  authContextRelease'_ :: ((AuthContext) -> (IO ()))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_auth_context_add_cstring_property"
  addAuthProperty''_ :: ((AuthContext) -> ((C2HSImp.Ptr C2HSImp.CChar) -> ((C2HSImp.Ptr C2HSImp.CChar) -> (IO ()))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_auth_context_property_iterator_"
  authContextPropertyIterator'_ :: ((AuthContext) -> (IO (AuthPropertyIterator)))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_auth_property_iterator_next"
  authPropertyIteratorNext'_ :: ((AuthPropertyIterator) -> (IO (C2HSImp.Ptr ())))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_channel_credentials_release"
  channelCredentialsRelease'_ :: ((ChannelCredentials) -> (IO ()))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_composite_channel_credentials_create"
  compositeChannelCredentialsCreate'_ :: ((ChannelCredentials) -> ((CallCredentials) -> ((C2HSImp.Ptr ()) -> (IO (ChannelCredentials)))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_ssl_credentials_create_internal"
  sslCredentialsCreateInternal'_ :: ((C2HSImp.Ptr C2HSImp.CChar) -> ((C2HSImp.Ptr C2HSImp.CChar) -> ((C2HSImp.Ptr C2HSImp.CChar) -> (IO (ChannelCredentials)))))

foreign import ccall safe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_call_set_credentials"
  callSetCredentials'_ :: ((Call) -> ((CallCredentials) -> (IO C2HSImp.CInt)))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_call_credentials_release"
  callCredentialsRelease'_ :: ((CallCredentials) -> (IO ()))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_composite_call_credentials_create"
  compositeCallCredentialsCreate'_ :: ((CallCredentials) -> ((CallCredentials) -> ((C2HSImp.Ptr ()) -> (IO (CallCredentials)))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_server_credentials_release"
  serverCredentialsRelease'_ :: ((ServerCredentials) -> (IO ()))

foreign import ccall safe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h ssl_server_credentials_create_internal"
  sslServerCredentialsCreateInternal'_ :: ((C2HSImp.Ptr C2HSImp.CChar) -> ((C2HSImp.Ptr C2HSImp.CChar) -> ((C2HSImp.Ptr C2HSImp.CChar) -> (C2HSImp.CInt -> (IO (ServerCredentials))))))

foreign import ccall safe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_server_add_secure_http2_port"
  serverAddSecureHttp2Port'_ :: ((Server) -> ((C2HSImp.Ptr C2HSImp.CChar) -> ((ServerCredentials) -> (IO C2HSImp.CInt))))

foreign import ccall safe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_secure_channel_create"
  secureChannelCreate'_ :: ((ChannelCredentials) -> ((C2HSImp.Ptr C2HSImp.CChar) -> ((GrpcChannelArgs) -> ((C2HSImp.Ptr ()) -> (IO (Channel))))))

foreign import ccall safe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_server_credentials_set_auth_metadata_processor_"
  serverCredentialsSetAuthMetadataProcessor'_ :: ((ServerCredentials) -> ((AuthMetadataProcessor) -> (IO ())))

foreign import ccall safe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Security.chs/Network/GRPC/Unsafe/Security.chs.h grpc_metadata_credentials_create_from_plugin_"
  metadataCredentialsCreateFromPlugin'_ :: ((MetadataCredentialsPlugin) -> (IO (CallCredentials)))

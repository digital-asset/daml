-- GENERATED by C->Haskell Compiler, version 0.28.6 Switcheroo, 25 November 2017 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Slice.chs" #-}
{-# LANGUAGE StandaloneDeriving #-}

module Network.GRPC.Unsafe.Slice where
import qualified Foreign.C.Types as C2HSImp
import qualified Foreign.Ptr as C2HSImp






import qualified Data.ByteString as B
import Foreign.C.String
import Foreign.C.Types
import Foreign.Ptr

-- | A 'Slice' is gRPC's string type. We can easily convert these to and from
-- ByteStrings. This type is a pointer to a C type.
newtype Slice = Slice (C2HSImp.Ptr (Slice))
{-# LINE 15 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Slice.chs" #-}


deriving instance Show Slice

-- TODO: we could also represent this type as 'Ptr Slice', by doing this:
-- newtype Slice = Slice {#type grpc_slice#}
-- This would have no practical effect, but it would communicate intent more
-- clearly by emphasizing that the type is indeed a pointer and that the data
-- it is pointing to might change/be destroyed after running IO actions. To make
-- the change, we would just need to change all occurrences of 'Slice' to
-- 'Ptr Slice' and add 'castPtr' in and out marshallers.
-- This seems like the right way to do it, but c2hs doesn't make it easy, so
-- maybe the established idiom is to do what c2hs does.

-- | Get the length of a slice.
grpcSliceLength :: (Slice) -> IO ((CULong))
grpcSliceLength a1 =
  let {a1' = id a1} in 
  grpcSliceLength'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 30 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Slice.chs" #-}


-- | Slices allocated using this function must be freed by
-- 'freeSlice'
grpcSliceMalloc :: (Int) -> IO ((Slice))
grpcSliceMalloc a1 =
  let {a1' = fromIntegral a1} in 
  grpcSliceMalloc'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 34 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Slice.chs" #-}


-- | Returns a pointer to the start of the character array contained by the
-- slice.
grpcSliceStart :: (Slice) -> IO ((Ptr CChar))
grpcSliceStart a1 =
  let {a1' = id a1} in 
  grpcSliceStart'_ a1' >>= \res ->
  let {res' = castPtr res} in
  return (res')

{-# LINE 38 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Slice.chs" #-}


-- | Slices must be freed using 'freeSlice'.
grpcSliceFromCopiedBuffer :: (CString) -> (Int) -> IO ((Slice))
grpcSliceFromCopiedBuffer a1 a2 =
  (flip ($)) a1 $ \a1' -> 
  let {a2' = fromIntegral a2} in 
  grpcSliceFromCopiedBuffer'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 41 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Slice.chs" #-}


-- | Properly cleans up all memory used by a 'Slice'. Danger: the Slice should
-- not be used after this function is called on it.
freeSlice :: (Slice) -> IO ()
freeSlice a1 =
  let {a1' = id a1} in 
  freeSlice'_ a1' >>
  return ()

{-# LINE 45 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Slice.chs" #-}


-- | Copies a 'Slice' to a ByteString.
-- TODO: there are also non-copying unsafe ByteString construction functions.
-- We could gain some speed by using them.
-- idea would be something :: (ByteString -> Response) -> IO () that handles
-- getting and freeing the slice behind the scenes.
sliceToByteString :: Slice -> IO B.ByteString
sliceToByteString slice = do
  len <- fmap fromIntegral $ grpcSliceLength slice
  str <- grpcSliceStart slice
  B.packCStringLen (str, len)

-- | Copies a 'ByteString' to a 'Slice'.
byteStringToSlice :: B.ByteString -> IO Slice
byteStringToSlice bs = B.useAsCStringLen bs $ uncurry grpcSliceFromCopiedBuffer

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Slice.chs/Network/GRPC/Unsafe/Slice.chs.h grpc_slice_length_"
  grpcSliceLength'_ :: ((Slice) -> (IO C2HSImp.CULong))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Slice.chs/Network/GRPC/Unsafe/Slice.chs.h grpc_slice_malloc_"
  grpcSliceMalloc'_ :: (C2HSImp.CULong -> (IO (Slice)))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Slice.chs/Network/GRPC/Unsafe/Slice.chs.h grpc_slice_start_"
  grpcSliceStart'_ :: ((Slice) -> (IO (C2HSImp.Ptr C2HSImp.CUChar)))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Slice.chs/Network/GRPC/Unsafe/Slice.chs.h grpc_slice_from_copied_buffer_"
  grpcSliceFromCopiedBuffer'_ :: ((C2HSImp.Ptr C2HSImp.CChar) -> (C2HSImp.CULong -> (IO (Slice))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Slice.chs/Network/GRPC/Unsafe/Slice.chs.h free_slice"
  freeSlice'_ :: ((Slice) -> (IO ()))

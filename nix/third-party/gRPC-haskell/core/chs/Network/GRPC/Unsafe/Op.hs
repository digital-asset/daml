-- GENERATED by C->Haskell Compiler, version 0.28.6 Switcheroo, 25 November 2017 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}
{-# LANGUAGE StandaloneDeriving #-}

module Network.GRPC.Unsafe.Op where
import qualified Foreign.C.Types as C2HSImp
import qualified Foreign.Ptr as C2HSImp



import Network.GRPC.Unsafe.Slice
{-# LINE 5 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


import Control.Exception
import Foreign.C.Types
import Foreign.Ptr
import Network.GRPC.Unsafe.ByteBuffer
{-# LINE 10 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}

import Network.GRPC.Unsafe.Metadata
{-# LINE 11 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}








{-# LINE 18 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


data OpType = OpSendInitialMetadata
            | OpSendMessage
            | OpSendCloseFromClient
            | OpSendStatusFromServer
            | OpRecvInitialMetadata
            | OpRecvMessage
            | OpRecvStatusOnClient
            | OpRecvCloseOnServer
  deriving (Eq,Show)
instance Enum OpType where
  succ OpSendInitialMetadata = OpSendMessage
  succ OpSendMessage = OpSendCloseFromClient
  succ OpSendCloseFromClient = OpSendStatusFromServer
  succ OpSendStatusFromServer = OpRecvInitialMetadata
  succ OpRecvInitialMetadata = OpRecvMessage
  succ OpRecvMessage = OpRecvStatusOnClient
  succ OpRecvStatusOnClient = OpRecvCloseOnServer
  succ OpRecvCloseOnServer = error "OpType.succ: OpRecvCloseOnServer has no successor"

  pred OpSendMessage = OpSendInitialMetadata
  pred OpSendCloseFromClient = OpSendMessage
  pred OpSendStatusFromServer = OpSendCloseFromClient
  pred OpRecvInitialMetadata = OpSendStatusFromServer
  pred OpRecvMessage = OpRecvInitialMetadata
  pred OpRecvStatusOnClient = OpRecvMessage
  pred OpRecvCloseOnServer = OpRecvStatusOnClient
  pred OpSendInitialMetadata = error "OpType.pred: OpSendInitialMetadata has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from OpRecvCloseOnServer

  fromEnum OpSendInitialMetadata = 0
  fromEnum OpSendMessage = 1
  fromEnum OpSendCloseFromClient = 2
  fromEnum OpSendStatusFromServer = 3
  fromEnum OpRecvInitialMetadata = 4
  fromEnum OpRecvMessage = 5
  fromEnum OpRecvStatusOnClient = 6
  fromEnum OpRecvCloseOnServer = 7

  toEnum 0 = OpSendInitialMetadata
  toEnum 1 = OpSendMessage
  toEnum 2 = OpSendCloseFromClient
  toEnum 3 = OpSendStatusFromServer
  toEnum 4 = OpRecvInitialMetadata
  toEnum 5 = OpRecvMessage
  toEnum 6 = OpRecvStatusOnClient
  toEnum 7 = OpRecvCloseOnServer
  toEnum unmatched = error ("OpType.toEnum: Cannot match " ++ show unmatched)

{-# LINE 20 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}

data StatusCode = StatusDoNotUse
                | StatusOk
                | StatusCancelled
                | StatusUnknown
                | StatusInvalidArgument
                | StatusDeadlineExceeded
                | StatusNotFound
                | StatusAlreadyExists
                | StatusPermissionDenied
                | StatusResourceExhausted
                | StatusFailedPrecondition
                | StatusAborted
                | StatusOutOfRange
                | StatusUnimplemented
                | StatusInternal
                | StatusUnavailable
                | StatusDataLoss
                | StatusUnauthenticated
  deriving (Eq,Read,Show)
instance Enum StatusCode where
  succ StatusDoNotUse = StatusOk
  succ StatusOk = StatusCancelled
  succ StatusCancelled = StatusUnknown
  succ StatusUnknown = StatusInvalidArgument
  succ StatusInvalidArgument = StatusDeadlineExceeded
  succ StatusDeadlineExceeded = StatusNotFound
  succ StatusNotFound = StatusAlreadyExists
  succ StatusAlreadyExists = StatusPermissionDenied
  succ StatusPermissionDenied = StatusResourceExhausted
  succ StatusResourceExhausted = StatusFailedPrecondition
  succ StatusFailedPrecondition = StatusAborted
  succ StatusAborted = StatusOutOfRange
  succ StatusOutOfRange = StatusUnimplemented
  succ StatusUnimplemented = StatusInternal
  succ StatusInternal = StatusUnavailable
  succ StatusUnavailable = StatusDataLoss
  succ StatusDataLoss = StatusUnauthenticated
  succ StatusUnauthenticated = error "StatusCode.succ: StatusUnauthenticated has no successor"

  pred StatusOk = StatusDoNotUse
  pred StatusCancelled = StatusOk
  pred StatusUnknown = StatusCancelled
  pred StatusInvalidArgument = StatusUnknown
  pred StatusDeadlineExceeded = StatusInvalidArgument
  pred StatusNotFound = StatusDeadlineExceeded
  pred StatusAlreadyExists = StatusNotFound
  pred StatusPermissionDenied = StatusAlreadyExists
  pred StatusResourceExhausted = StatusPermissionDenied
  pred StatusFailedPrecondition = StatusResourceExhausted
  pred StatusAborted = StatusFailedPrecondition
  pred StatusOutOfRange = StatusAborted
  pred StatusUnimplemented = StatusOutOfRange
  pred StatusInternal = StatusUnimplemented
  pred StatusUnavailable = StatusInternal
  pred StatusDataLoss = StatusUnavailable
  pred StatusUnauthenticated = StatusDataLoss
  pred StatusDoNotUse = error "StatusCode.pred: StatusDoNotUse has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from StatusUnauthenticated

  fromEnum StatusDoNotUse = (-1)
  fromEnum StatusOk = 0
  fromEnum StatusCancelled = 1
  fromEnum StatusUnknown = 2
  fromEnum StatusInvalidArgument = 3
  fromEnum StatusDeadlineExceeded = 4
  fromEnum StatusNotFound = 5
  fromEnum StatusAlreadyExists = 6
  fromEnum StatusPermissionDenied = 7
  fromEnum StatusResourceExhausted = 8
  fromEnum StatusFailedPrecondition = 9
  fromEnum StatusAborted = 10
  fromEnum StatusOutOfRange = 11
  fromEnum StatusUnimplemented = 12
  fromEnum StatusInternal = 13
  fromEnum StatusUnavailable = 14
  fromEnum StatusDataLoss = 15
  fromEnum StatusUnauthenticated = 16

  toEnum (-1) = StatusDoNotUse
  toEnum 0 = StatusOk
  toEnum 1 = StatusCancelled
  toEnum 2 = StatusUnknown
  toEnum 3 = StatusInvalidArgument
  toEnum 4 = StatusDeadlineExceeded
  toEnum 5 = StatusNotFound
  toEnum 6 = StatusAlreadyExists
  toEnum 7 = StatusPermissionDenied
  toEnum 8 = StatusResourceExhausted
  toEnum 9 = StatusFailedPrecondition
  toEnum 10 = StatusAborted
  toEnum 11 = StatusOutOfRange
  toEnum 12 = StatusUnimplemented
  toEnum 13 = StatusInternal
  toEnum 14 = StatusUnavailable
  toEnum 15 = StatusDataLoss
  toEnum 16 = StatusUnauthenticated
  toEnum unmatched = error ("StatusCode.toEnum: Cannot match " ++ show unmatched)

{-# LINE 21 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- NOTE: We don't alloc the space for the enum in Haskell because enum size is
-- implementation-dependent. See:
-- http://stackoverflow.com/questions/1113855/is-the-sizeofenum-sizeofint-always
-- | Allocates space for a 'StatusCode' and returns a pointer to it. Used to
-- receive a status code from the server with 'opRecvStatusClient'.
createStatusCodePtr :: IO ((Ptr StatusCode))
createStatusCodePtr =
  createStatusCodePtr'_ >>= \res ->
  let {res' = castPtr res} in
  return (res')

{-# LINE 28 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


derefStatusCodePtr :: (Ptr StatusCode) -> IO ((StatusCode))
derefStatusCodePtr a1 =
  let {a1' = castPtr a1} in 
  derefStatusCodePtr'_ a1' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 30 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


destroyStatusCodePtr :: (Ptr StatusCode) -> IO ()
destroyStatusCodePtr a1 =
  let {a1' = castPtr a1} in 
  destroyStatusCodePtr'_ a1' >>
  return ()

{-# LINE 32 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- | Represents an array of ops to be passed to 'grpcCallStartBatch'.
-- Create an array with 'opArrayCreate', then create individual ops in the array
-- using the op* functions. For these functions, the first two arguments are
-- always the OpArray to mutate and the index in the array at which to create
-- the new op. After processing the batch and getting out any results, call
-- 'opArrayDestroy'.
newtype OpArray = OpArray (C2HSImp.Ptr (OpArray))
{-# LINE 40 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


deriving instance Show OpArray

-- | Creates an empty 'OpArray' with space for the given number of ops.
opArrayCreate :: (Int) -> IO ((OpArray))
opArrayCreate a1 =
  let {a1' = fromIntegral a1} in 
  opArrayCreate'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 45 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- | Destroys an 'OpArray' of the given size.
opArrayDestroy :: (OpArray) -> (Int) -> IO ()
opArrayDestroy a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  opArrayDestroy'_ a1' a2' >>
  return ()

{-# LINE 48 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- | brackets creating and destroying an 'OpArray' with the given size.
withOpArray :: Int -> (OpArray -> IO a) -> IO a
withOpArray n f = bracket (opArrayCreate n) (flip opArrayDestroy n) f

-- | Creates an op of type GRPC_OP_SEND_INITIAL_METADATA at the specified
-- index of the given 'OpArray', containing the given
-- metadata. The metadata is copied and can be destroyed after calling this
-- function.
opSendInitialMetadata :: (OpArray) -> (Int) -> (MetadataKeyValPtr) -> (Int) -> IO ()
opSendInitialMetadata a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = id a3} in 
  let {a4' = fromIntegral a4} in 
  opSendInitialMetadata'_ a1' a2' a3' a4' >>
  return ()

{-# LINE 59 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- | Creates an op of type GRPC_OP_SEND_INITIAL_METADATA at the specified
-- index of the given 'OpArray'. The op will contain no metadata.
opSendInitialMetadataEmpty :: (OpArray) -> (Int) -> IO ()
opSendInitialMetadataEmpty a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  opSendInitialMetadataEmpty'_ a1' a2' >>
  return ()

{-# LINE 63 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- | Creates an op of type GRPC_OP_SEND_MESSAGE at the specified index of
-- the given 'OpArray'. The given 'ByteBuffer' is
-- copied and can be destroyed after calling this function.
opSendMessage :: (OpArray) -> (Int) -> (ByteBuffer) -> IO ()
opSendMessage a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = id a3} in 
  opSendMessage'_ a1' a2' a3' >>
  return ()

{-# LINE 68 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- | Creates an 'Op' of type GRPC_OP_SEND_CLOSE_FROM_CLIENT at the specified
-- index of the given 'OpArray'.
opSendCloseClient :: (OpArray) -> (Int) -> IO ()
opSendCloseClient a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  opSendCloseClient'_ a1' a2' >>
  return ()

{-# LINE 72 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- | Creates an op of type GRPC_OP_RECV_INITIAL_METADATA at the specified
-- index of the given 'OpArray', and ties the given
-- 'MetadataArray' pointer to that op so that the received metadata can be
-- accessed. It is the user's responsibility to destroy the 'MetadataArray'.
opRecvInitialMetadata :: (OpArray) -> (Int) -> (Ptr MetadataArray) -> IO ()
opRecvInitialMetadata a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = id a3} in 
  opRecvInitialMetadata'_ a1' a2' a3' >>
  return ()

{-# LINE 79 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- | Creates an op of type GRPC_OP_RECV_MESSAGE at the specified index of the
-- given 'OpArray', and ties the given
-- 'ByteBuffer' pointer to that op so that the received message can be
-- accessed. It is the user's responsibility to destroy the 'ByteBuffer'.
opRecvMessage :: (OpArray) -> (Int) -> (Ptr ByteBuffer) -> IO ()
opRecvMessage a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = id a3} in 
  opRecvMessage'_ a1' a2' a3' >>
  return ()

{-# LINE 85 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- | Creates an op of type GRPC_OP_RECV_STATUS_ON_CLIENT at the specified
-- index of the given 'OpArray', and ties all the
-- input pointers to that op so that the results of the receive can be
-- accessed. It is the user's responsibility to free all the input args after
-- this call.
opRecvStatusClient :: (OpArray) -> (Int) -> (Ptr MetadataArray) -> (Ptr StatusCode) -> (Slice) -> IO ()
opRecvStatusClient a1 a2 a3 a4 a5 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = id a3} in 
  let {a4' = castPtr a4} in 
  let {a5' = id a5} in 
  opRecvStatusClient'_ a1' a2' a3' a4' a5' >>
  return ()

{-# LINE 95 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- | Creates an op of type GRPC_OP_RECV_CLOSE_ON_SERVER at the specified index
-- of the given 'OpArray', and ties the input
-- pointer to that op so that the result of the receive can be accessed. It is
-- the user's responsibility to free the pointer.
opRecvCloseServer :: (OpArray) -> (Int) -> (Ptr CInt) -> IO ()
opRecvCloseServer a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = id a3} in 
  opRecvCloseServer'_ a1' a2' a3' >>
  return ()

{-# LINE 101 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


-- | Creates an op of type GRPC_OP_SEND_STATUS_FROM_SERVER at the specified
-- index of the given 'OpArray'. The given
-- Metadata and string are copied when creating the op, and can be safely
-- destroyed immediately after calling this function.
opSendStatusServer :: (OpArray) -> (Int) -> (Int) -> (MetadataKeyValPtr) -> (StatusCode) -> (Slice) -> IO ()
opSendStatusServer a1 a2 a3 a4 a5 a6 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = fromIntegral a3} in 
  let {a4' = id a4} in 
  let {a5' = (fromIntegral . fromEnum) a5} in 
  let {a6' = id a6} in 
  opSendStatusServer'_ a1' a2' a3' a4' a5' a6' >>
  return ()

{-# LINE 109 "nix/third-party/gRPC-haskell/core/src/Network/GRPC/Unsafe/Op.chs" #-}


foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h create_status_code_ptr"
  createStatusCodePtr'_ :: (IO (C2HSImp.Ptr C2HSImp.CInt))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h deref_status_code_ptr"
  derefStatusCodePtr'_ :: ((C2HSImp.Ptr C2HSImp.CInt) -> (IO C2HSImp.CInt))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h destroy_status_code_ptr"
  destroyStatusCodePtr'_ :: ((C2HSImp.Ptr C2HSImp.CInt) -> (IO ()))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h op_array_create"
  opArrayCreate'_ :: (C2HSImp.CULong -> (IO (OpArray)))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h op_array_destroy"
  opArrayDestroy'_ :: ((OpArray) -> (C2HSImp.CULong -> (IO ())))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h op_send_initial_metadata"
  opSendInitialMetadata'_ :: ((OpArray) -> (C2HSImp.CULong -> ((MetadataKeyValPtr) -> (C2HSImp.CULong -> (IO ())))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h op_send_initial_metadata_empty"
  opSendInitialMetadataEmpty'_ :: ((OpArray) -> (C2HSImp.CULong -> (IO ())))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h op_send_message"
  opSendMessage'_ :: ((OpArray) -> (C2HSImp.CULong -> ((ByteBuffer) -> (IO ()))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h op_send_close_client"
  opSendCloseClient'_ :: ((OpArray) -> (C2HSImp.CULong -> (IO ())))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h op_recv_initial_metadata"
  opRecvInitialMetadata'_ :: ((OpArray) -> (C2HSImp.CULong -> ((C2HSImp.Ptr (MetadataArray)) -> (IO ()))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h op_recv_message"
  opRecvMessage'_ :: ((OpArray) -> (C2HSImp.CULong -> ((C2HSImp.Ptr (ByteBuffer)) -> (IO ()))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h op_recv_status_client"
  opRecvStatusClient'_ :: ((OpArray) -> (C2HSImp.CULong -> ((C2HSImp.Ptr (MetadataArray)) -> ((C2HSImp.Ptr C2HSImp.CInt) -> ((Slice) -> (IO ()))))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h op_recv_close_server"
  opRecvCloseServer'_ :: ((OpArray) -> (C2HSImp.CULong -> ((C2HSImp.Ptr C2HSImp.CInt) -> (IO ()))))

foreign import ccall unsafe "bazel-out/k8-fastbuild/bin/nix/third-party/gRPC-haskell/core/chs-src_Network_GRPC_Unsafe_Op.chs/Network/GRPC/Unsafe/Op.chs.h op_send_status_server"
  opSendStatusServer'_ :: ((OpArray) -> (C2HSImp.CULong -> (C2HSImp.CULong -> ((MetadataKeyValPtr) -> (C2HSImp.CInt -> ((Slice) -> (IO ())))))))

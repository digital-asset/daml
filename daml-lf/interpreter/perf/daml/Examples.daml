-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Examples where
{-
triangle 0 = 0
triangle n = n + triangle (n-1)

triangleTR = triangleTR_acc 0
triangleTR_acc acc 0 = acc
triangleTR_acc acc n = triangleTR_acc (acc+n) (n-1)

altTriangleTR n = altTriangleTR_acc (0,n)
altTriangleTR_acc (acc,n) = if n == 0 then acc else altTriangleTR_acc (acc+n, n-1)

nfib 0 = 1
nfib 1 = 1
nfib n = nfib (n-1) + nfib (n-2) + 1

decrement : Int -> Int
decrement n = n - 1

mysub : Int -> Int -> Int
mysub a b = a - b

thrice : (a -> a) -> a -> a
thrice f x = f (f (f x))

useThriceA : Int
useThriceA = thrice decrement 100

useThriceB : Int
useThriceB = thrice thrice decrement 100

mymap : (a -> b) -> [a] -> [b]
mymap f [] = []
mymap f (x::xs) = f x :: mymap f xs

myzip : [a] -> [b] -> [(a,b)]
myzip (x::xs) (y::ys) = (x,y)::myzip xs ys
myzip _ [] = []
myzip [] _ = []

upto : Int -> Int -> [Int]
upto a b = if a <= b then a :: upto (a+1) b else []

useThriceC q = do
  let thrice f x = f (f (f x)) +q
  let decrement x = x-1 +q
  (thrice decrement 100, thrice decrement 200)

cpsStyle one two k =
  one 11 (\a -> two 22 (\b -> k a b))

anfTalkExample a b c d e f =
  let x = (a*b*c - d*e*f) in
  x*x + 1

nbeExample = \arg -> do
  let dub x = x + x
  let twice f x = f (f x)
  let increase q x = dub x + q
  twice (increase (arg+1)) 3

nbeExamplePreventLL = \zero arg -> do
  let dub x = x + x + zero
  let twice f x = f (f x) + zero
  let increase q x = dub x + q
  twice (increase (arg+1)) 3
-}

----------------------------------------------------------------------

identity x = x

absdiff : Int -> Int -> Int
absdiff x y =
  if x > y then x - y else y - x

manhattan (a,b) (c,d) =
  absdiff a c + absdiff b d

thrice : (a -> a) -> a -> a
thrice func arg =
  func (func (func arg))

useThrice : Int -> Int
useThrice a =
  let decrease = \x -> x - a in
  thrice decrease 100

factorial : Int -> Int
factorial n =
  if n <= 1 then 1 else n * factorial (n-1)

factorialAcc : Int -> Int -> Int
factorialAcc n acc =
  if n <= 1 then acc else factorialAcc (n-1) (n*acc)

myMap : (a -> b) -> [a] -> [b]
myMap f [] = []
myMap f (x::xs) = f x :: myMap f xs

--myMap f xs = case xs of [] -> []; x::xs -> f x :: myMap f xs -- same!

// Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

// .proto representation of the first version of the Daml-LF language,
// as specified by
// <https://github.com/digital-asset/daml/blob/main/daml-lf/spec/daml-lf-1.rst>.
//
// A few notes:
//
// * We generally "compress" structures that are often repeated, such as
//   application, let bindings, abstractions, etc.. In the Haskell / Scala
//   AST we probably will use the normal binary forms.
// * We generally never "newtype" strings, even if it might be good in
//   the actual AST. This is to keep the message structure relatively flat
//   and light.


// Minor version history:
// * 0 (somewhen in December 2018): initial version
// * 1 --  2019-01-10: Add Optional type
//     --  2019-01-27: Add <, <=, =>, > for Party
//     --  2019-01-29: Add PrimType.ARROW
// * 2 --  2019-03-18: Add BuiltinFunction.{SHA256_TEXT, PARTY_TO_TEXT, TEXT_TO_PARTY}
//     --  2019-03-18: Add flexible controllers (change scoping of controller expressions)
// * 3 --  2019-03-25: Add contract keys
//     --  2019-03-27: Add Map type
// * 4 --  2019-05-15: Add complex contract keys
// * 5 --  2019-05-22: Relax serializability constraints for contract ids
//         2019-05-23: Add BuiltinFunction.COERCE_CONTRACT_ID
//         2019-05-24: Make actors in exercise optional
// * 6 --  2019-05-27: Add enum type.
//         2019-06-04: Add BuiltinFunction.{CODE_POINTS_TO_TEXT, TEXT_TO_CODE_POINTS}
//         2019-06-12: Add Package.interned_package_ids and PackageRef.interned_id
// * 7 --  2019-07-29: Add nat kind and Nat types, Numeric types and Numeric builtins
//         2019-09-17: Add Any type and, `to_any` and `from_any` builtins
//         2019-09-17: Drop support for Decimal
//         2019-09-30: Add interning of strings and dotted names
//         2019-11-04: Add Type representation values
// * 8 --  2019-11-22: Rename Map to TextMap
//         2019-11-28: Rename Tuple to Struct
//         2019-12-03: Add type synonyms
//         2020-02-20: Add PackageMetadata.
// * 11 -- 2019-11-12: Add Generic Map (GenMap)
//         2019-12-05: Add Generic Equality builtin
//         2019-10-13: Add ExerciseByKey Update
//         2020-11-04: Add interning of types
//         2020-11-20: Add choice-observers
// * 12 -- 2021-01-27: No Archive changes
// * 13 -- 2021-04-06: Add BigNumeric
// * 14 -- 2021-03-06: Add Exception
// * 15 -- 2022-06-18: Add Interfaces
// * dev (special staging area for the next version to be released)

syntax = "proto3";
package daml_lf_1;

option java_package = "com.daml.daml_lf_dev";
option csharp_namespace = "Com.Daml.Daml_Lf_Dev.DamlLf1";

// Canonical encoding in one-ofs for cases that carry no meaningful
// values.
message Unit {}

// Package reference
message PackageRef {
  oneof Sum {

    // Reference to the package of which the package this reference
    // belongs.
    Unit self = 1;

    // A `Package identifier` for an imported Package.
    // *Must be a list of valid packageId string*
    string package_id_str = 2; // *Available in versions < 1.7*

    // An index into `interned_package_ids` of the Package containing
    // this reference.
    // *Must be a valid interned package Id string*
    int32 package_id_interned_str = 3;
  }
}

// A `name`, e.g. Util.Either.isLeft
// *Available in version < 1.7*
message DottedName {

  // *Must be a non-empty list of a valid identifiers*
  repeated string segments = 1;

}

// A fully qualified module reference
message ModuleRef {

  // package where the module is defined.
  PackageRef package_ref = 1;

  oneof module_name {
    // module name
    DottedName module_name_dname = 2; // *Available in version < 1.7*

    int32 module_name_interned_dname = 3; // *Available in version >= 1.7*
  }

}

// A fully qualified reference to a type constructor name.
message TypeConName {

  // Module where the type is defined.
  ModuleRef module = 1;

  oneof name {
    // type constructor name.
    DottedName name_dname = 2;

    // *Must be a valid interned name*
    int32 name_interned_dname = 3; // *Available in versions >= 1.7*
  }
}

// A fully qualified reference to a type synonym name.
// *Available in versions >= 1.8*
message TypeSynName {

  // Module where the type is defined.
  ModuleRef module = 1;

  oneof name {
    // type synonym name.
    DottedName name_dname = 2;

    // *Must be a valid interned name*
    int32 name_interned_dname = 3;
  }
}

// A fully qualified reference to a value definition.
message ValName {

  // Module where the value is defined
  ModuleRef module = 1;

  // *Must be a non-empty list of valid identifier*
  repeated string name_dname = 2; // *Available in version < 1.7*

  // *Must be a valid interned name*
  int32 name_interned_dname = 3; // *Available in versions >= 1.7*
}

// A field name definition in a record or a variant associated with a type.
message FieldWithType {

  oneof field {
      // *Must be a valid identifier*
      string field_str = 1; // *Available in version < 1.7*

      // *Must a valid interned identifier*
      int32 field_interned_str = 3; // *Available in versions >= 1.7*
  }

  // Type associated
  Type type = 2;
}

// Binder associated with a type.
message VarWithType {

  // Name of the bound expression variable.
  oneof var {
    // *Must be a valid identifier*
    string var_str = 1; // *Available in version < 1.7*

    // *Must be a valid interned identifier*
    int32 var_interned_str = 3; // *Available in versions >= 1.7*
  }

  // Type of the bound variable
  Type type = 2;
}

// Type binder associated with a kind.
message TypeVarWithKind {

  // Name of the bound expression variable
  oneof var {
    // *Must be a valid identifier*
    string var_str = 1; // *Available in version < 1.7*

    // *Must be a valid interned identifier*
    int32 var_interned_str = 3; // *Available in versions >= 1.7*
  }

  // Kind of the bound variable
  Kind kind = 2;
}

// A field in a record with its value.
message FieldWithExpr {

  oneof field {
    // *Must be a valid identifier*
    string field_str = 1; // *Available in version < 1.7*

    // *Must be a valid interned identifier*
    int32 field_interned_str = 3; // *Available in versions >= 1.7*
  }

  // Value of the field
  Expr expr = 2;
}

// A binding of a typed binder to an expression
message Binding {
  // The binder (expression variable and type)
  VarWithType binder = 1;
  // The value to which the variable is bound.
  Expr bound = 2;
}

// Kinds
message Kind {

  // The kind of polimorphic type.
  message Arrow {
    // parameter of the kind
    // *Must be non-empty*
    repeated Kind params = 1;
    Kind result = 2;
  }

  oneof Sum {
    // Kind of monomorphic type.
    Unit star = 1;
    // Kind of polymorphic type.
    Arrow arrow = 2;
    // kind of TNat type;
    // *Available in versions >= 1.7*
    Unit nat = 3;
  }
}

// Builtin primitive types
enum PrimType {
  // Builtin type 'Unit'
  UNIT = 0;

  // Builtin type 'Bool'
  BOOL = 1;

  // Builtin type 'Int64'
  INT64 = 2;

  // Builtin type for legacy 'Decimal'
  // Alias for (Numeric 10)
  // *available in version < 1.7*
  DECIMAL = 3;

  // CHAR = 4; // we have removed this in favor of TEXT for everything text related.

  // Builtin type 'Text'
  TEXT = 5;

  // Builtin type 'Timestamp'
  TIMESTAMP = 6;

  // RELTIME = 7; // we removed this in favor of INT64.

  // Builtin tpe 'Party'
  PARTY = 8;

  // Builtin type 'List'
  LIST = 9;

  // Builtin type 'Update'
  UPDATE = 10;

  // Builtin type 'Scenario'
  SCENARIO = 11;

  // Builtin type 'Date'
  DATE = 12;

  // Builtin type 'ContractId'
  CONTRACT_ID = 13;

  // Builtin type 'Optional'
  OPTIONAL = 14;

  // Builtin type `TArrow`
  ARROW = 15;

  // Builtin type 'TTextMap`
  TEXTMAP = 16;

  // Builtin type 'Numeric'
  // *Available in versions >= 1.7*
  NUMERIC = 17;

  // Builtin type 'Any'
  // *Available in versions >= 1.7*
  ANY = 18;

  // Builtin type 'TypeRep'
  // *Available in versions >= 1.7*
  TYPE_REP = 19;

  // Builtin type 'TGenMap`
  // *Available in versions >= 1.11*
  GENMAP = 20;

  // Builtin type 'TBigNumeric'
  // *Available in versions >= 1.13*
  BIGNUMERIC = 21;

  // Builtin type 'TRoundingMode'
  // *Available in versions >= 1.13*
  ROUNDING_MODE = 22;

  // Builtin type 'TAnyException'
  // *Available in versions >= 1.14*
  ANY_EXCEPTION = 23;
}

// Types
message Type {

  // Possibly applied type variable 'TyVar'
  message Var {

    // Name of the variable.
    oneof var {
      // *Must be a valid identifier*
      string var_str = 1; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 var_interned_str = 3; // *Available in versions >= 1.7*
    }

    // Types to which the variable is applied
    repeated Type args = 2;
  }

  // Possibly applied type constructor 'TyCon'
  message Con {

    // Name of the type constructor name
    TypeConName tycon = 1;

    // Type to which the constructor name is applied.
    repeated Type args = 2;
  }

  // Fully applied type constructor 'TySyn'
  // *Available in versions >= 1.8*
  message Syn {

    // Name of the type synonym
    TypeSynName tysyn = 1;

    // Types to which the synonym is applied.
    repeated Type args = 2;
  }

  // Possibly applied builtin types
  message Prim {

    // Builtin type
    // FixMe: Rename
    PrimType prim = 1;

    // Types to which the builtin type is applied.
    repeated Type args = 2;
  }

  // Universal quantification 'TyForAll'
  message Forall {
    // binders of the quantification
    // *Must be non-empty*
    repeated TypeVarWithKind vars = 1;
    // Body of the quantification
    Type body = 2;
  }

  // Struct type
  message Struct {
    // name of the field with their types.
    repeated FieldWithType fields = 1;
  }

  oneof Sum {
    Var var = 1;
    Con con = 2;
    Prim prim = 3; // FixMe: renamed
    Forall forall = 5;
    Struct struct = 7;
    // *Available in versions >= 1.7*
    // *Must be between 0 and 37 (bounds inclusive)*
    // use standard signed long for future usage.
    sint64 nat = 11;
    Syn syn = 12; // *Available in versions >= 1.8*

    int32 interned = 13; // *Available in versions >= 1.11*
  }

  reserved 4; // This was fun.  Removed in favour of PrimType.ARROW
  reserved 6; // This was list. Removed in favour of PrimType.LIST
  reserved 8; // This was contract_id. Removed in favour of PrimType.CONTRACT_ID
  reserved 9; // This was update. Removed in favour of PrimType.UPDATE
  reserved 10; // This was scenario. Removed in favor of PrimType.SCENARIO

}

// Primitive constructors
enum PrimCon {

  // Unit value '()'
  CON_UNIT = 0;

  // 'False' boolean value
  CON_FALSE = 1;

  // 'True' boolean value
  CON_TRUE = 2;
}

// Builtin functions
// Refer to Daml-LF major version 1 specification for types and behavior of those.
enum BuiltinFunction {
  ADD_DECIMAL = 0; // *Available in versions < 1.7*
  SUB_DECIMAL = 1; // *Available in versions < 1.7*
  MUL_DECIMAL = 2; // *Available in versions < 1.7*
  DIV_DECIMAL = 3; // *Available in versions < 1.7*
  ROUND_DECIMAL = 6; // *Available in versions < 1.7*

  ADD_NUMERIC = 107;    // *Available in versions >= 1.7*
  SUB_NUMERIC = 108;    // *Available in versions >= 1.7*
  MUL_NUMERIC = 109;    // *Available in versions >= 1.7*
  DIV_NUMERIC = 110;    // *Available in versions >= 1.7*
  ROUND_NUMERIC = 111;  // *Available in versions >= 1.7*
  CAST_NUMERIC = 121;   // *Available in versions >= 1.7*
  SHIFT_NUMERIC = 122;  // *Available in versions >= 1.7*

  ADD_INT64 = 7;
  SUB_INT64 = 8;
  MUL_INT64 = 9;
  DIV_INT64 = 10;
  MOD_INT64 = 11;
  EXP_INT64 = 12;

  FOLDL = 20;
  FOLDR = 21;
  XX_WITH_AUTHORITY_OF = 149; //NICK, no!

  TEXTMAP_EMPTY = 96;
  TEXTMAP_INSERT = 97;
  TEXTMAP_LOOKUP = 98;
  TEXTMAP_DELETE = 99;
  TEXTMAP_TO_LIST = 100;
  TEXTMAP_SIZE = 101;

  GENMAP_EMPTY = 124; // *Available in versions >= 1.11*
  GENMAP_INSERT = 125; // *Available in versions >= 1.11*
  GENMAP_LOOKUP = 126; // *Available in versions >= 1.11*
  GENMAP_DELETE = 127; // *Available in versions >= 1.11*
  GENMAP_KEYS = 128; // *Available in versions >= 1.11*
  GENMAP_VALUES = 129; // *Available in versions >= 1.11*
  GENMAP_SIZE = 130; // *Available in versions >= 1.11*

  EXPLODE_TEXT = 23;
  APPEND_TEXT = 24;

  ERROR = 25;
  ANY_EXCEPTION_MESSAGE = 147;              // *Available in versions >= 1.14*

  LEQ_INT64 = 33;         // *Available in versions < 1.11*
  LEQ_DECIMAL = 34;       // *Available in versions < 1.7*
  LEQ_NUMERIC = 112;      // *Available in versions >= 1.7 and < 1.11*
  LEQ_TEXT = 36;          // *Available in versions < 1.11*
  LEQ_TIMESTAMP = 37;     // *Available in versions < 1.11*
  LEQ_DATE = 67;          // *Available in versions < 1.11*
  LEQ_PARTY = 89;         // *Available in versions >= 1.1 and < 1.11*

  LESS_INT64 = 39;        // *Available in versions < 1.11*
  LESS_DECIMAL = 40;      // *Available in versions < 1.7*
  LESS_NUMERIC = 113;     // *Available in versions >= 1.7 and < 1.11*
  LESS_TEXT = 42;         // *Available in versions < 1.11*
  LESS_TIMESTAMP = 43;    // *Available in versions < 1.11*
  LESS_DATE = 68;         // *Available in versions < 1.11*
  LESS_PARTY = 90;        // *Available in versions >= 1.1 and < 1.11*

  GEQ_INT64 = 45;         // *Available in versions < 1.11*
  GEQ_DECIMAL = 46;       // *Available in versions < 1.7*
  GEQ_NUMERIC = 114;      // *Available in versions >= 1.7 and < 1.11*
  GEQ_TEXT = 48;          // *Available in versions < 1.11*
  GEQ_TIMESTAMP = 49;     // *Available in versions < 1.11*
  GEQ_DATE = 69;          // *Available in versions < 1.11*
  GEQ_PARTY = 91;         // *Available in versions >= 1.1 and < 1.11*

  GREATER_INT64 = 51;     // *Available in versions < 1.11*
  GREATER_DECIMAL = 52;   // *Available in versions < 1.7*
  GREATER_NUMERIC = 115;  // *Available in versions >= 1.7 and < 1.11*
  GREATER_TEXT = 54;      // *Available in versions < 1.11*
  GREATER_TIMESTAMP = 55; // *Available in versions < 1.11*
  GREATER_DATE = 70;      // *Available in versions < 1.11*
  GREATER_PARTY = 92;     // *Available in versions >= 1.1 and < 1.11*

  INT64_TO_TEXT = 57;
  DECIMAL_TO_TEXT = 58;  // *Available in versions < 1.7*
  NUMERIC_TO_TEXT = 116;  // *Available in versions >= 1.7*
  TEXT_TO_TEXT = 60;
  TIMESTAMP_TO_TEXT = 61;
  DATE_TO_TEXT = 71;
  PARTY_TO_QUOTED_TEXT = 63; // *Available in versions < 1.14*
  PARTY_TO_TEXT = 94;
  TEXT_TO_PARTY = 95;
  TEXT_TO_INT64 = 103;
  TEXT_TO_DECIMAL = 104;
  TEXT_TO_NUMERIC = 117;  // *Available in versions >= 1.7*
  CONTRACT_ID_TO_TEXT = 136; // *Available in versions >= 1.11*
  SHA256_TEXT = 93;

  DATE_TO_UNIX_DAYS = 72; // Date -> Int64
  UNIX_DAYS_TO_DATE = 73; // Int64 -> Date

  TIMESTAMP_TO_UNIX_MICROSECONDS = 74; // Timestamp -> Int64
  UNIX_MICROSECONDS_TO_TIMESTAMP = 75; // Int64 -> Timestamp

  INT64_TO_DECIMAL = 76;  // *Available in versions < 1.7*
  DECIMAL_TO_INT64 = 77;  // *Available in versions < 1.7*

  INT64_TO_NUMERIC = 118;  // *Available in versions >= 1.7*
  NUMERIC_TO_INT64 = 119;  // *Available in versions >= 1.7*

  IMPLODE_TEXT = 78;

  EQUAL_INT64 = 79;       // *Available in versions < 1.11*
  EQUAL_DECIMAL = 80;     // *Available in versions < 1.7*
  EQUAL_NUMERIC = 120;    // *Available in versions >= 1.7 and < 1.11*
  EQUAL_TEXT = 81;        // *Available in versions < 1.11*
  EQUAL_TIMESTAMP = 82;   // *Available in versions < 1.11*
  EQUAL_DATE = 83;        // *Available in versions < 1.11*
  EQUAL_PARTY = 84;       // *Available in versions < 1.11*
  EQUAL_BOOL = 85;        // *Available in versions < 1.11*
  EQUAL_CONTRACT_ID = 86; // *Available in versions < 1.11*
  EQUAL_LIST = 87;
  EQUAL_TYPE_REP = 123;   // *Available in versions = 1.8*

  EQUAL = 131;            // *Available in versions >= 1.11*
  LESS_EQ = 132;          // *Available in versions >= 1.11*
  LESS = 133;             // *Available in versions >= 1.11*
  GREATER_EQ = 134;       // *Available in versions >= 1.11*
  GREATER = 135;          // *Available in versions >= 1.11*

  TRACE = 88;

  COERCE_CONTRACT_ID = 102;

  CODE_POINTS_TO_TEXT = 105;
  TEXT_TO_CODE_POINTS = 106;

  SCALE_BIGNUMERIC = 137; // *Available in versions >= 1.13*
  PRECISION_BIGNUMERIC = 138; // *Available in versions >= 1.13*
  ADD_BIGNUMERIC = 139; // *Available in versions >= 1.13*
  SUB_BIGNUMERIC = 140; // *Available in versions >= 1.13*
  MUL_BIGNUMERIC = 141; // *Available in versions >= 1.13*
  DIV_BIGNUMERIC = 142; // *Available in versions >= 1.13*
  SHIFT_RIGHT_BIGNUMERIC = 143; // *Available in versions >= 1.13*
  BIGNUMERIC_TO_NUMERIC = 144; // *Available in versions >= 1.13*
  NUMERIC_TO_BIGNUMERIC = 145; // *Available in versions >= 1.13*
  BIGNUMERIC_TO_TEXT = 146; // *Available in versions >= 1.13*

  TYPEREP_TYCON_NAME = 148; // *Available in versions >= 1.dev*

  // Next id is 150.

  // EXPERIMENTAL TEXT PRIMITIVES -- these do not yet have stable numbers.
  TEXT_TO_UPPER = 9901; // *Available in versions >= 1.dev*
  TEXT_TO_LOWER = 9902; // *Available in versions >= 1.dev*
  TEXT_SLICE = 9903; // *Available in versions >= 1.dev*
  TEXT_SLICE_INDEX = 9904; // *Available in versions >= 1.dev*
  TEXT_CONTAINS_ONLY = 9905; // *Available in versions >= 1.dev*
  TEXT_REPLICATE = 9906; // *Available in versions >= 1.dev*
  TEXT_SPLIT_ON = 9907; // *Available in versions >= 1.dev*
  TEXT_INTERCALATE = 9908; // *Available in versions >= 1.dev*
}

// Builtin literals
// FixMe: Renamed
message PrimLit {

  // match java.math.BigDecimal.ROUND_XXX constants
  enum RoundingMode {
    UP = 0;
    DOWN = 1;
    CEILING = 2;
    FLOOR = 3;
    HALF_UP = 4;
    HALF_DOWN = 5;
    HALF_EVEN = 6;
    UNNECESSARY = 7;
  }

  oneof Sum {

    //  64-bit integer literal ('LitInt64')
    sint64 int64 = 1;

    // *Must be a valid representation of decimal*
    string decimal_str = 2; // *Available in versions < 1.7*

    // *Must be a valid interned numeric */
    int32 numeric_interned_str = 10; // *Available in versions >= 1.7*

    string text_str = 4; // *Available in version < 1.7*

    // *Must be a valid interned text*
    int32 text_interned_str = 11; // *Available in versions >= 1.7*

    // *Must be a valid timestamp*
    sfixed64 timestamp = 5;

    // *Must be a valid PartyId string*
    string party_str = 7; // *Available in version < 1.7*

    // *Must be a valid interned PartyId string*
    int32 party_interned_str = 12; // *Available in versions >= 1.7*

    // *Must be a valid date*
    int32 date = 8;

    // rounding mode for arithmetic operation
    // *Available in versions >= 1.13*
    RoundingMode rounding_mode = 13;
  }

  reserved 3; // This was char.
  reserved 6; // This was reltime;
}

// Source code locations
message Location {

  // 0-indexed start and end line and column numbers.
  message Range {
    int32 start_line = 1;
    int32 start_col = 2;
    int32 end_line = 3;
    int32 end_col = 4;
  }

  ModuleRef module = 1; // (*optional*), if missing the line is within the current module.
  Range range = 2;
}


// Expressions
message Expr {

  // Record construction ('ExpRecCon')
  message RecCon {

    // type of the record being constructed
    Type.Con tycon = 1;

    // Field names and the associated values.
    repeated FieldWithExpr fields = 2;
  }

  // Record projection (ExpRecProj)
  message RecProj {

    // type of the record being projected.
    Type.Con tycon = 1;

    // Name of the record field to be projected on.
    oneof field {
      // *Must be a valid identifier*
      string field_str = 2; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 field_interned_str = 4; // *Available in versions >= 1.7*
    }

    // projected expression
    Expr record = 3;
  }

  // Record update ('ExpRecUp')
  message RecUpd {

    // type of the record being updated
    Type.Con tycon = 1;

    // Name of the updated field.
    oneof field {
      // *Must be a valid identifier*
      string field_str = 2; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 field_interned_str = 5; // *Available in versions >= 1.7*
    }

    // Actual record being updated
    Expr record = 3;

    // Value to wich the record is udpated
    Expr update = 4;
  }

  // Variant construction ('ExpVariantCon')
  message VariantCon {

    // type of the variant being constructed
    Type.Con tycon = 1;

    // name of the variant constructor
    oneof variant_con {
      // *Must be a valid identifier*
      string variant_con_str = 2; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 variant_con_interned_str = 4; // *Available in versions >= 1.7*
    }

    // Argument of the variant.
    Expr variant_arg = 3;
  }

  // Enum construction ('ExpEnumCon')
  message EnumCon {

    // Name of the type constructor name
    TypeConName tycon = 1;

    // name of the enum constructor
    oneof enum_con {
      // *Must be a valid identifier*
      string enum_con_str = 2; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 enum_con_interned_str = 3; // *Available in versions >= 1.7*
    }
  }

  // Struct Construction ('ExpStructCon')
  message StructCon {
    // Field names and their associated values.
    repeated FieldWithExpr fields = 1;
  }

  // Struct Projection ('ExpStructProj')
  message StructProj {

    // Name of the field to be projected on.
    oneof field {
      // *Must be a valid Identifier*
      string field_str = 1; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 field_interned_str = 3; // *Available in versions >= 1.7*
    }

    // struct to be projected.
    Expr struct = 2;
  }

  // Struct update ('ExpTuplUpdate')
  message StructUpd {

    // Name of the updated field.
    oneof field {
      // *Must be a valid identifier*.
      string field_str = 1; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 field_interned_str = 4; // *Available in versions >= 1.7*
    }

    // Actual struct being updated.
    Expr struct = 2;

    // Value to which the record is udpated.
    Expr update = 3;
  }

  // Application ('ExpApp')
  message App {

    // Function
    Expr fun = 1;

    // Arguments of the function.
    // *Must be non-empty*
    repeated Expr args = 2;
  }

  // Type application ('ExpTyApp')
  message TyApp {

    // Polymorphic expression
    Expr expr = 1;

    // Arguments of the function.
    // *Must be non-empty*
    repeated Type types = 2;
  }

  // Abstraction ('ExpAbs')
  message Abs {

    // Abstracted Variables with their kind
    // *Must be non-empty*
    repeated VarWithType param = 1;

    // Abstracted value
    Expr body = 2;
  }

  message TyAbs {

    // Abstracted Variables with their type
    // *Must be non-empty*
    repeated TypeVarWithKind param = 1;

    // Abstracted value
    Expr body = 2;
  }

  // Empty list ('ExpNil')
  message Nil {

    // type of the list elements.
    Type type = 1;
  }

  // Non empty list
  message Cons {

    // type of the list elements.
    Type type = 1;

    // Front element of the list.
    // *Must be non-empty*
    repeated Expr front = 2;

    // tail of the list
    Expr tail = 3;
  }

  // (*Since version 1*)
  // Empty optional value
  message OptionalNone {

    // type of the element
    Type type = 1;
  }

  // (*Since version 1*)
  // Non empty optional value
  message OptionalSome {

    // type of the element
    Type type = 1;

    // contained value
    // FixMe: renamed to 'value'
    Expr body = 2;
  }

  // Wrap a value in Any
  // *Available in versions >= 1.7*
  message ToAny {
    // type of argument. Must be the TypeConName of a template.
    Type type = 1;
    // argument
    Expr expr = 2;
  }

  // Extract the given type from Any or return None on type-mismatch
  // *Available in versions >= 1.7*
  message FromAny {
    // type that should be extracted. Must be the TypeConName of a template.
    Type type = 1;
    // Value of type Any
    Expr expr = 2;
  }

  // Wrap an exception value in AnyException
  // *Available in versions >= 1.14*
  message ToAnyException {
    // type of argument. Must be an exception type.
    Type type = 1;
    // argument
    Expr expr = 2;
  }

  // Extract the given exception type from AnyException or return None on type-mismatch
  // *Available in versions >= 1.14*
  message FromAnyException {
    // type that should be extracted. Must be an exception type.
    Type type = 1;
    // Value of type AnyException
    Expr expr = 2;
  }

  // Throw an exception.
  // *Available in versions >= 1.14*
  message Throw {
    // Overall type of the "throw" expression.
    Type return_type = 1;
    // Type of exception to throw. Must be an exception type.
    Type exception_type = 2;
    // Value of type "exception_type".
    Expr exception_expr = 3;
  }

  // Convert a template payload to an interface.
  // *Available in versions >= 1.15*
  message ToInterface {
    TypeConName interface_type = 1;
    TypeConName template_type = 2;
    Expr template_expr = 3;
  }

  // Convert an interface back to a template payload if possible.
  // *Available in versions >= 1.15*
  message FromInterface {
    TypeConName interface_type = 1;
    TypeConName template_type = 2;
    Expr interface_expr = 3;
  }

  // Invoke an interface method.
  // *Available in versions >= 1.15*
  message CallInterface {
    TypeConName interface_type = 1;
    int32 method_interned_name = 2;
    Expr interface_expr = 3;
  }

  // Obtain an interface view
  // *Available in versions >= 1.15*
  message ViewInterface {
    TypeConName interface = 1;
    Expr expr = 2;
  }

  // Obtain the signatories of a contract through an interface
  // *Available in versions >= 1.15*
  message SignatoryInterface {
    // Interface type
    TypeConName interface = 1;
    // Interface argument
    Expr expr = 2;
  }

  // Obtain the observers of a contract through an interface
  // *Available in versions >= 1.15*
  message ObserverInterface {
    // Interface type
    TypeConName interface = 1;
    // Interface argument
    Expr expr = 2;
  }



  // Convert an interface back to a template payload, or raises WronglyTypedContract if not possible.
  // *Available in versions >= 1.dev*
  message UnsafeFromInterface {
    TypeConName interface_type = 1;
    TypeConName template_type = 2;
    Expr contract_id_expr = 3;
    Expr interface_expr = 4;
  }

  // Upcast from an interface payload to an interface it requires.
  // *Available in versions >= 1.dev*
  message ToRequiredInterface {
    TypeConName required_interface = 1;
    TypeConName requiring_interface = 2;
    Expr expr = 3;
  }

  // Downcast from an interface payload to an interface that requires it, if possible.
  // *Available in versions >= 1.dev*
  message FromRequiredInterface {
    TypeConName required_interface = 1;
    TypeConName requiring_interface = 2;
    Expr expr = 3;
  }

  // Downcast from an interface payload to an interface that requires it, or raises WronglyTypedContract if not possible.
  // *Available in versions >= 1.dev*
  message UnsafeFromRequiredInterface {
    TypeConName required_interface = 1;
    TypeConName requiring_interface = 2;
    Expr contract_id_expr = 3;
    Expr interface_expr = 4;
  }

  // Obtain the type representation of a contract through an interface
  // *Available in versions >= 1.dev*
  message InterfaceTemplateTypeRep {
    // interface type
    TypeConName interface = 1;
    // interface argument
    Expr expr = 2;
  }

  // Obtain the controllers for a choice.
  // *Available in versions >= 1.dev*
  message ChoiceController {
    TypeConName template = 1;
    int32 choice_interned_str = 2;
    Expr contract_expr = 3;
    Expr choice_arg_expr = 4;
  }

  // Obtain the observers for a choice.
  // *Available in versions >= 1.dev*
  message ChoiceObserver {
    TypeConName template = 1;
    int32 choice_interned_str = 2;
    Expr contract_expr = 3;
    Expr choice_arg_expr = 4;
  }

  message Experimental {
    string name = 1;
    Type type = 2 ;
  }

  // Location of the expression in the Daml code source.
  // Optional
  Location location = 25;

  oneof Sum {

    // *Must be a valid identifier*
    string var_str = 1; // *Available in version < 1.7*

    // *Must be a valid interned identifier*
    int32 var_interned_str = 29; // *Available in versions >= 1.7*

    // Defined value ('ExpVal')
    ValName val = 2;

    // Builtin function ('ExpBuiltin')
    BuiltinFunction builtin = 3;

    // Primitive constructor ('()', 'False' or 'True')
    PrimCon prim_con = 4;

    // Builtin literal ('ExpBuiltin')
    PrimLit prim_lit = 5;

    // Record construction ('ExpRecCon')
    RecCon rec_con = 6;

    // Record projection ('ExpRecProj')
    RecProj rec_proj = 7;

    // Record udpate ('ExpRecUpdate')
    RecUpd rec_upd = 22;

    // Variant construction ('ExpVariantCon')
    VariantCon variant_con = 8;

    // Enum construction ('ExpEnumCon')
    EnumCon enum_con = 28;

    // Struct construction ('ExpStructCon')
    StructCon struct_con = 9;

    // Struct project ('ExpStructProj')
    StructProj struct_proj = 10;

    // Struct update ('ExpStructUpdate')
    StructUpd struct_upd = 23;

    // Application ('ExpApp')
    App app = 11;

    // Type Application ('ExpTyApp')
    TyApp ty_app = 12;

    // Abstraction ('ExpAbs')
    Abs abs = 13;

    // Type Abstraction ('ExpTyAbs')
    TyAbs ty_abs = 14;

    // Pattern Matching ('ExpCase')
    Case case = 15;

    // Let block ('ExpLet')
    Block let = 16;

    // Empty List ('ExpNil')
    Nil nil = 17;

    // Non Empty list ('ExpCons')
    Cons cons = 18;

    // Update expression ('ExpUpdate')
    Update update = 20;

    // Scenario Expression ('ExpScenario')
    Scenario scenario = 21;

    // empty optional value ('ExpNone')
    OptionalNone optional_none = 26;

    // non empty optional value ('ExpSome')
    OptionalSome optional_some = 27;

    // Wrap an arbitrary value in Any ('ExpToAny')
    // *Available in versions >= 1.7*
    ToAny to_any = 30;

    // Extract the given type from Any or return None on type-mismatch ('ExpFromAny')
    // *Available in versions >= 1.7*
    FromAny from_any = 31;

    // A type representation
    // *Available in versions >= 1.7*
    Type type_rep = 32;

    // Wrap an arbitrary exception into an AnyException ('ExpToAnyException').
    // *Available in versions >= 1.14*
    ToAnyException to_any_exception = 33;

    // Extract an arbitrary exception from an AnyException ('ExpFromAnyException').
    // *Available in versions >= 1.14*
    FromAnyException from_any_exception = 34;

    // Throw an exception ('ExpThrow').
    // *Available in versions >= 1.14*
    Throw throw = 35;

    // Convert to/from interface payloads.
    // *Available in versions >= 1.15*
    ToInterface to_interface = 36;
    FromInterface from_interface = 37;

    // Invoke an interface method.
    // *Available in versions >= 1.15*
    CallInterface call_interface = 38;

    // Obtain a contract's signatories/observers through an interface.
    // *Available in versions >= 1.15*
    SignatoryInterface signatory_interface = 39;
    ObserverInterface observer_interface = 40;

    // Invoke an interface method.
    // *Available in versions >= 1.15*
    ViewInterface view_interface = 41;

    // Unsafe conversion from interface payloads.
    // *Available in versions >= 1.15*
    UnsafeFromInterface unsafe_from_interface = 42;

    // Obtain the type representation of a contract's template through an interface.
    // *Available in versions >= 1.15*
    InterfaceTemplateTypeRep interface_template_type_rep = 43;

    // Upcast/downcast interface payloads.
    // *Available in versions >= 1.dev*
    ToRequiredInterface to_required_interface = 44;
    FromRequiredInterface from_required_interface = 45;
    UnsafeFromRequiredInterface unsafe_from_required_interface = 46;

    // Obtain the controllers for a choice.
    // *Available in versions >= 1.dev*
    ChoiceController choice_controller = 47;

    // Obtain the observers for a choice.
    // *Available in versions >= 1.dev*
    ChoiceObserver choice_observer = 48;

    Experimental experimental = 9999; // *Available only in 1.dev*
  }

  reserved 19; // This was equals. Removed in favour of BuiltinFunction.EQUAL_*
  reserved 24; // This was equal_contract_id. Removed in favour of BuiltinFunction.EQUAL_CONTRACT_ID
}

// Case alternative
message CaseAlt {

  // Variant pattern
  message Variant {

    // name of the type constructor
    TypeConName con = 1;

    // name of the variant constructor
    oneof variant {
      // *Must be a valid identifier*
      string variant_str = 2; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 variant_interned_str = 4; // *Available in versions >= 1.7*
    }

    // name of the variant binder
    oneof binder {
      // *Must be a valid identifier*
      string binder_str = 3; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 binder_interned_str = 5; // *Available in versions >= 1.7*
    }
  }

  // Enum pattern
  message Enum {

    // name of the type constructor
    TypeConName con = 1;

    // name of the variant constructor
    // *Must be a valid identifier*
    oneof constructor {
      // *Must be a valid identifier*
      string constructor_str = 2; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 constructor_interned_str = 3; // *Available in versions >= 1.7*
    }
  }

  // Non empty list pattern
  message Cons {

    // name of the binder for the head
    oneof var_head {
      // *Must be a valid identifier*
      string var_head_str = 1; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 var_head_interned_str = 3; // *Available in versions >= 1.7*
    }


    oneof var_tail {
      // *Must be a valid identifier*
      string var_tail_str = 2; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 var_tail_interned_str = 4; // *Available in versions >= 1.7*
    }
  }

  // Non empty option patterm
  message OptionalSome {

    oneof var_body {
      // *Must be a valid identifier*
      string var_body_str = 1; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 var_body_interned_str = 2; // *Available in versions >= 1.7*
    }
  }

  oneof Sum {
    Unit default = 1;
    Variant variant = 2;
    PrimCon prim_con = 3;
    Unit nil = 4;
    Cons cons = 5;
    Unit optional_none = 7;
    OptionalSome optional_some = 8;
    Enum enum = 9;
  }

  Expr body = 6;
}

message Case {
  Expr scrut = 1;
  repeated CaseAlt alts = 2;
}

// A block of bindings and an expression.
// Encodes a sequence of binds in e.g. a let or update block.
message Block {
  // *Must be non-empty*
  // Bindings
  repeated Binding bindings = 1;
  Expr body = 2;
}

// A Pure statement either scenario or update
message Pure {
  Type type = 1;
  Expr expr = 2;
}

message Update {

  // Create Update
  message Create {
    // Template type
    TypeConName template = 1;
    // Template argument
    Expr expr = 2;
  }

  // Interface Create Update
  // *Available in versions >= 1.15*
  message CreateInterface {
    // Interface type
    TypeConName interface = 1;
    // Interface argument
    Expr expr = 2;
  }

  // Exercise Update
  message Exercise {
    // Template type
    TypeConName template = 1;

    // name of the exercised template choice
    oneof choice {
      // *Must be a valid identifier*
      string choice_str = 2; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 choice_interned_str = 6; // *Available in versions >= 1.7*
    }

    // contract id
    Expr cid = 3;
    // actors
    reserved 4; // Was actor
    // argument
    Expr arg = 5;
  }

  // Interface Exercise Update
  // *Available in versions >= 1.15*
  message ExerciseInterface {
    // Interface type
    TypeConName interface = 1;

    // name of the exercised template choice
    // *Must be a valid interned identifier*
    int32 choice_interned_str = 2;

    // contract id
    Expr cid = 3;
    // argument
    Expr arg = 4;

    // exercise guard (Interface -> Bool)
    Expr guard = 5;  // *optional*  *Available in versions >= 1.16*
  }

 // ExerciseByKey Update
  message ExerciseByKey {
    // Template type
    TypeConName template = 1;
    // *Must be a valid interned identifier*
    int32 choice_interned_str = 2;
    // key
    Expr key = 3;
    // argument
    Expr arg = 4;
  }

  // Fetch Update
  message Fetch {
    // Template type
    TypeConName template = 1;
    // contract id
    Expr cid = 2;
    reserved 3; // was actor, we thought we'd need this, but we don't
  }

  // Interface Fetch Update
  // *Available in versions >= 1.15*
  message FetchInterface {
    // Interface type
    TypeConName interface = 1;
    // contract id
    Expr cid = 2;
  }

  // Embedded Expression Update
  message EmbedExpr {
    // Expression type
    Type type = 1;
    // Expression body
    Expr body = 2;
  }

  // Retrieve by key Update
  message RetrieveByKey {
    TypeConName template = 1;
    Expr key = 2;
  }

  // Try-catch block.
  message TryCatch {
    Type return_type = 1;
    Expr try_expr = 2;

    // Name of the bound expression variable.
    // *Must be a valid interned identifier*
    int32 var_interned_str = 3;
    Expr catch_expr = 4;
  }

  // WithAuthority Update
  // *Available in versions >= 1.dev*
  message WithAuthority {
    Type type = 1;
    // Requested authority
    Expr parties = 2;
    // Scoped update body
    Expr body = 3;
  }

  oneof Sum {
    Pure pure = 1;
    Block block = 2;
    Create create = 3;
    Exercise exercise = 4;
    ExerciseByKey exercise_by_key = 10; // *Available in versions >= 1.11*
    Fetch fetch = 5;
    Unit get_time = 6;
    RetrieveByKey lookup_by_key = 8;
    RetrieveByKey fetch_by_key = 9;
    // see similar constructor in `Scenario` on why this is useful.
    EmbedExpr embed_expr = 7;
    TryCatch try_catch = 11; // *Available in versions >= 1.14*
    CreateInterface create_interface = 12; // *Available in versions >= 1.15*
    ExerciseInterface exercise_interface = 13; // *Available in versions >= 1.15*
    FetchInterface fetch_interface = 14; // *Available in versions >= 1.15*
    WithAuthority with_authority = 15; // *Available in versions >= 1.dev*
  }
}

// Scenario actions
message Scenario {

  message Commit {
    // committing party
    Expr party = 1;
    //
    Expr expr = 2;
    // type of result
    Type ret_type = 3;
  }

  message EmbedExpr {
    Type type = 1;
    Expr body = 2;
  }

  oneof Sum {
    Pure pure = 1;
    Block block = 2;
    Commit commit = 3;
    Commit mustFailAt = 4;
    Expr pass = 5;
    Unit get_time = 6;
    Expr get_party = 7;
    // embed an expression of type Scenario. note that this construct is useful
    // to explicitly mark the start of scenario execution, which is useful in
    // top level definitions. for example if we hav
    //
    // def test : Scenario Unit = if <blah> then <this> else <that>
    //
    // this is not a value, since it's headed with an `if`, but we can turn
    // it into a value by wrapping the `if` with this constructor. in that
    // case, the `if` will be executed every time the scenario runs --
    // as expected.
    EmbedExpr embed_expr = 8;
  }
}

// Template choice definition.
message TemplateChoice {

  // *Must be a valid identifier*
  oneof name {
    string name_str = 1; // *Available in version < 1.7*

    // *Must be a valid interned identifier*
    int32 name_interned_str = 9; // *Available in versions >= 1.7*
  }

  // Choice type
  bool consuming = 2;

  // The controllers of the choice. They have type `List Party` and the
  // template parameter in scope, and the choice parameter. All of these
  // controllers need to authorize the exercising of this choice (aka
  // conjunctive choice controllers).
  Expr controllers = 3;

  // The additional informees of the choice. They have type `List Party`.
  Expr observers = 11; // *Available in versions >= 1.11*

  // Name to which the choice argument is bound and its type.
  VarWithType arg_binder = 4;

  // Return type of the choice.
  Type ret_type = 5;

  // Follow-up update of the choice. It has type `Update <ret_type>` and both
  // the template parameter and the choice parameter in scope.
  Expr update = 6;

  // Name to bind the ContractId of the contract this choice is exercised on to.
  oneof self_binder {
    // *Must be a valid identifier*
    string self_binder_str = 7; // *Available in version < 1.7*

    // *Must be a valid interned identifier*
    int32 self_binder_interned_str = 10; // *Available in versions >= 1.7*
  }

  Location location = 8;
}

// we restrict key expressions to records of projections, much like SQL
message KeyExpr {
  message Projection {
    Type.Con tycon = 1; // Always fully applied

    oneof field {
      // *Must be a valid identifier*
      string field_str = 2; // *Available in version < 1.7*

      // *Must be a valid interned identifier*
      int32 field_interned_str = 3; // *Available in versions >= 1.7*
    }
  }

  // note that the projection is always referring to the template parameter.
  message Projections {
    repeated Projection projections = 2;
  }

  message RecordField {
    oneof field {
      // *Must be a valid identifier*
      string field_str = 1; // *Available in version < 1.7*

      // *Must be a valid identifier*
      int32 field_interned_str = 3; // *Available in versions >= 1.7*
    }
    KeyExpr expr = 2;
  }

  message Record {
    Type.Con tycon = 1; // Always fully applied
    repeated RecordField fields = 2;
  }

  oneof Sum {
    Projections projections = 1;
    Record record = 2;
  }
}

  // Contents of an interface instance.
  // *Available in versions >= 1.15*
message InterfaceInstanceBody {

  message InterfaceInstanceMethod {
    int32 method_interned_name = 1;
    Expr value = 2;
  }

  repeated InterfaceInstanceMethod methods = 1;
  Expr view = 2;
}

// Contract template definition
message DefTemplate {

  message DefKey {
    Type type = 1;
    // NOTE(MH): The first version of contract keys had syntactic
    // restrictions that key expression had to be "simple". We lifted these
    // restrictions later and allowed arbitrarily complext key expressions.
    oneof key_expr {
      KeyExpr key = 2;
      Expr complex_key = 4;
    }
    Expr maintainers = 3; // a function from the key type to [Party]
  }

  // An interface instance defined in this template.
  // *Available in versions >= 1.15*
  message Implements {
    TypeConName interface = 1;
    InterfaceInstanceBody body = 2;
  }

  // The type constructor for the template, acting as both
  // the name of the template and the type of the template argument.
  oneof tycon {
    DottedName tycon_dname = 1;

    // *Must be a valid interned name*
    int32 tycon_interned_dname = 12; // *Available in versions >= 1.7*
  }

  // Name to which the template argument is bound.
  oneof param {
    // *Must be a valid identifier*
    string param_str = 2; // *Available in version < 1.7*

    // *Must be a valid interned identifier*
    int32 param_interned_str = 11; // *Available in versions >= 1.7*
  }

  // NOTE(MH): The new runtime authorization check for Daml 1.0 does not rely
  // on the stakeholder signatures produced by the obligables computation
  // anymore but uses the interpreter to compute the signatories and
  // stakeholders of contract instances.
  // REMOVED: TemplateStakeholders stakeholders = 3;
  reserved 3;

  // Pre-condition that the template argument must satisfy.
  // When present, it has type `Bool` and the template parameter in scope.
  // *Optional*, interpreted as 'True' if undefined
  Expr precond = 4;

  // The signatories of the contract. They have type `List Party` and the
  // template parameter in scope.
  Expr signatories = 5;

  // The agreement text associated with the contract. It has type `Text` and
  // the template parameter in scope.
  Expr agreement = 6;

  // The choices available in the resulting contract.
  repeated TemplateChoice choices = 7;

  // The observers of the contract. They have type `List Party` and the
  // template parameter in scope.
  Expr observers = 8;

  Location location = 9;

  // The key definition for the template, if present
  DefKey key = 10; // optional

  // Interface instances defined in this template.
  repeated Implements implements = 13; // *Available in versions >= 1.15*
}

// Interface method definition.
// *Available in versions >= 1.15*
message InterfaceMethod {
  Location location = 1;
  int32 method_interned_name = 2;
  Type type = 3;
}

// Interface definition.
// *Available in versions >= 1.15*
message DefInterface {

  // An interface instance defined in this interface.
  message CoImplements {
    TypeConName template = 1;
    InterfaceInstanceBody body = 2;
  }

  Location location = 1;
  int32 tycon_interned_dname = 2;
  repeated InterfaceMethod methods = 3;

  // Binder for interface value ("this") in precond and fixed choices.
  int32 param_interned_str = 4;

  repeated TemplateChoice choices = 5;

  // Interface instances defined in this interface.
  repeated CoImplements coImplements = 6;

  // View type for this interface
  Type view = 8;

  repeated TypeConName requires = 9;  // *Available in versions >= 1.dev*
}

// Exception definition
// *Available in versions >= 1.14*
message DefException {
  // *Must be a valid interned dotted name*
  int32 name_interned_dname = 1;
  Location location = 2;
  Expr message = 3;
}

// Data type definition
message DefDataType {
  message Fields {
    repeated FieldWithType fields = 1;
  }

  message EnumConstructors {

    // *Must be a list of valid identifiers*
    repeated string constructors_str = 1; // *Available in version < 1.7*

    // *Must be a list of valid interned identifiers*
    repeated int32 constructors_interned_str = 2; // *Available in versions >= 1.7*
  }

  // name of the defined data type
  oneof name {
    DottedName name_dname = 1;

    // *Must be a valid interned name*
    int32 name_interned_dname = 8; // *Available in versions >= 1.7*
  }

  // type parameters
  // *Must be empty if enum field is set*
  repeated TypeVarWithKind params = 2;

  oneof DataCons {
    Fields record = 3; // Records without fields are explicitly allowed.
    Fields variant = 4; // Variants without constructors are explicitly allowed.
    EnumConstructors enum = 7;
    Unit interface = 9; // Interfaces are special, they can't be represented as records or variants.
  }

  // If true, this data type preserves serializability in the sense that when
  // all parameters are instantiated with serializable types (of kind '*'),
  // then the resulting type is serializable as well.
  // This flag is used to simplify package validation by not requiring an
  // inference but only a check. Such a check must validate that this flag is
  // set correctly and that template and choice argument and result types
  // have this flag set to true.
  bool serializable = 5;

  Location location = 6;
}

// Type synonym definition
// *Available in versions >= 1.8*
message DefTypeSyn {

  // name of the defined type synonym
  oneof name {
    DottedName name_dname = 1;

    // *Must be a valid interned name*
    int32 name_interned_dname = 8;
  }

  // type parameters
  repeated TypeVarWithKind params = 2;

  Type type = 3;

  Location location = 4;
}

// Value definition
message DefValue {
  // The reason why we have this type instead of just flattening name
  // and type in DefValue is that it was VarWithType before, and we
  // want to be binary-compatible with it.
  message NameWithType {

    // *Must a non-empty list a valid identifier*
    repeated string name_dname = 1; // *Available in version < 1.7*

    // *Must be a valid interned name*
    int32 name_interned_dname = 3; // *Available in versions >= 1.7*

    // Type of the value
    Type type = 2;
  }

  NameWithType name_with_type = 1;

  Expr expr = 2;

  // Always true for SDK > 1.18. Setting it to false
  // will result in the package being rejected.
  bool no_party_literals = 3;

  bool is_test = 4;

  Location location = 5;
}

message FeatureFlags {
  bool forbidPartyLiterals = 1;
  bool dontDivulgeContractIdsInCreateArguments = 2;
  bool dontDiscloseNonConsumingChoicesToObservers = 3;
}

message Module {

  oneof name {
    DottedName name_dname = 1;
    int32 name_interned_dname = 8; // *Available in versions >= 1.7*
  }
  // repeated Definition definitions = 2; // Removed in favour of data_types, values and templates.
  reserved 2;
  // repeated string scenario_tests = 3; // Removed in favour of DefValue.is_test.
  reserved 3;
  FeatureFlags flags = 4;
  repeated DefTypeSyn synonyms = 9; // *Available in versions >= 1.8*
  repeated DefDataType data_types = 5;
  repeated DefValue values = 6;
  repeated DefTemplate templates = 7;
  repeated DefException exceptions = 10; // *Available in versions >= 1.14*
  repeated DefInterface interfaces = 11; // *Available in versions >= 1.15*
}

message InternedDottedName {
  repeated int32 segments_interned_str = 1; // *Available in versions >= 1.7*
}

message PackageMetadata {
  int32 name_interned_str = 1; // *Available in versions >= 1.8*
  int32 version_interned_str = 2; // *Available in versions >= 1.8*
}

message Package {
  repeated Module modules = 1;
  repeated string interned_strings = 2;
  repeated InternedDottedName interned_dotted_names = 3; // *Available in versions >= 1.7*
  PackageMetadata metadata = 4; // *Available and required in versions >= 1.8*

  // Types in the interning table are only allowed to refer to interned types
  // at smaller indices.
  repeated Type interned_types = 5; // *Available in versions >= 1.11*
}

This is required to get the GHCi/TH linker to pick up static Haskell libs.
Buck uses the same trick. On Windows we retain the original behavior.

Moreover on Windows we add extra system dependencies. The solution is not ideal
but works well; for a proper solution we need better system library support in
rules_haskell: https://github.com/tweag/rules_haskell/issues/834
diff --git a/haskell/haskell.bzl b/haskell/haskell.bzl
index bde7036..0928d09 100644
--- a/haskell/haskell.bzl
+++ b/haskell/haskell.bzl
@@ -241,7 +241,7 @@ haskell_library = rule(
             doc = "A dictionary mapping dependencies to module reexports that should be available for import by dependencies.",
         ),
         linkstatic = attr.bool(
-            default = False,
+            default = True,
             doc = "Create a static library, not both a static and a shared library.",
         ),
         package_name = attr.string(
diff --git a/haskell/private/actions/package.bzl b/haskell/private/actions/package.bzl
index 6671232..6969c05 100644
--- a/haskell/private/actions/package.bzl
+++ b/haskell/private/actions/package.bzl
@@ -99,8 +99,6 @@ def package(
         "import-dirs": " ".join([import_dir, import_dir_prof]),
         "library-dirs": " ".join(["${pkgroot}"] + extra_lib_dirs),
         "dynamic-library-dirs": " ".join(["${pkgroot}"] + extra_lib_dirs),
-        "hs-libraries": pkg_id.library_name(hs, my_pkg_id),
-        "extra-libraries": " ".join(extra_libs),
         "depends": ", ".join(
             # Prebuilt dependencies are added further down, since their
             # package-ids are not available as strings but in build outputs.
@@ -108,6 +106,15 @@ def package(
         ),
     }
 
+    metadata_entries_extras = {
+        "hs-libraries": pkg_id.library_name(hs, my_pkg_id),
+        "extra-libraries": " ".join(extra_libs + ["stdc++", "crypt32", "shlwapi", "ws2_32"]),
+        } if hs.toolchain.is_windows else {
+        "extra-libraries": " ".join([pkg_id.library_name(hs, my_pkg_id)] + extra_libs),
+    }
+
+    metadata_entries.update(metadata_entries_extras)
+
     # Create a file from which ghc-pkg will create the actual package
     # from. List of exposed modules generated below.
     metadata_file = hs.actions.declare_file(target_unique_name(hs, "metadata"))

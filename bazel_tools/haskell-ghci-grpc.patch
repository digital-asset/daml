On MacOS GHCi fails to load grpc fat_cbits statically due to duplicate symbols.
diff --git a/haskell/private/cc_libraries.bzl b/haskell/private/cc_libraries.bzl
index f209d726..61708a66 100644
--- a/haskell/private/cc_libraries.bzl
+++ b/haskell/private/cc_libraries.bzl
@@ -18,6 +18,7 @@ load(
     "is_hs_library",
     "mangle_static_library",
     "rel_to_pkgroot",
+    "symlink_dynamic_library",
     "target_unique_name",
 )
 load(
@@ -196,6 +197,10 @@ def get_extra_libs(hs, posix, cc_libraries_info, cc_info, dynamic = False, pic =
             if static_lib == None:
                 static_lib = lib_to_link.static_library
 
+        if hs.toolchain.is_darwin and fixup_dir == "_ghci_libs" and dynamic_lib and get_lib_name(dynamic_lib) == "grpc":
+            dynamic_libs.append(symlink_dynamic_library(hs, posix, dynamic_lib, fixup_dir))
+            continue
+
         if static_lib and not (dynamic and dynamic_lib):
             static_libs.append(static_lib)
         elif dynamic_lib:
diff --git a/haskell/private/path_utils.bzl b/haskell/private/path_utils.bzl
index 2327c3aa..7def6314 100644
--- a/haskell/private/path_utils.bzl
+++ b/haskell/private/path_utils.bzl
@@ -112,6 +112,44 @@ def join_path_list(hs, paths):
     sep = ";" if hs.toolchain.is_windows else ":"
     return sep.join(paths)
 
+def symlink_dynamic_library(hs, posix, lib, outdir):
+    """Create a symbolic link for a dynamic library and fix the extension.
+
+    This function is used for two reasons:
+
+    1) GHCi expects specific file endings for dynamic libraries depending on
+       the platform: (Linux: .so, macOS: .dylib, Windows: .dll). Bazel does not
+       follow this convention.
+
+    2) macOS applies a strict limit to the MACH-O header size. Many large
+       dynamic loading commands can quickly exceed this limit. To avoid this we
+       place all dynamic libraries into one directory, so that a single RPATH
+       entry is sufficient.
+
+    Args:
+      hs: Haskell context.
+      lib: The dynamic library file.
+      outdir: Output directory for the symbolic link.
+
+    Returns:
+      File, symbolic link to dynamic library.
+    """
+    if hs.toolchain.is_darwin:
+        extension = "dylib"
+    elif hs.toolchain.is_windows:
+        extension = "dll"
+    else:
+        # On Linux we must preserve endings like .so.1.2.3. If those exist then
+        # there will be a matching .so symlink that points to the final
+        # library.
+        extension = get_lib_extension(lib)
+
+    link = hs.actions.declare_file(
+        paths.join(outdir, "lib" + get_lib_name(lib) + "." + extension),
+    )
+    ln(hs, posix, lib, link)
+    return link
+
 def mangle_static_library(hs, posix, dynamic_lib, static_lib, outdir):
     """Mangle a static library to match a dynamic library name.
 

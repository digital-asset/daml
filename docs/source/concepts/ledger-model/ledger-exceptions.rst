.. Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
.. SPDX-License-Identifier: Apache-2.0

.. _da-model-exceptions:

Exceptions
----------

The introduction of exceptions, a new Daml feature, has many implications
for the ledger model. This page describes the changes to the ledger model
introduced as part of this new feature.

..
   SF: Once the dust settles on exceptions, these changes should be
   incorporated into the rest of the ledger model.

Structure
+++++++++

The structure of transactions is modified to include **Rollback** nodes.
Rollback nodes represent a subtransaction that was cancelled and rolled
back due to a raised exception. Rollback nodes are not considered ledger
actions, since they have too many differences from ledger actions. As
such, incorporating rollback nodes into the transaction structure
requires us to redefine transactions. Transactions are now given as
a list of actions or rollback nodes:

.. code-block:: none

   Transaction ::= (Action | Rollback)*
   Rollback ::= 'Rollback' Transaction

Each rollback node contains the subtransaction that was rolled back.

Integrity
+++++++++

The notion of a ledger action coming "after" another ledger action must
be revised in the presence of rollback nodes. It is not enough to traverse
the transaction tree in prefix order, because the actions under a rollback
were rolled back.

For example, a contract may be consumed by an exercise under a rollback node,
and immediately again after the rollback node. This is allowed because the
exercise was rolled back, and this does not represent a "double spend" of
the same contract.

We now define the "after" relation as a partial order on all the actions and
rollback nodes of a transaction. This relation is generated by reflexivity,
transitivity, and the following additional rules:

#. If `act1` and `act2` are two actions that share a parent (e.g. two
   top-level actions, or two actions under the same rollback node, or two
   consequences of the same action), and `act1` precedes `act2` in the list
   of children, then `act2` comes after `act1`.

#. If `node1` is an action, and `node2` is a rollback node, and they both
   share a parent, and `node1` precedes `node2` in the list of children,
   then `node2` comes after `node1`.

#. If `node1` and `node2` are actions or rollback nodes in the transaction
   tree, and `node1` is a parent of `node2`, then `node2` comes after `node1`.

With this modified "after" relation, the notion of consistency remains the
same. Note that under this definition, a rollback node can be "after" its
siblings, but never "before". The only time a rollback node comes "before"
another node, is when that other node is a child or descendant of the
rollback node.

So in the example of a consuming exercise in a rollback node, followed by a
consuming exercise on the same contract outside of the rollback node, neither
exercise comes "after" the other. They are part of separate continuities,
one of which was rolled back, and so they don't break the ledger integrity.

Privacy
+++++++

Rollback nodes also have an interesting effect on the notion of privacy in
the ledger model. When projecting a transaction for a party `p`, it's
necessary to preserve some of the rollback structure of the transaction,
even if `p` does not have the right to observe every action under it. This
is because we need for `p` to be able to verify that an exercise under a
rollback (to which they are is party) is conformant, but we also need `p`
to know that the exercise was rolled back.

As such, the notion of projection for rollback nodes is defined as follows:
When projecting a rollback node for a party `p`, we project the subtransaction
contained in the rollback node, and then we wrap the projected subtransaction
in a new rollback node.

Subsequently, we see whether we can "normalise" the projected rollback node to
prevent leaking information about the structure of the original transaction.
In particular, we apply the following steps:

- If the projected rollback node starts with another rollback node, for instance:

  .. code-block:: none

    'Rollback' [ 'Rollback' tx , node1, ..., nodeN ]

  Then we re-associate the rollback nodes, bringing the inner rollback node out:

  .. code-block:: none

    'Rollback' tx, 'Rollback' [ node1, ..., nodeN ]

  We repeat this step until the projected rollback does not start with another
  rollback node.

- If the projected rollback node ends with another rollback node, for instance:

  .. code-block:: none

    'Rollback' [ node1, ..., nodeN, 'Rollback' [ node1', ..., nodeM' ] ]

  Then we remove the flatten the inner rollback node into its parent:

  .. code-block:: none

    'Rollback' [ node1, ..., nodeN, node1', ..., nodeM' ]

- If the projected rollback node is empty, we drop it.

Note that all of these transformations preserve the "after" relation among
actions in the transaction tree. They only affect the structure of the
transaction by reducing the amount of variation that may occur in a
projected rollback node. This way, information cannot be leaked through
the arrangement of rollback nodes.

The privacy section of the ledger model makes a point of saying that a
ledger model should be **subaction-closed** to support projections. But
this requirement is not necessarily true once we introduce rollbacks.
Rollback nodes may contain actions that are not valid as standalone actions,
since they may have been interrupted prematurely by an exception.

Instead, we require that the ledger model be **projection-closed**, i.e.
closed under projections for any party 'p'. This is a weaker requirement
that matches what we actually the need.

Relation to Daml Exceptions
+++++++++++++++++++++++++++

Rollback nodes are created when an exception is thrown and caught within
the same transaction. In particular, any exception that is caught within
a try-catch will generate a rollback node if there are any ledger actions
to roll back. For example:

.. code-block:: daml

   try do
     cid <- create MyContract { ... }
     exercise cid MyChoice { ... }
     throw MyException
   catch
     MyException ->
       create MyOtherContract { ... }

This Daml code will try to create a contract, and exercise a choice on this
contract, before throwing an exception. That exception is caught immediately,
and then another contract is created.

Thus a rollback node is created, to reset the ledger to the state it had
at the start of the "try" block. The rollback node contains the create and
exercise nodes. After the rollback node, another contract is created.
Thus the final transaction looks like this:

.. code-block:: none

   [
     'Rollback' [ 'Create' cid 'MyContract', 'Exercise' cid 'MyChoice' ],
     'Create' cid2 'MyOtherContract'
   ]

Note that rollback nodes are only created if an exception is *caught*. An
uncaught exception will result in an error, not a transaction.

In addition, empty rollback nodes are not desirable, so if the generated
rollback node would contain an empty transaction, it is dropped.

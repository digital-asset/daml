-- Copyright (c) 2019 The DAML Authors. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module CopyTrigger where

import DA.List
import DA.Next.Map (Map)

import Daml.Trigger

-- ORIGINAL_TEMPLATE_BEGIN
template Original
  with
    owner : Party
    name : Text
    textdata : Text
  where
    signatory owner

    key (owner, name) : (Party, Text)
    maintainer key._1
-- ORIGINAL_TEMPLATE_END

deriving instance Ord Original

-- SUBSCRIBER_TEMPLATE_BEGIN
template Subscriber
  with
    subscriber : Party
    subscribedTo : Party
  where
    signatory subscriber
    observer subscribedTo
    key (subscriber, subscribedTo) : (Party, Party)
    maintainer key._1
-- SUBSCRIBER_TEMPLATE_END

-- COPY_TEMPLATE_BEGIN
template Copy
  with
    original : Original
    subscriber : Party
  where
    signatory (signatory original)
    observer subscriber
-- COPY_TEMPLATE_END

deriving instance Ord Copy

-- TRIGGER_BEGIN
copyTrigger : Trigger ()
copyTrigger = Trigger
  { initialize = \_acs -> ()
  , updateState = \_acs _message () -> ()
  , rule = copyRule
  }
-- TRIGGER_END

-- RULE_SIGNATURE_BEGIN
copyRule : Party -> ACS -> Map CommandId [Command] -> () -> TriggerA ()
copyRule party acs commandsInFlight () = do
-- RULE_SIGNATURE_END
-- ACS_QUERY_BEGIN
  let subscribers : [(AbsoluteContractId Subscriber, Subscriber)] = getTemplates @Subscriber acs
  let originals : [(AbsoluteContractId Original, Original)] = getTemplates @Original acs
  let copies : [(AbsoluteContractId Copy, Copy)] = getTemplates @Copy acs
-- ACS_QUERY_END

-- ACS_FILTER_BEGIN
  let ownedSubscribers = filter (\(_, s) -> s.subscribedTo == party) subscribers
  let ownedOriginals = filter (\(_, o) -> o.owner == party) originals
  let ownedCopies = filter (\(_, c) -> c.original.owner == party) copies
-- ACS_FILTER_END

-- SUBSCRIBING_PARTIES_BEGIN
  let subscribingParties = map (\(_, s) -> s.subscriber) ownedSubscribers
-- SUBSCRIBING_PARTIES_END

-- GROUP_COPIES_BEGIN
  let groupedCopies : [[(AbsoluteContractId Copy, Copy)]]
      groupedCopies = groupOn snd $ sortOn snd $ ownedCopies
  let copiesToKeep = map head groupedCopies
  let archiveDuplicateCopies = concatMap tail groupedCopies
-- GROUP_COPIES_END

-- ARCHIVE_COPIES_BEGIN
  let archiveMissingOriginal = filter (\(_, c) -> c.original `notElem` map snd ownedOriginals) copiesToKeep
  let archiveMissingSubscriber = filter (\(_, c) -> c.subscriber `notElem` subscribingParties) copiesToKeep
  let archiveCopies = dedup $ map fst $ archiveDuplicateCopies <> archiveMissingOriginal <> archiveMissingSubscriber
-- ARCHIVE_COPIES_END

-- ARCHIVE_COMMAND_BEGIN
  forA archiveCopies $ \cid -> emitCommands [exerciseCmd @Copy cid Archive]
-- ARCHIVE_COMMAND_END

-- CREATE_COPIES_BEGIN
  let neededCopies = [Copy m o | (_, m) <- ownedOriginals, o <- subscribingParties]
  let createCopies = filter (\c -> c `notElem` map snd copiesToKeep) neededCopies
  mapA dedupCreate createCopies
-- CREATE_COPIES_END
  pure ()

-- Copyright (c) 2019 The DAML Authors. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module CopyTrigger where

import DA.List
import DA.Next.Map (Map)
import qualified DA.Next.Map as Map
import DA.Optional

import Daml.Trigger

-- ORIGINAL_TEMPLATE_BEGIN
template Original
  with
    owner : Party
    name : Text
    textdata : Text
  where
    signatory owner

    key (owner, name) : (Party, Text)
    maintainer key._1
-- ORIGINAL_TEMPLATE_END

deriving instance Ord Original

-- SUBSCRIBER_TEMPLATE_BEGIN
template Subscriber
  with
    subscriber : Party
    subscribedTo : Party
  where
    signatory subscriber
    observer subscribedTo
    key (subscriber, subscribedTo) : (Party, Party)
    maintainer key._1
-- SUBSCRIBER_TEMPLATE_END

-- COPY_TEMPLATE_BEGIN
template Copy
  with
    original : Original
    subscriber : Party
  where
    signatory (signatory original)
    observer subscriber
-- COPY_TEMPLATE_END

deriving instance Ord Copy

-- TRIGGER_BEGIN
copyTrigger = runTrigger $ Trigger
  { initialize = \_acs -> ()
  , updateState = \_acs _message () -> ()
  , rule = copyRule
  }
-- TRIGGER_END

-- RULE_SIGNATURE_BEGIN
copyRule : Party -> ACS -> Map CommandId [Command] -> () -> TriggerA ()
copyRule party acs commandsInFlight () = do
-- RULE_SIGNATURE_END
-- ACS_QUERY_BEGIN
  let subscribers : [(AnyContractId, Subscriber)] = getTemplates @Subscriber acs
  let originals : [(AnyContractId, Original)] = getTemplates @Original acs
  let copies : [(AnyContractId, Copy)] = getTemplates @Copy acs
-- ACS_QUERY_END

-- ACS_FILTER_BEGIN
  let ownedSubscribers = filter (\(_, s) -> s.owner == party) subscribers
  let ownedOriginals = filter (\(_, o) -> o.owner == party) originals
  let ownedCopies = filter (\(_, c) -> c.original.owner == party) copies
-- ACS_FILTER_END

-- SUBSCRIBING_PARTIES_BEGIN
  let subscribingParties = map (\(_, s) -> s.subscriber) ownedSubscribers
-- SUBSCRIBING_PARTIES_END

-- GROUP_COPIES_BEGIN
  let groupedCopies : [[(AnyContractId, Copy)]]
  let groupedCopies = groupOn snd $ sortOn snd $ ownedCopies
  let copiesToKeep = map head groupedCopies
  let archiveDuplicateCopies = concatMap tail groupedCopies
-- GROUP_COPIES_END

-- ARCHIVE_COPIES_BEGIN
  let archiveMissingOriginal = filter (\(_, c) -> c.original `notElem` map snd ownedOriginals) uniqueCopies
  let archiveMissingSubscriber = filter (\(_, c) -> c.subscriber `notElem` subscribingParties) uniqueCopies
  let archiveCopies = dedup $ map fst $ archiveDuplicateCopies <> archiveMissingOriginal <> archiveMissingSubscriber
-- ARCHIVE_COPIES_END

-- ARCHIVE_COMMAND_BEGIN
  forA archiveCopies $ \cid -> emitCommands [exerciseCmd @Copy cid Archive]
-- ARCHIVE_COMMAND_END

-- CREATE_COPIES_BEGIN
  let pendingCopies = concatMap (mapOptional toCreateCopy . snd) $ Map.toList commandsInFlight
  let eventualCopies = pendingCopies <> map snd copiesToKeep
  let neededCopies = [Copy m o | (_, m) <- ownedOriginals, o <- subscribingParties]
  let createCopies = filter (\c -> c `notElem` eventualCopies) neededCopies
  forA createCopies $ \copy -> emitCommands [createCmd copy]
-- CREATE_COPIES_END
  pure ()

-- TO_CREATE_COPY_BEGIN
toCreateCopy : Command -> Optional Copy
toCreateCopy (CreateCommand tpl) = fromAnyTemplate tpl
toCreateCopy (ExerciseCommand _ _) = None
-- TO_CREATE_COPY_END

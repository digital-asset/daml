.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
.. SPDX-License-Identifier: Apache-2.0

Creating your own bindings
##########################

This page gets you started with creating custom bindings for the Digital Asset distributed ledger.

Introduction
============

Digital Asset currently provides bindings for the following programming languages:

- :doc:`Java </app-dev/bindings-java/index>`

- :doc:`Scala </app-dev/bindings-scala/index>`

- :doc:`JavaScript (Node.js) </app-dev/bindings-js>`

However, you can create bindings for any programming language supported by `gRPC <https://grpc.io/docs/>`_.

What do we mean by "bindings"? Bindings for a language consist of two main components:

- Ledger API
    Client "stubs" for the programming language, -- the remote API that allows sending ledger commands and receiving ledger transactions. You have to generate **Ledger API** from `the gRPC protobuf definitions in the daml repository on GitHub <https://github.com/digital-asset/daml/tree/master/ledger-api/grpc-definitions>`_. **Ledger API** is documented on this page: :doc:`/app-dev/grpc/index`. The `gRPC <https://grpc.io/docs/>`_ tutorial explains how to generate client "stubs".

- Codegen
     A code generator is a program that generates classes representing DAML contract templates in the language. These classes incorporate all boilerplate code for constructing: :ref:`com.digitalasset.ledger.api.v1.CreateCommand` and :ref:`com.digitalasset.ledger.api.v1.ExerciseCommand` corresponding for each DAML contract template.

Technically codegen is optional. You can construct the commands manually from the auto-generated **Ledger API** classes. However it is very tedious and error-prone. If you are creating ah hoc bindings for a project with a few contract templates, writing a proper codegen may be an overkill. On the other hand if you have hundreds of contract templates in your project or planning to build language bindings that you will share across multiple projects, we recommend including codegen in your bindings. It will save you time in the long run.

Building Create Command
=======================

Let's recall an **IOU** example from the :doc:`Quickstart guide </getting-started/quickstart>`, where `Iou` template is defined like this:

.. literalinclude:: ./code-snippets/quickstart/template-root/daml/Iou.daml
  :language: daml
  :lines: 9-15

Here is how to manually build a :ref:`com.digitalasset.ledger.api.v1.CreateCommand` for the above contract template in Scala:

.. literalinclude:: ./code-snippets/iou-no-codegen/application/src/main/scala/com/digitalasset/quickstart/iou/IouCommands.scala
   :start-after: // <doc-ref:iou-no-codegen-create-command>
   :end-before: // </doc-ref:iou-no-codegen-create-command>

If you do not specify any of the above fields or type their names or values incorrectly, or do not order them exactly as they are in the DAML template, the above code will compile but fail at run-time because you did not structure your create command correctly.

Codegen should simplify the command construction by providing auto-generated utilities to help you construct commands. For example, when you use :doc:`Scala codegen </app-dev/bindings-scala/index>` to generate contract classes, a similar contract instantiation would look like this:


.. literalinclude:: ./code-snippets/quickstart-scala/application/src/main/scala/com/digitalasset/quickstart/iou/IouMain.scala
   :start-after: // <doc-ref:iou-contract-instance>
   :end-before: // </doc-ref:iou-contract-instance>

Building Exercise Command
=========================

To build :ref:`com.digitalasset.ledger.api.v1.ExerciseCommand` for `Iou_Transfer`:

.. literalinclude:: ./code-snippets/quickstart/template-root/daml/Iou.daml
  :language: daml
  :lines: 23, 52-55

manually in Scala:

.. literalinclude:: ./code-snippets/iou-no-codegen/application/src/main/scala/com/digitalasset/quickstart/iou/IouCommands.scala
   :start-after: // <doc-ref:iou-no-codegen-exercise-command>
   :end-before: // </doc-ref:iou-no-codegen-exercise-command>

versus creating the same command using a value class generated by :doc:`Scala codegen </app-dev/bindings-scala/index>`:

.. literalinclude:: ./code-snippets/quickstart-scala/application/src/main/scala/com/digitalasset/quickstart/iou/IouMain.scala
   :start-after: // <doc-ref:iou-exercise-transfer-cmd>
   :end-before: // </doc-ref:iou-exercise-transfer-cmd>

Summary
=======

When creating custom bindings for the Digital Asset distributed ledger, you will need to:

- generate **Ledger API** from the gRPC definitions

- decide whether to write a codegen to generate contract classes or manually build commands for all contracts defined in your DAML model.

The above examples should help you get started. If you have any questions, see the :doc:`/support/support` page for how to get in touch with us. You can also open a `GitHub issue <https://github.com/digital-asset/daml/issues>`_ if any of the instructions did not work.

Links
=====

- A Scala example that demonstrates how to manually construct ledger commands: https://github.com/digital-asset/daml/tree/master/language-support/scala/examples/iou-no-codegen

- A Scala codegen example: https://github.com/digital-asset/daml/tree/master/language-support/scala/examples/quickstart-scala

- gRPC documentation: https://grpc.io/docs/

- Digital Asset Ledger API gRPC protobuf definitions: https://github.com/digital-asset/daml/tree/master/ledger-api/grpc-definitions

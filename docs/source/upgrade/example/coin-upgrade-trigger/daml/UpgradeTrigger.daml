-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module UpgradeTrigger where

import DA.Assert
import DA.Foldable
import qualified DA.Next.Map as Map
import Daml.Trigger
import Daml.Trigger.Assert
import qualified Daml.Script as Script
import Daml.Script (script)

import CoinV1
import UpgradeFromCoinV1

-- TRIGGER_BOILERPLATE_BEGIN
upgradeTrigger : Trigger ()
upgradeTrigger = Trigger with
  initialize = pure ()
  updateState = \_msg -> pure ()
  registeredTemplates = AllInDar
  heartbeat = None
  rule = triggerRule
-- TRIGGER_BOILERPLATE_END

-- TRIGGER_RULE_BEGIN
triggerRule : Party -> TriggerA () ()
triggerRule issuer = do
  agreements <-
    filter (\(_cid, agreement) -> agreement.issuer == issuer) <$>
    query @UpgradeCoinAgreement
  allCoins <-
    filter (\(_cid, coin) -> coin.issuer == issuer) <$>
    query @Coin
  forA_ agreements $ \(agreementCid, agreement) -> do
    let coinsForOwner = filter (\(_cid, coin) -> coin.owner == agreement.owner) allCoins
    forA_ coinsForOwner $ \(coinCid, _) ->
      emitCommands
        [exerciseCmd agreementCid (Upgrade coinCid)]
        [toAnyContractId coinCid]
-- TRIGGER_RULE_END

-- TODO (MK) The Bazel rule atm doesnâ€™t run this script, we should fix that.
test = script do
  alice <- Script.allocateParty "Alice"
  bob <- Script.allocateParty "Bob"

  coinProposal <- submit alice $ Script.createCmd (CoinProposal alice bob)
  coin <- submit bob $ Script.exerciseCmd coinProposal CoinProposal_Accept

  upgradeProposal <- submit alice $ Script.createCmd (UpgradeCoinProposal alice bob)
  upgradeAgreement <- submit bob $ Script.exerciseCmd upgradeProposal Accept

  let acs = toACS coin <> toACS upgradeAgreement

  (_, commands) <- testRule upgradeTrigger alice acs Map.empty ()
  let flatCommands = flattenCommands commands
  assertExerciseCmd flatCommands $ \(cid, choiceArg) -> do
    cid === upgradeAgreement
    choiceArg === Upgrade coin
  -- TODO (MK) It would be nice to test for the absence of certain commands as well
  -- or ideally just assert that the list of emitted commands matches an expected
  -- list of commands.

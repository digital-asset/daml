// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.daml.lf.engine.trigger.dao

import java.util.UUID

import cats.effect.{ContextShift, IO}
import cats.syntax.apply._
import cats.syntax.functor._
import com.daml.lf.engine.trigger.{EncryptedToken, JdbcConfig, RunningTrigger, UserCredentials}
import doobie.free.connection.ConnectionIO
import doobie.implicits._
import doobie.postgres.implicits._
import doobie.util.log
import doobie.{LogHandler, Transactor, _}

import scala.concurrent.ExecutionContext
import scala.util.{Failure, Success, Try}

object Connection {

  type T = Transactor.Aux[IO, Unit]

  def connect(jdbcDriver: String, jdbcUrl: String, username: String, password: String)(
      implicit cs: ContextShift[IO]): T =
    Transactor
      .fromDriverManager[IO](jdbcDriver, jdbcUrl, username, password)(IO.ioConcurrentEffect(cs), cs)
}

class DbTriggerDao(xa: Connection.T) extends RunningTriggerDao {

  private val logHandler: log.LogHandler = doobie.util.log.LogHandler.jdkLogHandler

  private def createTables(implicit logHandler: LogHandler): ConnectionIO[Unit] = {
    // Running trigger table.
    // `trigger_instance` is a UUID generated by the service
    // `party_token` is the token corresponding to the party
    // `full_trigger_name` is the identifier for the trigger in its dalf,
    //  of the form "packageId:moduleName:triggerName"
    val createTriggerTable: Fragment = sql"""
        create table running_triggers(
          trigger_instance uuid primary key,
          party_token text not null,
          full_trigger_name text not null
        )
      """

    // Dalf table with binary package data.
    val createDalfTable: Fragment = sql"""
        create table dalfs(
          package_id text primary key,
          package bytea not null
        )
      """

    // Index for efficiently listing running triggers for a particular party.
    val createPartyIndex: Fragment = sql"""
        create index triggers_by_party on running_triggers(party_token)
      """

    (createTriggerTable.update.run
      *> createDalfTable.update.run
      *> createPartyIndex.update.run).void
  }

  private def insertRunningTrigger(t: RunningTrigger): ConnectionIO[Unit] = {
    val partyToken: String = t.credentials match {
      case UserCredentials(EncryptedToken(token)) => token
    }
    val fullTriggerName = t.triggerName.toString
    val insert: Fragment = Fragment.const(
      s"insert into running_triggers values ('${t.triggerInstance}', '$partyToken', '$fullTriggerName')"
    )
    insert.update.run.void
  }

  // trigger_instance is the primary key on running_triggers so this deletes
  // at most one row. Return whether or not it deleted.
  private def deleteRunningTrigger(triggerInstance: UUID): ConnectionIO[Boolean] = {
    val delete = sql"delete from running_triggers where trigger_instance = $triggerInstance"
    // NOTE(RJR): We do *not* quote the `$triggerInstance` above. The `sql`
    // string interpolation adds it for UUIDs, unlike the `s` interpolation used
    // in `Fragment.const`.
    delete.update.run.map(_ == 1)
  }

  private def selectRunningTriggers(credentials: UserCredentials): ConnectionIO[Vector[UUID]] = {
    val partyToken: String = credentials match {
      case UserCredentials(EncryptedToken(token)) => token
    }
    val select = Fragment.const("select trigger_instance from running_triggers")
    val where = Fragment.const(s" where party_token = '${partyToken}'")
    val order = Fragment.const(" order by running_triggers")
    val list = select ++ where ++ order
    list.query[UUID].to[Vector]
  }

  // Drop all tables and other objects associated with the database.
  // Only used between tests for now.
  private def dropTables: ConnectionIO[Unit] = {
    val dropTriggerTable: Fragment = sql"drop table running_triggers"
    val dropDalfTable: Fragment = sql"drop table dalfs"
    (dropTriggerTable.update.run
      *> dropDalfTable.update.run).void
  }

  private def run[T](query: ConnectionIO[T], errorContext: String = ""): Either[String, T] = {
    Try(query.transact(xa).unsafeRunSync) match {
      case Failure(err) => Left(errorContext ++ "\n" ++ err.toString)
      case Success(res) => Right(res)
    }
  }

  override def addRunningTrigger(t: RunningTrigger): Either[String, Unit] =
    run(insertRunningTrigger(t))

  override def removeRunningTrigger(triggerInstance: UUID): Either[String, Boolean] =
    run(deleteRunningTrigger(triggerInstance))

  override def listRunningTriggers(credentials: UserCredentials): Either[String, Vector[UUID]] = {
    // Note(RJR): Postgres' ordering of UUIDs is different to Scala/Java's.
    // We sort them after the query to be consistent with the ordering when not using a database.
    run(selectRunningTriggers(credentials)).map(_.sorted)
  }

  def initialize: Either[String, Unit] =
    run(createTables(logHandler), "Failed to initialize database.")

  def destroy: Either[String, Unit] =
    run(dropTables, "Failed to remove database objects.")
}

object DbTriggerDao {

  def apply(c: JdbcConfig)(implicit ec: ExecutionContext): DbTriggerDao = {
    val cs: ContextShift[IO] = IO.contextShift(ec)
    val conn: Connection.T = Connection.connect(JdbcConfig.driver, c.url, c.user, c.password)(cs)
    new DbTriggerDao(conn)
  }
}

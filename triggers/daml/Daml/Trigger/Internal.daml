-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Trigger.Internal
  ( ACS (..)
  , TriggerA (..)
  , addCommands
  , insertTpl
  , groupActiveContracts
  , deleteTpl
  , lookupTpl
  , applyEvent
  , applyTransaction
  , runRule
  , runTriggerA
  , TriggerAState (..)
  , TriggerState (..)
  ) where

import DA.Action.State
import DA.Map (Map)
import qualified DA.Map as Map
import qualified DA.Next.Map as NMap
import DA.Optional (fromOptional)

import Daml.Trigger.LowLevel hiding (Trigger)

-- public API

-- | Active contract set, you can use `getContracts` to access the templates of
-- a given type.

-- This will change to a Map once we have proper maps in DAML-LF
data ACS = ACS
  { activeContracts : Map TemplateTypeRep [(AnyContractId, AnyTemplate)]
  , pendingContracts : NMap.Map CommandId [AnyContractId]
  }

-- | TriggerA is the type used in the `rule` of a DAML trigger.
-- Its main feature is that you can call `emitCommands` to
-- send commands to the ledger.
newtype TriggerA a = TriggerA (State TriggerAState a)
  deriving (Functor, Applicative, Action)

-- Internal API

addCommands : NMap.Map CommandId [Command] -> Commands -> NMap.Map CommandId [Command]
addCommands m (Commands cid cmds) = NMap.insert cid cmds m

adjust : forall k v. Ord k => k -> (Optional v -> Optional v) -> Map k v -> Map k v
adjust k f m =
  let orig = Map.lookup k m
  in case (orig, f orig) of
       (None, None) -> m
       (_, Some v) -> Map.insert k v m
       (Some _, None) -> Map.delete k m

insertTpl : AnyContractId -> AnyTemplate -> ACS -> ACS
insertTpl cid tpl acs = acs { activeContracts = adjust cid.templateId addct acs.activeContracts }
  where addct ol = Some $ (cid, tpl) :: fromOptional [] ol

groupActiveContracts : [(AnyContractId, AnyTemplate)] -> Map TemplateTypeRep [(AnyContractId, AnyTemplate)]
groupActiveContracts = foldr (\v@(cid, _) -> adjust cid.templateId (addct v)) Map.empty
  where addct v ol = Some $ v :: fromOptional [] ol

deleteTpl : AnyContractId -> ACS -> ACS
deleteTpl cid acs = acs { activeContracts = adjust cid.templateId rmct acs.activeContracts }
  where rmct ol = do
          l <- ol
          case filter (\(cid', _) -> cid /= cid') l of
            [] -> None
            nel -> Some nel

lookupTpl : Template a => AnyContractId -> ACS -> Optional a
lookupTpl cid acs = do
  tacs <- Map.lookup cid.templateId acs.activeContracts
  (_, tpl) <- find ((cid ==) . fst) tacs
  fromAnyTemplate tpl

applyEvent : Event -> ACS -> ACS
applyEvent ev acs = case ev of
  CreatedEvent (Created _ cid tpl) -> insertTpl cid tpl acs
  ArchivedEvent (Archived _ cid) -> deleteTpl cid acs

applyTransaction : Transaction -> ACS -> ACS
applyTransaction (Transaction _ _ evs) acs = foldl (flip applyEvent) acs evs

runRule
  : (Party -> ACS -> Time -> NMap.Map CommandId [Command] -> s -> TriggerA ())
  -> Time
  -> TriggerState s
  -> (TriggerState s, [Commands])
runRule rule time state =
  let (_, aState) =
        runTriggerA
          (rule state.party state.acs time state.commandsInFlight state.userState)
          (TriggerAState state.commandsInFlight [] state.acs.pendingContracts state.nextCommandId)
      commandsInFlight = foldl addCommands state.commandsInFlight aState.emittedCommands
      acs = state.acs { pendingContracts = aState.pendingContracts }
  in (state { nextCommandId = aState.nextCommandId, commandsInFlight, acs }, aState.emittedCommands)

runTriggerA : TriggerA a -> TriggerAState -> (a, TriggerAState)
runTriggerA (TriggerA f) s =
  let (a, s') = runState f s
  in (a, s' { emittedCommands = reverse s'.emittedCommands })

data TriggerAState = TriggerAState
  { commandsInFlight : NMap.Map CommandId [Command]
  -- This is not modified during a run (new commands end up in emittedCommands)
  -- but for simplicity we keep it in TriggerAState instead of layering a
  -- Reader on top of it.
  -- This will be used for dedupCreateCmd/dedupExerciseCmd helpers.
  , emittedCommands : [Commands]
  -- ^ Emitted commands in reverse because I canâ€™t be bothered to implement a dlist.
  , pendingContracts : NMap.Map CommandId [AnyContractId]
  -- ^ Map from command ids to the contract ids marked pending by that command.
  , nextCommandId : Int
  -- ^ Command id used for the next submit
  }

data TriggerState s = TriggerState
  { acs : ACS
  , party : Party
  , userState : s
  , commandsInFlight : NMap.Map CommandId [Command]
  , nextCommandId : Int
  }

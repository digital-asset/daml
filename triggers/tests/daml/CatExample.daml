-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module CatExample where

import Daml.Trigger
import DA.Foldable (forA_)
import DA.Time (seconds)
import qualified DA.Map as Map
import DA.Functor (void)


template Cat
  with
    owner : Party
    isin : Int
  where
    signatory owner
    key this : Cat
    maintainer key.owner

    choice Feed : ()
      with
       foodCid : ContractId Food
      controller owner
      do
        exercise foodCid Food_FeedCat

template Food
  with
    owner : Party
    isin : Int
  where
    signatory owner
    key this : Food
    maintainer key.owner

    choice Food_FeedCat : ()
      controller owner
      do
        pure ()

boundedTrigger : Trigger Int
boundedTrigger = Trigger
  { initialize = pure 0
  , updateState = \_ -> modify (+ 1)
  , rule = boundedFeedTheCats
  , registeredTemplates =  RegisteredTemplates [ registeredTemplate @Cat, registeredTemplate @Food ]
  , heartbeat = Some (seconds 1)
  }

unboundedTrigger : Trigger Int
unboundedTrigger = Trigger
  { initialize = pure 0
  , updateState = \_ -> modify (+ 1)
  , rule = unboundedFeedTheCats
  , registeredTemplates =  RegisteredTemplates [ registeredTemplate @Cat, registeredTemplate @Food ]
  , heartbeat = Some (seconds 1)
  }

limit = 100

tooManyCommandsInFlight : TriggerA s Bool
tooManyCommandsInFlight = do
  cs <- getCommandsInFlight
  pure $ Map.size cs >=limit

--emitCommands' cmds pending =
--  tooManyCommandsInFlight >>= \case
--    False -> void $ emitCommands cmds pending
--    True ->  pure ()

for_ : [a] -> (a -> TriggerA c b) -> TriggerA c ()
for_ (h :: t) f =
  tooManyCommandsInFlight >>= \case
    False -> do
      f h
      for_ t f
    True ->
      pure ()
for_ _ _ = pure ()

boundedFeedTheCats: Party -> TriggerA Int ()
boundedFeedTheCats _ = do
  cats <- query @Cat
  step <- get
  debugRaw $ "Step " <> show step <> ": feeding " <> show (length cats) <> " cats"
  for_ cats \(catCid, Cat{..}) -> do
    tooManyCommandsInFlight >>= \case
       True ->
         debugRaw $ "Step " <> show step <> ": too many commands in flight, skip isin " <> (show isin)
       False -> do
         queryContractKey @Food (Food owner isin) >>= \case
           Some (foodCid, _) -> do
             debugRaw $ "Step " <> show step <> ": found food for cat with isin " <> (show isin)
             void $ emitCommands [exerciseCmd catCid (Feed foodCid)] [toAnyContractId catCid, toAnyContractId foodCid]
           None -> do
             debugRaw $ "Step " <> show step <> ": not found food for cat with isin " <> (show isin)

unboundedFeedTheCats: Party -> TriggerA Int ()
unboundedFeedTheCats _ = do
  cats <- query @Cat
  step <- get
  if step == 0 then
    pure ()
  else do
    debugRaw $ "Step " <> show step <> ": feeding " <> show (length cats) <> " cats"
    forA_ cats \(catCid, Cat{..}) -> do
      queryContractKey @Food (Food owner isin) >>= \case
        Some (foodCid, _) -> do
          debugRaw $ "Step " <> show step <> ": found food for cat with isin " <> (show isin)
          void $ emitCommands [exerciseCmd catCid (Feed foodCid)] [toAnyContractId catCid, toAnyContractId foodCid]
        None ->
          debugRaw $ "Step " <> show step <> ": not found food for cat with isin " <> (show isin)

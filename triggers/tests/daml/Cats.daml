-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- This Daml code is based on the sample code supplied in issue https://github.com/digital-asset/daml/issues/15756
module Cats where

import Daml.Trigger
import DA.Foldable (forA_)
import DA.Time (seconds)
import DA.Functor (void)


template Cat
  with
    owner : Party
    isin : Int
  where
    signatory owner
    key this : Cat
    maintainer key.owner

    choice Feed : ()
      with
       foodCid : ContractId Food
      controller owner
      do
        exercise foodCid Food_FeedCat

template Food
  with
    owner : Party
    isin : Int
  where
    signatory owner
    key this : Food
    maintainer key.owner

    choice Food_FeedCat : ()
      controller owner
      do
        pure ()

template TestComplete
  with
    owner : Party
  where
    signatory owner

feedingTrigger : Trigger Int
feedingTrigger = Trigger
  { initialize = pure 500
  , updateState = \msg -> case msg of
      MTransaction (Transaction _ _ [ArchivedEvent (fromArchived @Cat -> Some (_, catId)), ArchivedEvent (fromArchived @Food -> Some (_, foodId))]) -> do
        modify (subtract 1)
      _ -> pure ()
  , rule = feedTheCats
  , registeredTemplates = RegisteredTemplates [ registeredTemplate @TestComplete, registeredTemplate @Cat, registeredTemplate @Food ]
  , heartbeat = Some (seconds 1)
  }

feedTheCats: Party -> TriggerA Int ()
feedTheCats party = do
  cats <- query @Cat
  pendingCount <- get
  if pendingCount == 0 then
    void $ emitCommands [createCmd (TestComplete party)] []
  else do
    forA_ cats \(catCid, Cat{..}) -> do
      queryContractKey @Food (Food owner isin) >>= \case
        Some (foodCid, _) -> do
          void $ emitCommands [exerciseCmd catCid (Feed foodCid)] [toAnyContractId catCid, toAnyContractId foodCid]
        None ->
          pure ()

breedingTrigger: Trigger (Int, Int)
breedingTrigger = Trigger
  { initialize = pure (1, 0)
  , updateState = \msg -> case msg of
      MCompletion completion
        | applyBackPressure <- completion.status -> do
          -- apply back pressure signal detected
          (_, baseIndex) <- get
          put (0, baseIndex)
        | cancelBackPressure <- completion.status -> do
          -- release back pressure signal detected
          (_, baseIndex) <- get
          put (-1, baseIndex)
      _ -> do
        -- allow exponential cat breeding!
        (breedCount, baseIndex) <- get
        put (2 * breedCount, baseIndex + breedCount + 1)
  , rule = breedTheCats
  , registeredTemplates = RegisteredTemplates [ registeredTemplate @TestComplete, registeredTemplate @Cat ]
  , heartbeat = Some (seconds 1)
  }

breedTheCats: Party -> TriggerA (Int, Int) ()
breedTheCats party = do
  (breedCount, baseIndex) <- get
  if breedCount < 0 then
    -- release back pressure signal detected, so complete this test
    void $ emitCommands [createCmd (TestComplete party)] []
  else if breedCount == 0 then
    -- apply back pressure signal detected, so stop cat breeding
    pure ()
  else do
    -- breed some cats
    forA_ [1..breedCount] \offset -> do
      void $ emitCommands [createCmd (Cat party (baseIndex + offset))] []

crashingTrigger: Trigger (Int, Int)
crashingTrigger = Trigger
  { initialize = pure (1, 0)
  , updateState = \_ -> do
      -- allow (unconstrained) exponential cat breeding!
      (breedCount, baseIndex) <- get
      put (2 * breedCount, baseIndex + breedCount + 1)
  , rule = uncontrolledBreeding
  , registeredTemplates = RegisteredTemplates [ registeredTemplate @TestComplete, registeredTemplate @Cat ]
  , heartbeat = Some (seconds 1)
  }

uncontrolledBreeding: Party -> TriggerA (Int, Int) ()
uncontrolledBreeding party = do
  (breedCount, baseIndex) <- get
  -- breed some cats
  forA_ [1..breedCount] \offset -> do
    void $ emitCommands [createCmd (Cat party (baseIndex + offset))] []

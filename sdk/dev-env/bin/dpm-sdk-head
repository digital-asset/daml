#!/usr/bin/env bash
set -euo pipefail

# Make sure they are in the right repo
readonly REPO_ROOT="$(bazel info workspace)"
if [[ "${REPO_ROOT}/dev-env/bin/dpm-sdk-head" != "${BASH_SOURCE[0]}" ]]; then
  echo "Repo root does not match the script being run."
  echo "Make sure you run this script from a directory within the 'daml' repository "
  exit 1
fi

BAZEL_MODE_FLAGS=()

COMPONENT_VERSION=0.0.0
RELEASE_VERSION=0.0.0
TO_BUILD=()
TO_SKIP=()
NUKE=0
PROFILING=0
REMOVE_OTHER_VERSIONS=0
VERBOSE=0
# 0 = no message, 1 = add path instructions, 2 = reload shell
LOG_PATH_INSTRUCTIONS=0
for opt in "$@"; do
  case "$opt" in
    --canton-community)
      TO_BUILD+=(canton-community)
      ;;
    --damlc)
      TO_BUILD+=(damlc)
      ;;
    --daml-script)
      TO_BUILD+=(daml-script)
      ;;
    --codegen)
      TO_BUILD+=(codegen)
      ;;
    --daml-new)
      TO_BUILD+=(daml-new)
      ;;
    --upgrade-check)
      TO_BUILD+=(upgrade-check)
      ;;
    --dpm)
      TO_BUILD+=(dpm)
      ;;
    --jars)
      TO_BUILD+=(jars)
      ;;
    --skip-*)
      TO_SKIP+=${opt#--skip-}
      ;;
    --version=*)
      RELEASE_VERSION=${opt#--version=}
      COMPONENT_VERSION=${opt#--version=}
      ;;
    --release-version=*)
      RELEASE_VERSION=${opt#--release-version=}
      ;;
    --component-version=*)
      COMPONENT_VERSION=${opt#--component-version=}
      ;;
    --profiling)
      PROFILING=1
      ;;
    --nuke)
      NUKE=1
      ;;
    --remove-other-versions)
      REMOVE_OTHER_VERSIONS=1
      ;;
    --verbose)
      ;&
    -v)
      VERBOSE=1
      ;;
    *)
      echo "Unknown option: $opt"
      echo "Available options:"
      echo "  --canton-community Build and update the canton-community component"
      echo "  --damlc Build and update the damlc component"
      echo "  --daml-script Build and update the daml-script component"
      echo "  --codegen Build and update the codegen component"
      echo "  --daml-new Build and update the daml-new component"
      echo "  --upgrade-check Build and update the upgrade-check component"
      echo "  --dpm Fetch and update the dpm component"
      echo "  --version=<version> Set the component and release version to be built, default 0.0.0"
      echo "  --component-version=<version> Set the component version (internal to dpm) to be built, default 0.0.0"
      echo "  --release-version=<version> Set the release version (sdk-version in daml.yaml) to contain built components, default 0.0.0"
      echo "  --profiling Build Haskell executables with profiling enabled"
      echo "  --nuke Remove DPM from your system entirely before building"
      echo "  --skip-* Skip building and installing a component, such as `--skip-jars`"
      echo "  --remove-other-versions After installing head, remove all other installed versions (assemblies only, components remain, this will not save disk space)"
      echo "  --verbose Print bazel build logs as they build live"

      exit 1
  esac
done

if [[ "$PROFILING" -ne 0 ]]; then
  BAZEL_MODE_FLAGS+=(-c dbg)
fi

readonly DPM_HOME="$HOME/.dpm"

if [[ "$NUKE" -ne 0 ]]; then
  rm -rf "$DPM_HOME"
  echo "$(tput setaf 3)Removed DPM from system.$(tput sgr 0)"
fi

get_dpm() {
  bazel build @dpm_binary//:dpm
  dpm_bazel_path=$(bazel cquery "${BAZEL_MODE_FLAGS[@]}" "@dpm_binary//:dpm" --output=files 2> /dev/null)
  dpm_version=$(HOME=. $dpm_bazel_path -v 2> /dev/null | head -n 1 | sed -e "s/^version: //")
  mkdir -p "$DPM_HOME/cache/components/dpm/${dpm_version}" "$DPM_HOME/bin" "$DPM_HOME/cache/sdk/open-source"
  cp $dpm_bazel_path "$DPM_HOME/cache/components/dpm/${dpm_version}/dpm"
  # Create symlink for .dpm/bin, to match DPM's current behaviour
  ln -sf "${DPM_HOME}/cache/components/dpm/${dpm_version}/dpm" "${DPM_HOME}/bin/dpm"
  echo $dpm_version
}

if [ ! -d "$DPM_HOME" ]; then
  echo "$(tput setaf 5)DPM is not installed, installing from bazel...$(tput sgr 0)"

  get_dpm

  cat > "${DPM_HOME}/dpm-config.yaml" << EOF
edition: open-source
registry: europe-docker.pkg.dev/da-images/public-unstable
EOF
  CONF_FILE=
  case $SHELL in
    *zsh)
      CONF_FILE=".zshrc"
      ;;
    *bash)
      CONF_FILE=".bashrc"
      ;;
    *sh)
      CONF_FILE=".profile"
      ;;
  esac
  # No conf file -> give user path instructions at end
  if [ -z "$CONF_FILE" ]; then
    LOG_PATH_INSTRUCTIONS=1
  else
    if [ -f "$HOME/$CONF_FILE" ]; then
      # Check conf already has .dpm-bin
      if grep -zqv .dpm/bin "$HOME/$CONF_FILE"; then
        echo "$(tput setaf 3)Would you like to add dpm to your PATH (in $CONF_FILE)?.$(tput sgr 0)"
        read -p "Add to PATH? [Y/n]: " path_answer
        if [[ $path_answer == [yY] || $path_answer == [yY][eE][sS] || $path_answer == "" ]]; then
          echo -e "\nexport PATH=\"\$HOME/.dpm/bin:\$PATH\"" >> "$HOME/$CONF_FILE"
          echo "$(tput setaf 5)DPM added to path$(tput sgr 0)"
          # If dpm added, tell user to restart shell at end
          LOG_PATH_INSTRUCTIONS=2
        else
          LOG_PATH_INSTRUCTIONS=1
        fi
      fi
    else
      LOG_PATH_INSTRUCTIONS=1
    fi
  fi
  echo "$(tput setaf 3)DPM installed.$(tput sgr 0)"
  # Don't need to update DPM if we just grabbed it
  TO_SKIP+=(dpm)
fi

# Some issues with updating release yaml file
chmod -R u+w "$DPM_HOME"

assembly_location="$DPM_HOME/cache/sdk/open-source/$RELEASE_VERSION.yaml"

all_dpm_components=(canton-community damlc daml-script codegen daml-new upgrade-check)

# Create a `RELEASE_VERSION.yaml` if it doesn't exist already with only daml components
if [ ! -f "$assembly_location" ]; then
  assembly_location="$DPM_HOME/cache/sdk/open-source/$RELEASE_VERSION.yaml"
  dpm_version=$(HOME=. $DPM_HOME/bin/dpm -v 2> /dev/null | head -n 1 | sed -e "s/^version: //")

  component_versions=""
  # Macos got angry with value loops, so looping keys
  for i in "${!all_dpm_components[@]}"; do
    component_versions="$component_versions${all_dpm_components[$i]}:
      version: $COMPONENT_VERSION
    "
  done

  cat > "$assembly_location" << EOF
apiVersion: digitalasset.com/v1
kind: SdkManifest
spec:
  components:
    $component_versions
  assistant:
    version: $dpm_version
  version: $RELEASE_VERSION
  edition: open-source
EOF
  echo "$(tput setaf 3)Created assembly for $RELEASE_VERSION.$(tput sgr 0)"
fi

all_components=("${all_dpm_components[@]}" jars dpm)

# If no explicit components specified, update all
if [[ ! ${TO_BUILD[@]} ]]; then
  TO_BUILD=("${all_components[@]}")
fi

# Imitate `chronic` from coreutils
chronic() {
  if [ "$VERBOSE" -ne 0 ]; then
    "$@"
  else
    # Store stdout and stderr to a tmp file
    tmp=$(mktemp) || return
    # Don't die just yet!
    set +e
    "$@" > "$tmp" 2>&1
    ret=$?
    set -e
    [ "$ret" -eq 0 ] || cat "$tmp"
    rm -f "$tmp"
    # Now you can die
    return "$ret"
  fi
}

update_component() {
  target_name=$1
  progress_marker=$2

  if [[ "$target_name" = "dpm" ]]; then
    # For DPM, we pull down from OCI again
    echo "$(tput setaf 5)$progress_marker Pulling down new DPM binary.$(tput sgr 0)"

    DPM_VERSION=$(get_dpm)

    # Update our $RELEASE_VERSION.yaml to point to new DPM
    DPM_VERSION=$DPM_VERSION yq -MiY '.spec.assistant.version |= env.DPM_VERSION' "$assembly_location"
    echo "$(tput setaf 3)$progress_marker Installed most recent dpm.$(tput sgr 0)"
  elif [[ "$target_name" = "jars" ]]; then
    tmp="$(mktemp -d)"
    
    function cleanup() {
      echo "$(tput setaf 3)FAILED TO INSTALL JARS! $(tput sgr 0)"
      rm -rf $tmp
    }
    trap cleanup EXIT

    echo "$(tput setaf 5)$progress_marker Building //release:release for JARs.$(tput sgr 0)"
    bazel build ${BAZEL_MODE_FLAGS[@]:-} //release:release
    RELEASE_ARGS=(--release-dir "$tmp" --install-head-jars --no-ts --no-docs)
    echo "$(tput setaf 5)$progress_marker Built //release:release, running...$(tput sgr 0)"

    DAML_SDK_RELEASE_VERSION=$COMPONENT_VERSION "${REPO_ROOT}/bazel-bin/release/release" ${RELEASE_ARGS[@]}
    rm -rf $tmp
    trap - EXIT

    echo "$(tput setaf 3)$progress_marker Installed JARs.$(tput sgr 0)"
  else
    # Find the OCI bazel target for the component as `package_oci_component` rule named `${component}-oci`
    bazel_path=$(bazel query "kind('package_oci_component', //...)" 2> /dev/null | grep "$target_name-oci")
    echo "$(tput setaf 5)$progress_marker Building $bazel_path.$(tput sgr 0)"
    # Build target
    DAML_SDK_RELEASE_VERSION=$COMPONENT_VERSION chronic bazel build "${BAZEL_MODE_FLAGS[@]}" "$bazel_path"
    echo "$(tput setaf 5)$progress_marker Built $bazel_path.$(tput sgr 0)"
    # Find built tar and unpack to DPM component
    output_path=$(bazel cquery "${BAZEL_MODE_FLAGS[@]}" "$bazel_path" --output=files 2> /dev/null)
    component_path="$DPM_HOME/cache/components/$target_name/$COMPONENT_VERSION"
    rm -rf $component_path
    mkdir -p "$component_path"
    tar -xzf "$output_path" -C "$component_path"
    echo "$(tput setaf 5)$progress_marker Unpacked component, updating assembly.$(tput sgr 0)"
    # Update $RELEASE_VERSION.yaml entry for given component to point to new unpacked component
    TARGET_NAME=$target_name COMPONENT_VERSION=$COMPONENT_VERSION yq -MiY '.spec.components.[env.TARGET_NAME].version |= env.COMPONENT_VERSION' "$assembly_location"
    echo "$(tput setaf 3)$progress_marker Installed $target_name to $component_path.$(tput sgr 0)"
  fi
}

# Remove the components to be skipped by rebuilding the list
# bash makes this painful :(
unskipped_to_build=("${TO_BUILD[@]}")
TO_BUILD=()
for i in "${!unskipped_to_build[@]}"; do
  if [[ ! " ${TO_SKIP[*]} " =~ [[:space:]]${unskipped_to_build[$i]}[[:space:]] ]]; then
    TO_BUILD+=("${unskipped_to_build[$i]}")
  fi
done

for i in "${!TO_BUILD[@]}"; do
  update_component "${TO_BUILD[$i]}" "($((i + 1))/${#TO_BUILD[@]})"
done

#dpm-head script which overrides the sdk version to 0.0.0 (since default is highest)
cat > "${DPM_HOME}/bin/dpm-head" << EOF
#!/bin/sh
exec env DPM_SDK_VERSION=$RELEASE_VERSION "${DPM_HOME}/bin/dpm" "\$@"
EOF
chmod +x "${DPM_HOME}/bin/dpm-head"
echo "$(tput setaf 3)Updated dpm-head to point to $RELEASE_VERSION.$(tput sgr 0)"

if [[ $REMOVE_OTHER_VERSIONS -ne 0 ]]; then
  # Deleting sdk/* rather than sdk with a depth of 2, to avoid accidentally deleting sdk/.lock
  find "$DPM_HOME"/cache/sdk/* ! -name "$RELEASE_VERSION.yaml" -type f -exec rm -f {} +
  echo "$(tput setaf 1)Removed all versions other than $RELEASE_VERSION$(tput sgr 0)"
fi

echo "$(tput setaf 2)Installed $RELEASE_VERSION to dpm.$(tput sgr 0)"

case "$LOG_PATH_INSTRUCTIONS" in
  "1")
    echo "$(tput setaf 3)DPM was installed but not added to your \$PATH, please add \"~/.dpm/bin\" to your \$PATH.$(tput sgr 0)"
    ;;
  "2")
    echo "$(tput setaf 3)DPM was added to your \$PATH, you will need to reload your shell to use DPM.$(tput sgr 0)"
    ;;
esac

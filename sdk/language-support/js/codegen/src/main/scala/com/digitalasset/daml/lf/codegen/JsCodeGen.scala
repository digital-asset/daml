// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.digitalasset.daml.lf.codegen

import java.nio.file.{Files, Path}
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.{Executors, ThreadFactory}

import scala.collection.immutable.Map
import scala.concurrent.{Await, ExecutionContext, ExecutionContextExecutorService, Future}
import scala.concurrent.duration._

import com.digitalasset.daml.lf.archive.DamlLf
import com.digitalasset.daml.lf.archive.DarParser
import com.digitalasset.daml.lf.codegen.js._
import com.digitalasset.daml.lf.data.ImmArray
import com.digitalasset.daml.lf.data.Ref._
import com.digitalasset.daml.lf.language.Ast
import com.digitalasset.daml.lf.typesig.reader.DamlLfArchiveReader
import com.typesafe.scalalogging.StrictLogging
import org.slf4j.{Logger, LoggerFactory}
import scalaz.{-\/, \/-}

private final class JsCodeGen(
    outputDirectory: Path,
    npmScope: String,
    damlVersion: String,
    allPackages: Map[PackageId, Ast.PackageSignature],
) extends StrictLogging {
  def writePackage(packageId: PackageId, packageSig: Ast.PackageSignature): Unit = {
    // The directory into which we write this package e.g. '/path/to/daml2js/davl-0.0.4'
    val packageDir = outputDirectory.resolve(packageSig.metadata.nameDashVersion)
    // Where the source files of this package are written e.g. '/path/to/daml2js/davl-0.0.4/lib'
    val srcDir = packageDir.resolve("lib")
    val packageName = packageSig.metadata.name
    val moduleGens = packageSig.modules
      .filter { case (_, module) => !module.isUtilityModule }
      .toSeq
      .sortBy(_._1)
      .map { case (moduleName, module) =>
        genModule(ModuleId(packageId, moduleName), packageName, module)
      }

    Files.createDirectories(srcDir)
    moduleGens.foreach { module =>
      val moduleDir = module.moduleName.segments.foldLeft(srcDir)(_.resolve(_))
      Files.createDirectories(moduleDir)
      Files.write(moduleDir.resolve("module.js"), module.renderJsSource.getBytes)
      Files.write(moduleDir.resolve("module.d.ts"), module.renderTsExport.getBytes)
    }
    val moduleTree =
      moduleGens.foldLeft(ModuleTree.empty)((tree, module) => tree.add(module.moduleName))
    writeIndexFiles(srcDir, packageId, moduleTree)
    Files.write(packageDir.resolve("tsconfig.json"), tsConfig.getBytes)
    val dependencies =
      moduleGens.flatMap(_.externalImports).distinctBy(_._1).map(_._2).sortBy(_.name)
    val _ = Files.write(
      packageDir.resolve("package.json"),
      renderPackageJson(packageSig.metadata, dependencies).getBytes,
    )
  }

  private def writeIndexFiles(srcDir: Path, packageId: PackageId, rootTree: ModuleTree): Unit = {
    Files.write(srcDir.resolve("index.d.ts"), rootTree.renderTsExports(Some(packageId)).getBytes)
    Files.write(srcDir.resolve("index.js"), rootTree.renderJsExports(Some(packageId)).getBytes)
    def writeModuleIndex(dir: Path, moduleTree: ModuleTree): Unit = {
      Files.write(dir.resolve("index.d.ts"), moduleTree.renderTsExports(packageId = None).getBytes)
      Files.write(dir.resolve("index.js"), moduleTree.renderJsExports(packageId = None).getBytes)
      moduleTree.childTrees
        .foreach { case (name, tree) => writeModuleIndex(dir.resolve(name), tree) }
    }
    rootTree.childTrees
      .foreach { case (name, tree) => writeModuleIndex(srcDir.resolve(name), tree) }
  }

  private def renderPackageJson(
      packageMetadata: Ast.PackageMetadata,
      dependencies: Seq[Ast.PackageMetadata],
  ): String = {
    val deps = Seq(""""@mojotech/json-type-validation": "^3.1.0"""") ++
      dependencies
        .map(d => s""""@$npmScope/${d.nameDashVersion}": "file:../${d.nameDashVersion}"""")
    s"""|{
        |  "private": true,
        |  "name": "@$npmScope/${packageMetadata.nameDashVersion}",
        |  "version": "$damlVersion",
        |  "license": "UNLICENSED",
        |  "main": "lib/index.js",
        |  "types": "lib/index.d.ts",
        |  "description": "Generated by `dpm codegen-js` from SDK $damlVersion",
        |  "dependencies": {
        |    ${deps.mkString(",\n    ")}
        |  },
        |  "peer-dependencies": {
        |    "@daml/types": "$damlVersion"
        |  }
        |}
        |""".stripMargin
  }

  // returns the list of typescript definitions, along with the needed internal and external imports
  private def genModule(
      moduleId: ModuleId,
      packageName: PackageName,
      module: Ast.ModuleSignature,
  ): ModuleGen = {
    val (topLevelDefinitions, nestedDefinitions) =
      module.serializableDefinitions.partition { case (name, _) => name.segments.length == 1 }

    // map top level name to list of nested definitions
    val nestedDefinitionMap = nestedDefinitions.groupBy { case (name, _) => name.segments.head }

    val templateAndDataDefs = topLevelDefinitions.toSeq
      .sortBy(_._1)
      .flatMap { case (dottedName, dataDef) =>
        val dataConsName = dottedName.segments.head
        module.templates.get(dottedName) match {
          case Some(template) =>
            genTemplate(moduleId, packageName, dataConsName, template, dataDef)
          case None =>
            val nestedDefs =
              nestedDefinitionMap.getOrElse(dataConsName, Map.empty).toSeq.sortBy(_._1)
            genDataDef(moduleId, dataConsName, dataDef, nestedDefs)
        }
      }
    val interfaces = module.interfaces.toSeq
      .sortBy(_._1)
      .map { case (name, interface) => genInterface(moduleId, packageName, name, interface) }
    val imports = (
      module.serializableDefinitions.valuesIterator.map(collectModuleRefs) ++
        module.templates.valuesIterator.map(collectModuleRefs) ++
        module.interfaces.valuesIterator.map(collectModuleRefs)
    ).fold(Set.empty)(_ ++ _)
    val (internalImports, externalImports) = imports.partition(_.pkg == moduleId.pkg)
    ModuleGen(
      moduleId.moduleName,
      npmScope,
      externalImports.map(_.pkg).toSeq.sorted.map(pkg => (pkg, allPackages(pkg).metadata)),
      internalImports.filterNot(_ == moduleId).map(_.moduleName).toSeq.sorted,
      // interfaces need to come before data definitions, otherwise template object would not
      // contain interface choice objects
      interfaces.toSeq ++ templateAndDataDefs,
    )
  }

  private def genTemplate(
      moduleId: ModuleId,
      packageName: PackageName,
      templateName: Name,
      templateSig: Ast.TemplateSignature,
      dataDef: Ast.DDataType,
  ): Seq[DefGen] = {
    val paramNames = dataDef.params.toSeq.map { case (name, _) => name }
    val typeCon = TypeConGen(moduleId, templateName, paramNames, dataDef.cons)
    val choices = templateSig.choices.toSeq
      .sortBy(_._1)
      .map { case (name, choice) => ChoiceGen(name, choice.argBinder._2, choice.returnType) }
    val implements = templateSig.implements.keys
    val template = TemplateGen(
      moduleId,
      packageName,
      templateName,
      Decoder(templateName, dataDef.cons),
      Encode(templateName, dataDef.cons),
      templateSig.key.map(key => TypeDecoder(key.typ)),
      templateSig.key.map(key => TypeEncode(key.typ)).getOrElse(ThrowEncode),
      choices,
      implements,
    )
    val namespaceOpt =
      templateSig.key.map(k => TemplateNamespaceGen(moduleId, templateName, k.typ))
    val registration = TemplateRegistrationGen(moduleId.pkg, packageName, templateName)
    Seq(typeCon, template) ++ namespaceOpt ++ Seq(registration)
  }

  private def genDataDef(
      moduleId: ModuleId,
      dataConName: Name,
      dataDef: Ast.DDataType,
      nestedDefinitions: Seq[(DottedName, Ast.DDataType)],
  ): Seq[DefGen] = {
    val paramNames = dataDef.params.toSeq.map { case (name, _) => name }
    val typeCon = TypeConGen(moduleId, dataConName, paramNames, dataDef.cons)
    val nestedSerializables =
      nestedDefinitions.map { case (nestedName, nestedDef) =>
        NestedSerializable(
          nestedName,
          Decoder(nestedName, nestedDef.cons),
          Encode(nestedName, nestedDef.cons),
        )
      }
    val keys = dataDef.cons match {
      case Ast.DataEnum(names) => names.toSeq
      case _ => Seq.empty
    }
    val serializable = SerializableGen(
      moduleId,
      dataConName,
      paramNames,
      keys = keys,
      Decoder(dataConName, dataDef.cons),
      Encode(dataConName, dataDef.cons),
      nestedSerializables,
    )
    val nestedTypeCons = nestedDefinitions.map { case (dottedName, dataDef) =>
      val nestedName = dottedName.segments.tail.head
      val paramNames = dataDef.params.toSeq.map { case (name, _) => name }
      TypeConGen(moduleId, nestedName, paramNames, dataDef.cons)
    }
    val namespaceOpt =
      Option.when(nestedTypeCons.nonEmpty)(NamespaceGen(dataConName, nestedTypeCons))
    Seq(typeCon, serializable) ++ namespaceOpt
  }

  private def genInterface(
      moduleId: ModuleId,
      packageName: PackageName,
      interfaceName: DottedName,
      interface: Ast.DefInterfaceSignature,
  ): InterfaceGen = {
    val name = interfaceName.segments match {
      case ImmArray(name) => name
      case _ => error(s"invalid multi-part name for interface")
    }
    val choices = interface.choices.toSeq
      .sortBy(_._1)
      .map { case (name, choice) => ChoiceGen(name, choice.argBinder._2, choice.returnType) }
    val view = interface.view match {
      case Ast.TTyCon(tycon) => tycon
      case _ => error(s"invalid view type for $interfaceName: ${interface.view}")
    }
    InterfaceGen(moduleId, packageName, name, choices, view)
  }

  private def collectModuleRefs(dataDef: Ast.DDataType): Set[ModuleId] =
    dataDef.cons match {
      case Ast.DataRecord(fields) => collectModuleRefs(fields.toList.map(_._2))
      case Ast.DataVariant(variants) => collectModuleRefs(variants.toList.map(_._2))
      case Ast.DataEnum(_) | Ast.DataInterface => Set.empty
    }

  private def collectModuleRefs(template: Ast.TemplateSignature): Set[ModuleId] =
    collectModuleRefs(
      template.choices.values.toList.flatMap(c => List(c.argBinder._2, c.returnType)) ++
        template.key.map(_.typ)
    ) ++ template.implements.values.map(i => toModuleId(i.interfaceId))

  private def collectModuleRefs(interface: Ast.DefInterfaceSignature): Set[ModuleId] =
    collectModuleRefs(
      interface.choices.values.toList.flatMap(c => List(c.argBinder._2, c.returnType))
    )

  private def collectModuleRefs(types: List[Ast.Type]): Set[ModuleId] = {
    @scala.annotation.tailrec
    def rec(types: List[Ast.Type], acc: Set[ModuleId]): Set[ModuleId] =
      types match {
        case Ast.TSynApp(tysyn, args) :: tail => rec(args.toList ++ tail, acc + toModuleId(tysyn))
        case Ast.TTyCon(tycon) :: tail => rec(tail, acc + toModuleId(tycon))
        case Ast.TApp(tyfun, arg) :: tail => rec(List(tyfun, arg) ++ tail, acc)
        case Ast.TForall(_, body) :: tail => rec(body :: tail, acc)
        case Ast.TStruct(fields) :: tail => rec(fields.iterator.map(_._2).toList ++ tail, acc)
        case _ :: tail => rec(tail, acc)
        case Nil => acc
      }
    rec(types, Set.empty)
  }

  private val tsConfig =
    """|{
       |  "compilerOptions": {
       |    "declaration": true,
       |    "lib": [
       |      "dom",
       |      "es2015"
       |    ],
       |    "module": "commonjs",
       |    "noFallthroughCasesInSwitch": true,
       |    "noImplicitReturns": true,
       |    "noUnusedLocals": false,
       |    "outDir": "lib",
       |    "skipLibCheck": true,
       |    "sourceMap": true,
       |    "strict": true,
       |    "target": "es5"
       |  },
       |  "include": [
       |    "src/**/*.ts"
       |  ]
       |}""".stripMargin

  private def toModuleId(identifier: Identifier): ModuleId =
    ModuleId(identifier.pkg, identifier.qualifiedName.module)

  private def error(message: String): Nothing = throw new RuntimeException(message)
}

object JsCodeGen extends StrictLogging {

  def run(conf: JsCodeGenConf, damlVersion: String): Unit = {
    LoggerFactory
      .getLogger(Logger.ROOT_LOGGER_NAME)
      .asInstanceOf[ch.qos.logback.classic.Logger]
      .setLevel(conf.verbosity)
    LoggerFactory
      .getLogger("com.digitalasset.daml.lf.codegen.backend.java.inner")
      .asInstanceOf[ch.qos.logback.classic.Logger]
      .setLevel(conf.verbosity)

    implicit val executionContext: ExecutionContextExecutorService = createExecutionContext()

    val future = run(conf.darFiles, conf.outputDirectory, conf.npmScope, damlVersion)

    Await.result(future, 10.minutes)
    executionContext.shutdownNow()
    ()
  }

  def run(darFiles: Seq[Path], outputDir: Path, npmScope: String, damlVersion: String)(implicit
      ec: ExecutionContext
  ): Future[Unit] =
    for {
      _ <- Future(darFiles.foreach(assertInputFileExists))
      allPackages <- Future
        .traverse(darFiles)(path => Future(decodeDar(path)))
        .map(_.fold(Map.empty)(_ ++ _))
      _ = checkAndCreateOutputDir(outputDir)
      filteredPackages = allPackages
        .filterNot { case (pkgId, pkg) =>
          val skip = pkg.isUtilityPackage
          if (skip)
            logger.info(
              s"Skipping ${pkg.metadata.nameDashVersion} (hash: $pkgId) as it does not define any serializable types"
            )
          skip
        }
      sortedPackages = filteredPackages.toSeq
        .sortBy { case (_, pkg) => (pkg.metadata.name, pkg.metadata.version) }
      _ = assertNoDuplicateNameAndVersion(sortedPackages)
      codegen = new JsCodeGen(outputDir, npmScope, damlVersion, allPackages)
      _ <- Future.traverse(sortedPackages) { case (pkgId, pkg) =>
        Future {
          logger.info(s"Generating ${pkg.metadata.nameDashVersion} (hash: $pkgId)")
          codegen.writePackage(pkgId, pkg)
        }
      }
    } yield ()

  private def assertNoDuplicateNameAndVersion(
      packages: Seq[(PackageId, Ast.PackageSignature)]
  ): Unit = {
    val _ = packages
      .groupMapReduce { case (_, pkg) =>
        (pkg.metadata.name, pkg.metadata.version)
      } { case (_, pkg) =>
        (pkg.metadata.name, pkg.metadata.version)
      } { case ((name, version), _) =>
        throw new RuntimeException(
          s"Duplicate name '$name-$version' for different packages detected"
        )
      }
  }

  private def decodeDar(path: Path): Map[PackageId, Ast.PackageSignature] =
    DarParser.assertReadArchiveFromFile(path.toFile).all.map(tryDecodeArchive).toMap

  private def tryDecodeArchive(archive: DamlLf.Archive): (PackageId, Ast.PackageSignature) = {
    DamlLfArchiveReader.readPackage(archive) match {
      case -\/(error) => throw new RuntimeException(error)
      case \/-(result @ (packageId, _)) =>
        logger.trace(s"Daml-LF Archive decoded, packageId '$packageId'")
        result
    }
  }

  private def createExecutionContext(): ExecutionContextExecutorService =
    ExecutionContext.fromExecutorService(
      Executors.newFixedThreadPool(
        Runtime.getRuntime.availableProcessors(),
        new ThreadFactory {
          val n = new AtomicInteger(0)
          override def newThread(r: Runnable): Thread = {
            val t = new Thread(r)
            t.setDaemon(true)
            t.setName(s"ts-codegen-${n.getAndIncrement}")
            t
          }
        },
      )
    )

  private def assertInputFileExists(filePath: Path): Unit = {
    logger.trace(s"Checking that the file '$filePath' exists")
    if (Files.notExists(filePath)) {
      throw new IllegalArgumentException(s"Input file '$filePath' doesn't exist")
    }
    if (!Files.isReadable(filePath)) {
      throw new IllegalArgumentException(s"Input file '$filePath' is not readable")
    }
  }

  private def checkAndCreateOutputDir(outputPath: Path): Unit = {
    val exists = Files.exists(outputPath)
    if (!exists) {
      logger.trace(s"Output directory '$outputPath' does not exists, creating it")
      val _ = Files.createDirectories(outputPath)
    } else if (!Files.isDirectory(outputPath)) {
      throw new IllegalArgumentException(
        s"Output directory '$outputPath' exists but it is not a directory"
      )
    }
  }
}

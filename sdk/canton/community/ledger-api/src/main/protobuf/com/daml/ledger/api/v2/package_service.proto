// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package com.daml.ledger.api.v2;

import "com/daml/ledger/api/v2/package_reference.proto";

option csharp_namespace = "Com.Daml.Ledger.Api.V2";
option java_outer_classname = "PackageServiceOuterClass";
option java_package = "com.daml.ledger.api.v2";

message ListPackagesResponse {
  // The IDs of all Daml-LF packages supported by the server.
  // Each element must be a valid PackageIdString (as described in ``value.proto``).
  // Required
  repeated string package_ids = 1;
}

message GetPackageResponse {
  // The hash function we use to calculate the hash.
  // Required
  HashFunction hash_function = 1;

  // Contains a ``daml_lf`` ArchivePayload. See further details in ``daml_lf.proto``.
  // Required
  bytes archive_payload = 2;

  // The hash of the archive payload, can also used as a ``package_id``.
  // Must be a valid PackageIdString (as described in ``value.proto``).
  // Required
  string hash = 3;
}

message GetPackageStatusResponse {
  // The status of the package.
  PackageStatus package_status = 1;
}

enum PackageStatus {
  // The server is not aware of such a package.
  PACKAGE_STATUS_UNSPECIFIED = 0;

  // The server is able to execute Daml commands operating on this package.
  PACKAGE_STATUS_REGISTERED = 1;
}

enum HashFunction {
  HASH_FUNCTION_SHA256 = 0;
}

// Allows clients to query the Daml-LF packages that are supported by the server.
service PackageService {
  // Returns the identifiers of all supported packages.
  rpc ListPackages(ListPackagesRequest) returns (ListPackagesResponse);

  // Returns the contents of a single package.
  rpc GetPackage(GetPackageRequest) returns (GetPackageResponse);

  // Returns the status of a single package.
  rpc GetPackageStatus(GetPackageStatusRequest) returns (GetPackageStatusResponse);

  // Lists which participant node vetted what packages on which synchronizer.
  // Can be called by any authenticated user.
  rpc ListVettedPackages(ListVettedPackagesRequest) returns (ListVettedPackagesResponse);
}

message ListPackagesRequest {}

message GetPackageRequest {
  // The ID of the requested package.
  // Must be a valid PackageIdString (as described in ``value.proto``).
  // Required
  string package_id = 1;
}

message GetPackageStatusRequest {
  // The ID of the requested package.
  // Must be a valid PackageIdString (as described in ``value.proto``).
  // Required
  string package_id = 1;
}

// Filter the VettedPackages by package metadata.
//
// A PackageMetadataFilter without package_ids and without package_name_prefixes
// matches any vetted package.
//
// Non-empty fields specify candidate values of which at least one must match.
// If both fields are set, then a candidate is returned if it matches one of the fields.
message PackageMetadataFilter {
  // If this list is non-empty, any vetted package with a package ID in this
  // list will match the filter.
  repeated string package_ids = 1;

  // If this list is non-empty, any vetted package with a name matching at least
  // one prefix in this list will match the filter.
  repeated string package_name_prefixes = 2;
}

// Filter the vetted packages by the participant and synchronizer that they are
// hosted on.
//
// Empty fields are ignored, such that a ``TopologyStateFilter`` without
// participant_ids and without synchronizer_ids matches a vetted package hosted
// on any participant and synchronizer.
//
// Non-empty fields specify candidate values of which at least one must match.
// If both fields are set then at least one candidate value must match from each
// field.
message TopologyStateFilter {
  // If this list is non-empty, only vetted packages hosted on participants
  // listed in this field match the filter.
  // Query the current Ledger API's participant's ID via the public
  // ``GetParticipantId`` command in ``PartyManagementService``.
  repeated string participant_ids = 1;

  // If this list is non-empty, only vetted packages from the topology state of
  // the synchronizers in this list match the filter.
  repeated string synchronizer_ids = 2;
}

message ListVettedPackagesRequest {
  // The package metadata filter the returned vetted packages set must satisfy.
  // Optional.
  PackageMetadataFilter package_metadata_filter = 1;

  // The topology filter the returned vetted packages set must satisfy.
  // Optional.
  TopologyStateFilter topology_state_filter = 2;

  // Pagination token to determine the specific page to fetch. Using the token
  // guarantees that ``VettedPackages`` on a subsequent page are all greater
  // (``VettedPackages`` are sorted by synchronizer ID then participant ID) than
  // the last ``VettedPackages`` on a previous page.
  //
  // The server does not store intermediate results between calls chained by a
  // series of page tokens. As a consequence, if new vetted packages are being
  // added and a page is requested twice using the same token, more packages can
  // be returned on the second call.
  //
  // Leave empty to fetch the first page.
  //
  // Optional
  optional string page_token = 3;

  // Maximum number of ``VettedPackages`` results to return in a single page.
  //
  // If the page_size is unspecified, the server will decide the number of
  // results to be returned.
  //
  // If the page_size exceeds the maximum supported by the server, an
  // error will be returned.
  //
  // To obtain the server's maximum consult the PackageService descriptor
  // available in the VersionService.
  //
  // Optional
  optional uint32 page_size = 4;
}

message ListVettedPackagesResponse {
  // All ``VettedPackages`` that contain at least one ``VettedPackage`` matching
  // both a ``PackageMetadataFilter`` and a ``TopologyStateFilter``.
  // Sorted by synchronizer_id then participant_id.
  repeated VettedPackages vetted_packages = 1;

  // Pagination token to retrieve the next page.
  // Empty, if there are no further results.
  optional string next_page_token = 2;
}

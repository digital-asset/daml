// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package com.daml.ledger.api.v2.admin;

import "com/daml/ledger/api/v2/admin/object_meta.proto";
import "com/daml/ledger/api/v2/crypto.proto";
import "com/daml/ledger/api/v2/interactive/interactive_submission_service.proto";
import "google/protobuf/field_mask.proto";

option csharp_namespace = "Com.Daml.Ledger.Api.V2.Admin";
option java_outer_classname = "PartyManagementServiceOuterClass";
option java_package = "com.daml.ledger.api.v2.admin";

// This service allows inspecting the party management state of the ledger known to the participant
// and managing the participant-local party metadata.
//
// The authorization rules for its RPCs are specified on the ``<RpcName>Request``
// messages as boolean expressions over these facts:
//
// 1. ``HasRight(r)`` denoting whether the authenticated user has right ``r`` and
// 2. ``IsAuthenticatedIdentityProviderAdmin(idp)`` denoting whether ``idp`` is equal to the ``identity_provider_id``
//    of the authenticated user and the user has an IdentityProviderAdmin right.
//
// If `identity_provider_id` is set to an empty string, then it's effectively set to the value of access token's 'iss' field if that is provided.
// If `identity_provider_id` remains an empty string, the default identity provider will be assumed.
//
// The fields of request messages (and sub-messages) are marked either as ``Optional`` or ``Required``:
//
// 1. ``Optional`` denoting the client may leave the field unset when sending a request.
// 2. ``Required`` denoting the client must set the field to a non-default value when sending a request.
//
// A party details resource is described by the ``PartyDetails`` message,
// A party details resource, once it has been created, can be modified using the ``UpdatePartyDetails`` RPC.
// The only fields that can be modified are those marked as ``Modifiable``.
service PartyManagementService {
  // Return the identifier of the participant.
  // All horizontally scaled replicas should return the same id.
  // daml-on-kv-ledger: returns an identifier supplied on command line at launch time
  // canton: returns globally unique identifier of the participant
  rpc GetParticipantId(GetParticipantIdRequest) returns (GetParticipantIdResponse);

  // Get the party details of the given parties. Only known parties will be
  // returned in the list.
  rpc GetParties(GetPartiesRequest) returns (GetPartiesResponse);

  // List the parties known by the participant.
  // The list returned contains parties whose ledger access is facilitated by
  // the participant and the ones maintained elsewhere.
  rpc ListKnownParties(ListKnownPartiesRequest) returns (ListKnownPartiesResponse);

  // Allocates a new party on a ledger and adds it to the set managed by the participant.
  // Caller specifies a party identifier suggestion, the actual identifier
  // allocated might be different and is implementation specific.
  // Caller can specify party metadata that is stored locally on the participant.
  // This call may:
  //
  // - Succeed, in which case the actual allocated identifier is visible in
  //   the response.
  // - Respond with a gRPC error
  //
  // daml-on-kv-ledger: suggestion's uniqueness is checked by the validators in
  // the consensus layer and call rejected if the identifier is already present.
  // canton: completely different globally unique identifier is allocated.
  // Behind the scenes calls to an internal protocol are made. As that protocol
  // is richer than the surface protocol, the arguments take implicit values
  // The party identifier suggestion must be a valid party name. Party names are required to be non-empty US-ASCII strings built from letters, digits, space,
  // colon, minus and underscore limited to 255 chars
  rpc AllocateParty(AllocatePartyRequest) returns (AllocatePartyResponse);

  // Alpha 3.3: Endpoint to allocate a new external party on a synchronizer
  //
  // Expected to be stable in 3.5
  //
  // The external party must be hosted (at least) on this node with either confirmation or observation permissions
  // It can optionally be hosted on other nodes (then called a multi-hosted party).
  // If hosted on additional nodes, explicit authorization of the hosting relationship must be performed on those nodes
  // before the party can be used.
  // Decentralized namespaces are supported but must be provided fully authorized by their owners.
  // The individual owner namespace transactions can be submitted in the same call (fully authorized as well).
  // In the simple case of a non-multi hosted, non-decentralized party, the RPC will return once the party is
  // effectively allocated and ready to use, similarly to the AllocateParty behavior.
  // For more complex scenarios applications may need to query the party status explicitly (only through the admin API as of now).
  rpc AllocateExternalParty(AllocateExternalPartyRequest) returns (AllocateExternalPartyResponse);

  // Update selected modifiable participant-local attributes of a party details resource.
  // Can update the participant's local information for local parties.
  rpc UpdatePartyDetails(UpdatePartyDetailsRequest) returns (UpdatePartyDetailsResponse);

  // Update the assignment of a party from one IDP to another.
  rpc UpdatePartyIdentityProviderId(UpdatePartyIdentityProviderIdRequest) returns (UpdatePartyIdentityProviderIdResponse);

  // Alpha 3.3: Convenience endpoint to generate topology transactions for external signing
  //
  // Expected to be stable in 3.5
  //
  // You may use this endpoint to generate the common external topology transactions
  // which can be signed externally and uploaded as part of the allocate party process
  //
  // Note that this request will create a normal namespace using the same key for the
  // identity as for signing. More elaborate schemes such as multi-signature
  // or decentralized parties require you to construct the topology transactions yourself.
  rpc GenerateExternalPartyTopology(GenerateExternalPartyTopologyRequest) returns (GenerateExternalPartyTopologyResponse);
}

// Required authorization: ``HasRight(ParticipantAdmin)``
message GetParticipantIdRequest {}

message GetParticipantIdResponse {
  // Identifier of the participant, which SHOULD be globally unique.
  // Must be a valid LedgerString (as describe in ``value.proto``).
  string participant_id = 1;
}

// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
message GetPartiesRequest {
  // The stable, unique identifier of the Daml parties.
  // Must be valid PartyIdStrings (as described in ``value.proto``).
  // Required
  repeated string parties = 1;

  // The id of the ``Identity Provider`` whose parties should be retrieved.
  // Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
  string identity_provider_id = 2;
}

message GetPartiesResponse {
  // The details of the requested Daml parties by the participant, if known.
  // The party details may not be in the same order as requested.
  // Required
  repeated PartyDetails party_details = 1;
}

// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
message ListKnownPartiesRequest {
  // Pagination token to determine the specific page to fetch. Using the token guarantees that parties on a subsequent
  // page are all lexically greater than the last party on a previous page. Server does not store intermediate results
  // between calls chained by a series of page tokens. As a consequence, if new parties are being added and a page is
  // requested twice using the same token, more parties can be returned on the second call.
  // Leave empty to fetch the first page.
  // Optional
  string page_token = 2;

  // Maximum number of results to be returned by the server. The server will return no more than that many results,
  // but it might return fewer. If the page_size is 0, the server will decide the number of results to be returned.
  // If the page_size exceeds the maximum supported by the server, an error will be returned. To obtain the server's
  // maximum consult the PartyManagementFeature descriptor available in the VersionService.
  // Optional
  int32 page_size = 3;

  // The id of the ``Identity Provider`` whose parties should be retrieved.
  // Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
  string identity_provider_id = 1;
}

message ListKnownPartiesResponse {
  // The details of all Daml parties known by the participant.
  // Required
  repeated PartyDetails party_details = 1;

  // Pagination token to retrieve the next page.
  // Empty, if there are no further results.
  string next_page_token = 2;
}

// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
message AllocatePartyRequest {
  // A hint to the participant which party ID to allocate. It can be
  // ignored.
  // Must be a valid PartyIdString (as described in ``value.proto``).
  // Optional
  string party_id_hint = 1;

  reserved 2; // Formerly "display_name"

  // Participant-local metadata to be stored in the ``PartyDetails`` of this newly allocated party.
  // Optional
  ObjectMeta local_metadata = 3;

  // The id of the ``Identity Provider``
  // Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
  string identity_provider_id = 4;
}

message AllocatePartyResponse {
  PartyDetails party_details = 1;
}

// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
message AllocateExternalPartyRequest {
  message SignedTransaction {
    // The serialized TopologyTransaction
    bytes transaction = 1;
    // Additional signatures for this transaction specifically
    // Use for transactions that require additional signatures beyond the namespace key signatures
    // e.g: PartyToKeyMapping must be signed by all registered keys
    repeated interactive.Signature signatures = 2;
  }

  // TODO(#27670) support synchronizer aliases
  // Synchronizer ID on which to onboard the party
  // Required
  string synchronizer = 1;
  // TopologyTransactions to onboard the external party
  // Can contain:
  // - A namespace for the party.
  // This can be either a single NamespaceDelegation,
  // or DecentralizedNamespaceDefinition along with its authorized namespace owners in the form of NamespaceDelegations.
  // May be provided, if so it must be fully authorized by the signatures in this request combined with the existing topology state.
  // - A PartyToKeyMapping to register the party's signing keys.
  // May be provided, if so it must be fully authorized by the signatures in this request combined with the existing topology state.
  // - A PartyToParticipant to register the hosting relationship of the party.
  // Must be provided.
  // Required
  repeated SignedTransaction onboarding_transactions = 2;

  // Optional signatures of the combined hash of all onboarding_transactions
  // This may be used instead of providing signatures on each individual transaction
  repeated interactive.Signature multi_hash_signatures = 3;

  // The id of the ``Identity Provider``
  // If not set, assume the party is managed by the default identity provider.
  // Optional
  string identity_provider_id = 4;
}

message AllocateExternalPartyResponse {
  string party_id = 1;
}

// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(party_details.identity_provider_id)``
message UpdatePartyDetailsRequest {
  // Party to be updated
  // Required,
  // Modifiable
  PartyDetails party_details = 1;

  // An update mask specifies how and which properties of the ``PartyDetails`` message are to be updated.
  // An update mask consists of a set of update paths.
  // A valid update path points to a field or a subfield relative to the ``PartyDetails`` message.
  // A valid update mask must:
  //
  // 1. contain at least one update path,
  // 2. contain only valid update paths.
  //
  // Fields that can be updated are marked as ``Modifiable``.
  // An update path can also point to non-``Modifiable`` fields such as 'party' and 'local_metadata.resource_version'
  // because they are used:
  //
  // 1. to identify the party details resource subject to the update,
  // 2. for concurrent change control.
  //
  // An update path can also point to non-``Modifiable`` fields such as 'is_local'
  // as long as the values provided in the update request match the server values.
  // Examples of update paths: 'local_metadata.annotations', 'local_metadata'.
  // For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
  // For similar Ledger API see ``com.daml.ledger.api.v2.admin.UpdateUserRequest``.
  // Required
  google.protobuf.FieldMask update_mask = 2;
}

message UpdatePartyDetailsResponse {
  // Updated party details
  PartyDetails party_details = 1;
}

message PartyDetails {
  // The stable unique identifier of a Daml party.
  // Must be a valid PartyIdString (as described in ``value.proto``).
  // Required
  string party = 1;

  // true if party is hosted by the participant and the party shares the same identity provider as the user issuing the request.
  // Optional
  bool is_local = 3;

  // Participant-local metadata of this party.
  // Optional,
  // Modifiable
  ObjectMeta local_metadata = 4;

  // The id of the ``Identity Provider``
  // Optional, if not set, there could be 3 options:
  //
  // 1. the party is managed by the default identity provider.
  // 2. party is not hosted by the participant.
  // 3. party is hosted by the participant, but is outside of the user's identity provider.
  string identity_provider_id = 5;
}

// Required authorization: ``HasRight(ParticipantAdmin)``
message UpdatePartyIdentityProviderIdRequest {
  // Party to update
  string party = 1;
  // Current identity provider id of the party
  string source_identity_provider_id = 2;
  // Target identity provider id of the party
  string target_identity_provider_id = 3;
}

message UpdatePartyIdentityProviderIdResponse {}

message GenerateExternalPartyTopologyRequest {
  // TODO(#27670) support synchronizer aliases
  // Required: synchronizer-id for which we are building this request.
  string synchronizer = 1;
  // Required: the actual party id will be constructed from this hint and a fingerprint of the public key
  string party_hint = 2;
  // Required: public key
  com.daml.ledger.api.v2.SigningPublicKey public_key = 3;
  // Optional: if true, then the local participant will only be observing, not confirming. Default false.
  bool local_participant_observation_only = 4;
  // Optional: other participant ids which should be confirming for this party
  repeated string other_confirming_participant_uids = 5;
  // Optional: Confirmation threshold >= 1 for the party. Defaults to all available confirmers (or if set to 0).
  uint32 confirmation_threshold = 6;
  // Optional: other observing participant ids for this party
  repeated string observing_participant_uids = 7;
}

// Response message with topology transactions and the multi-hash to be signed.
message GenerateExternalPartyTopologyResponse {
  // the generated party id
  string party_id = 1;
  // the fingerprint of the supplied public key
  string public_key_fingerprint = 2;
  // The serialized topology transactions which need to be signed and submitted as part of the allocate party process
  // Note that the serialization includes the versioning information. Therefore, the transaction here is serialized
  // as an `UntypedVersionedMessage` which in turn contains the serialized `TopologyTransaction` in the version
  // supported by the synchronizer.
  repeated bytes topology_transactions = 3;
  // the multi-hash which may be signed instead of each individual transaction
  bytes multi_hash = 4;
}

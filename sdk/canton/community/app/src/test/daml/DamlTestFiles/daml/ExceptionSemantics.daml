-- Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module ExceptionSemantics where

import DA.Exception
import DA.Assert ((===))
import Daml.Script

exception E
  where
    message "E"

template K
  with
    p : Party
    v : Int
  where
    signatory p
    key (p, v) : (Party, Int)
    maintainer key._1

template T
  with
    p : Party
  where
    signatory p
    nonconsuming choice Throw : ()
      controller p
      do throw E
    nonconsuming choice Catch : ()
      controller p
      do try (exercise self Throw)
         catch
           E -> pure ()

    nonconsuming choice ThrowArithmeticError : Int
      controller p
      do pure (1/0)
    nonconsuming choice CatchArithmeticError : Int
      controller p
      do try (exercise self ThrowArithmeticError)
         catch
           (_: ArithmeticError) -> pure 42

    nonconsuming choice UncatchableTry : ()
      with
        cid : ContractId K
      controller p
      do try (() <$ fetch cid)
         catch
           E -> pure()

    nonconsuming choice TransientDuplicate : ()
      with
        i : Int
      controller p
      do try do
           create (K p i)
           create (K p i)
           throw E
         catch
           E -> pure ()
    nonconsuming choice NonTransientDuplicate : ()
      with
        i : Int
      controller p
      do try do
           create (K p i)
           throw E
         catch
           E -> pure ()
    nonconsuming choice RollbackKey : ()
      with
        i : Int
      controller p
      do try do
           create (K p i)
           throw E
         catch
           E -> create (K p i) >> pure ()

    nonconsuming choice RollbackArchive : ()
      with
        i : Int
      controller p
      do cid <- create (K p i)
         try (archive cid >> throw E)
         catch
           E -> archive cid

    nonconsuming choice NonRollbackArchive : ()
      with
        i : Int
      controller p
      do cid <- create (K p i)
         try (archive cid)
         catch
           E -> pure ()
         archive cid

template Fetcher
  with
    sig : Party
    obs : Party
  where
    signatory sig
    observer obs
    choice Fetch : K
      with
        cid : ContractId K
      controller obs
      do fetch cid
    choice RollbackFetch : ()
      with
        cid : ContractId K
      controller obs
      do try (fetch cid >> throw E)
         catch
           E -> pure ()


uncaughtUserException : Script ()
uncaughtUserException = do
  p <- allocateParty "p"
  submitMustFail p do createAndExerciseCmd (T p) Throw
  pure ()

unhandledUserException : Script ()
unhandledUserException = do
  p <- allocateParty "p"
  submitMustFail p do createAndExerciseCmd (T p) Throw
  pure ()

handledUserException : Script ()
handledUserException = do
  p <- allocateParty "p"
  _ <- submit p do createAndExerciseCmd (T p) Catch
  pure ()

uncaughtArithmeticError : Script ()
uncaughtArithmeticError = do
  p <- allocateParty "p"
  _ <- submitMustFail p do createAndExerciseCmd (T p) ThrowArithmeticError
  pure ()

unhandledArithmeticError : Script ()
unhandledArithmeticError = do
  p <- allocateParty "p"
  submitMustFail p do createAndExerciseCmd (T p) ThrowArithmeticError
  pure ()

handledArithmeticError : Script ()
handledArithmeticError = do
  p <- allocateParty "p"
  r <- submit p do createAndExerciseCmd (T p) CatchArithmeticError
  r === 42

duplicateKey : Script ()
duplicateKey = do
  p <- allocateParty "p"
  -- transient duplicate key in rollback
  submitMustFail p $ createAndExerciseCmd (T p) (TransientDuplicate 0)
  submit p do createCmd (K p 1)
  -- duplicate key error with contract created outside of rollback
  submitMustFail p do createAndExerciseCmd (T p) (NonTransientDuplicate 1)
  -- no duplicate key error if key creation got rolled back
  submit p do createAndExerciseCmd (T p) (RollbackKey 2)
  pure ()

rollbackArchive : Script ()
rollbackArchive = do
  p <- allocateParty "p"
  submit p do createAndExerciseCmd (T p) (RollbackArchive 0)
  submitMustFail p do createAndExerciseCmd (T p) (NonRollbackArchive 0)

divulgence : Script ()
divulgence = do
  p1 <- allocateParty "p1"
  p2 <- allocateParty "p2"
  cid <- submit p1 do createCmd (K p1 0)
  divulger <- submit p2 do createCmd (Fetcher p2 p1)
  fetcher <- submit p1 do createCmd (Fetcher p1 p2)
  submitMustFail p2 do exerciseCmd fetcher (Fetch cid)
  submit p1 do exerciseCmd divulger (RollbackFetch cid)
  submitMustFail p2 do exerciseCmd fetcher (Fetch cid)
  pure ()

tryContext : Script ()
tryContext = do
  p <- allocateParty "p"
  kCid <- submit p do createCmd (K p 0)
  submit p do archiveCmd kCid
  c <- submit p do createCmd (T p)
  -- This will result in a partial transaction with ptx.context.info
  -- pointing to a TryContextInfo.
  submitMustFail p do exerciseCmd c (UncatchableTry kCid)

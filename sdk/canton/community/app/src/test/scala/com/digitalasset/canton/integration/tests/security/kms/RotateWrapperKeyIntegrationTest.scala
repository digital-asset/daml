// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.digitalasset.canton.integration.tests.security.kms

import com.digitalasset.canton.crypto.kms.KmsKeyId
import com.digitalasset.canton.integration.{
  CommunityIntegrationTest,
  EnvironmentDefinition,
  SharedEnvironment,
}

trait RotateWrapperKeyIntegrationTest
    extends CommunityIntegrationTest
    with SharedEnvironment
    with EncryptedCryptoPrivateStoreTestHelpers {

  override lazy val environmentDefinition: EnvironmentDefinition =
    EnvironmentDefinition.P2_S1M1.withSetup { implicit env =>
      import env.*
      participants.all.synchronizers.connect_local(sequencer1, alias = daName)
    }

  protected val protectedNodes: Set[String] = Set("participant1")

  protected val preDefinedKey: Option[String]

  "private keys are encrypted with correct wrapper key after rotation" in { implicit env =>
    import env.*

    val encStore = getEncryptedCryptoStore(participant1.name)

    val initialKeys = listAllStoredKeys(encStore)
    val initialWrapperKey = encStore.wrapperKeyId

    preDefinedKey match {
      case Some(newWrapperKeyId) =>
        // user-manual-entry-begin: WrapperKeyRotationWithManuallyGeneratedKey
        participant1.keys.secret.rotate_wrapper_key(newWrapperKeyId)
      // user-manual-entry-end: WrapperKeyRotationWithManuallyGeneratedKey
      case None =>
        // user-manual-entry-begin: WrapperKeyRotationWithAutoGeneratedKey
        participant1.keys.secret.rotate_wrapper_key()
      // user-manual-entry-end: WrapperKeyRotationWithAutoGeneratedKey
    }

    try {
      val currentWrapperKey = encStore.wrapperKeyId
      initialWrapperKey shouldNot be(currentWrapperKey)
      if (preDefinedKey.isDefined) preDefinedKey shouldBe Some(currentWrapperKey.unwrap)
      forAll(
        listAllStoredKeys(encStore.store)
          .map(storedKey => KmsKeyId(storedKey.wrapperKeyId.valueOrFail("no wrapper key")))
      ) { wrapperKey =>
        wrapperKey shouldBe currentWrapperKey
      }

      val decryptedKeys = checkAndDecryptKeys(participant1.name)
      // compare decrypted result with previously existent keys (e.g. before the rotation)
      decryptedKeys.map(_.copy(wrapperKeyId = None)).toSet shouldBe initialKeys
        .map(_.copy(wrapperKeyId = None))
        .toSet
    } finally {
      if (preDefinedKey.isEmpty)
        encStore.kms.deleteKey(encStore.wrapperKeyId).failOnShutdown.futureValue
    }
  }

}

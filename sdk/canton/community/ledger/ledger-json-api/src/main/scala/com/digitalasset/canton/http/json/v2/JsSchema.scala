// Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.digitalasset.canton.http.json.v2

import com.daml.ledger.api.v2 as lapi
import com.daml.ledger.api.v2.admin.object_meta.ObjectMeta
import com.daml.ledger.api.v2.trace_context.TraceContext
import com.daml.ledger.api.v2.transaction_filter.TransactionShape
import com.daml.ledger.api.v2.value.Identifier
import com.daml.ledger.api.v2.{
  crypto,
  offset_checkpoint,
  reassignment,
  state_service,
  transaction_filter,
}
import com.digitalasset.base.error.utils.DecodedCantonError
import com.digitalasset.base.error.{DamlErrorWithDefiniteAnswer, RpcError}
import com.digitalasset.canton.http.json.v2.CirceRelaxedCodec.deriveRelaxedCodec
import com.digitalasset.canton.http.json.v2.JsSchema.DirectScalaPbRwImplicits.*
import com.digitalasset.canton.http.json.v2.JsSchema.JsEvent.{CreatedEvent, ExercisedEvent}
import com.google.protobuf
import com.google.protobuf.ByteString
import com.google.protobuf.field_mask.FieldMask
import com.google.protobuf.struct.Struct
import com.google.protobuf.util.JsonFormat
import com.google.rpc.error_details.{ErrorInfo, RetryInfo}
import io.circe
import io.circe.generic.extras.Configuration
import io.circe.generic.extras.semiauto.deriveConfiguredCodec
import io.circe.generic.semiauto.deriveCodec
import io.circe.{Codec, Decoder, DecodingFailure, Encoder, Json}
import scalapb.{GeneratedEnumCompanion, UnknownFieldSet}
import sttp.tapir.CodecFormat.TextPlain
import sttp.tapir.Schema.SName
import sttp.tapir.SchemaType.{SProduct, SProductField}
import sttp.tapir.generic.Derived
import sttp.tapir.generic.auto.*
import sttp.tapir.{DecodeResult, FieldName, Schema, SchemaType, Validator}

import java.time.Instant
import java.util.Base64
import scala.concurrent.duration.Duration
import scala.util.Try

/** JSON wrappers that do not belong to a particular service */
object JsSchema {

  val BYTE_STRING_PARSE_ERROR_TEMPLATE = "The string is not a valid Base64: %s"

  implicit val config: Configuration = Configuration.default.copy(
    useDefaults = true,
    strictDecoding = false,
  )

  def stringEncoderForEnum[T <: scalapb.GeneratedEnum](): Encoder[T] =
    Encoder.encodeString.contramap[T](shape => shape.companion.fromValue(shape.value).name)

  def stringDecoderForEnum[T <: scalapb.GeneratedEnum]()(implicit
      enumCompanion: GeneratedEnumCompanion[T]
  ): Decoder[T] =
    Decoder.decodeString.emap {
      case "UNRECOGNIZED" =>
        // Map UNRECOGNIZED to -1 in order to have the enum companion return the Unrecognized instance
        // which is automatically generated by protobuf
        Right(enumCompanion.fromValue(-1))
      case v =>
        enumCompanion
          .fromName(v)
          .toRight {
            s"Unrecognized enum value $v. Supported values: ${enumCompanion.values.map(_.name).mkString("[", ", ", "]")}"
          }
    }

  def stringSchemaForEnum[T <: scalapb.GeneratedEnum]()(implicit
      enumCompanion: GeneratedEnumCompanion[T]
  ): Schema[T] =
    Schema.string.validate(
      Validator.enumeration(
        implicitly[GeneratedEnumCompanion[T]].values.toList,
        v => Some(v.name),
      )
    )

  final case class JsTransaction(
      updateId: String,
      commandId: String,
      workflowId: String,
      effectiveAt: com.google.protobuf.timestamp.Timestamp,
      events: Seq[JsEvent.Event],
      offset: Long,
      synchronizerId: String,
      traceContext: Option[TraceContext],
      recordTime: com.google.protobuf.timestamp.Timestamp,
      externalTransactionHash: Option[String],
  )

  final case class JsTransactionTree(
      updateId: String,
      commandId: String,
      workflowId: String,
      effectiveAt: protobuf.timestamp.Timestamp,
      offset: Long,
      eventsById: Map[Int, JsTreeEvent.TreeEvent],
      synchronizerId: String,
      traceContext: Option[TraceContext],
      recordTime: protobuf.timestamp.Timestamp,
  )

  final case class JsInterfaceView(
      interfaceId: Identifier,
      viewStatus: com.google.rpc.status.Status,
      viewValue: Option[Json],
      implementationPackageId: Option[String],
  )
  object JsReassignmentEvent {
    sealed trait JsReassignmentEvent

    final case class JsAssignmentEvent(
        source: String,
        target: String,
        reassignmentId: String,
        submitter: String,
        reassignmentCounter: Long,
        createdEvent: CreatedEvent,
    ) extends JsReassignmentEvent

    final case class JsUnassignedEvent(value: reassignment.UnassignedEvent)
        extends JsReassignmentEvent

  }

  final case class JsReassignment(
      updateId: String,
      commandId: String,
      workflowId: String,
      offset: Long,
      events: Seq[JsReassignmentEvent.JsReassignmentEvent],
      traceContext: Option[com.daml.ledger.api.v2.trace_context.TraceContext],
      recordTime: com.google.protobuf.timestamp.Timestamp,
      synchronizerId: String,
  )

  object JsServicesCommonCodecs {
    implicit val jsTransactionRW: Codec[JsTransaction] = deriveConfiguredCodec

    implicit val unassignedEventRW: Codec[reassignment.UnassignedEvent] = deriveRelaxedCodec

    implicit val wildcardFilterRW: Codec[transaction_filter.WildcardFilter] =
      deriveRelaxedCodec
    implicit val templateFilterRW: Codec[transaction_filter.TemplateFilter] =
      deriveRelaxedCodec
    implicit val interfaceFilterRW: Codec[transaction_filter.InterfaceFilter] =
      deriveRelaxedCodec

    implicit val identifierFilterWildcardRW
        : Codec[transaction_filter.CumulativeFilter.IdentifierFilter.WildcardFilter] =
      deriveRelaxedCodec

    implicit val identifierFilterTemplateRW
        : Codec[transaction_filter.CumulativeFilter.IdentifierFilter.TemplateFilter] =
      deriveRelaxedCodec
    implicit val identifierFilterInterfaceRW
        : Codec[transaction_filter.CumulativeFilter.IdentifierFilter.InterfaceFilter] =
      deriveRelaxedCodec

    implicit val identifierFilterRW: Codec[transaction_filter.CumulativeFilter.IdentifierFilter] =
      deriveConfiguredCodec // ADT

    implicit val cumulativeFilterRW: Codec[transaction_filter.CumulativeFilter] =
      deriveRelaxedCodec

    implicit val filtersRW: Codec[transaction_filter.Filters] = deriveRelaxedCodec
    implicit val transactionFilterLegacyRW: Codec[LegacyDTOs.TransactionFilter] =
      deriveRelaxedCodec
    implicit val eventFormatRW: Codec[transaction_filter.EventFormat] = deriveRelaxedCodec

    implicit val transactionShapeEncoder: Encoder[TransactionShape] =
      stringEncoderForEnum()

    implicit val transactionShapeDecoder: Decoder[TransactionShape] =
      stringDecoderForEnum()

    implicit val transactionFormatRW: Codec[transaction_filter.TransactionFormat] =
      deriveRelaxedCodec

    implicit val jsReassignment: Codec[JsReassignment] = deriveConfiguredCodec

    implicit val jsReassignmentEventRW: Codec[JsReassignmentEvent.JsReassignmentEvent] =
      deriveConfiguredCodec

    implicit val jsReassignmentEventJsUnassignedEventRW
        : Codec[JsReassignmentEvent.JsUnassignedEvent] =
      deriveConfiguredCodec

    implicit val jsReassignmentEventJsAssignedEventRW
        : Codec[JsReassignmentEvent.JsAssignmentEvent] =
      deriveConfiguredCodec

    implicit val participantPermissionEncoder: Encoder[state_service.ParticipantPermission] =
      stringEncoderForEnum()

    implicit val participantPermissionDecoder: Decoder[state_service.ParticipantPermission] =
      stringDecoderForEnum()

    implicit val jsPrefetchContractKeyRW: Codec[js.PrefetchContractKey] = deriveConfiguredCodec

    implicit val unrecognizedShape: Schema[transaction_filter.TransactionShape.Unrecognized] =
      Schema.derived

    implicit val participantPermissionSchema: Schema[state_service.ParticipantPermission] =
      stringSchemaForEnum()

    implicit val transactionShapeSchema: Schema[transaction_filter.TransactionShape] =
      stringSchemaForEnum()

    implicit val identifierFilterSchema
        : Schema[transaction_filter.CumulativeFilter.IdentifierFilter] =
      Schema.oneOfWrapped

    implicit val filtersByPartyMapSchema: Schema[Map[String, transaction_filter.Filters]] =
      Schema.schemaForMap[transaction_filter.Filters]

    implicit val eventFormatSchema: Schema[transaction_filter.EventFormat] =
      Schema.derived

    @SuppressWarnings(Array("org.wartremover.warts.Product", "org.wartremover.warts.Serializable"))
    implicit val jsReassignmentEventSchema: Schema[JsReassignmentEvent.JsReassignmentEvent] =
      Schema.oneOfWrapped

    implicit val topologyTransactionParticipantAuthorizationAddedSchema
        : Schema[lapi.topology_transaction.ParticipantAuthorizationAdded] =
      Schema.derived
    implicit val topologyTransactionParticipantAuthorizationChangedSchema
        : Schema[lapi.topology_transaction.ParticipantAuthorizationChanged] =
      Schema.derived
    implicit val topologyTransactionParticipantAuthorizationRevokedSchema
        : Schema[lapi.topology_transaction.ParticipantAuthorizationRevoked] =
      Schema.derived

    @SuppressWarnings(Array("org.wartremover.warts.Product", "org.wartremover.warts.Serializable"))
    implicit val topologyEventEventSchema: Schema[lapi.topology_transaction.TopologyEvent.Event] =
      Schema.oneOfWrapped.name(
        SName("TopologyEventEvent")
      ) // Name selected manually otherwise it is generated as Event1

  }

  object JsEvent {
    sealed trait Event

    final case class CreatedEvent(
        offset: Long,
        nodeId: Int,
        contractId: String,
        templateId: Identifier,
        contractKey: Option[Json],
        createArgument: Option[Json],
        createdEventBlob: protobuf.ByteString,
        interfaceViews: Seq[JsInterfaceView],
        witnessParties: Seq[String],
        signatories: Seq[String],
        observers: Seq[String],
        createdAt: protobuf.timestamp.Timestamp,
        packageName: String,
        representativePackageId: String,
        acsDelta: Boolean,
    ) extends Event

    final case class ArchivedEvent(
        offset: Long,
        nodeId: Int,
        contractId: String,
        templateId: Identifier,
        witnessParties: Seq[String],
        packageName: String,
        implementedInterfaces: Seq[Identifier],
    ) extends Event

    final case class ExercisedEvent(
        offset: Long,
        nodeId: Int,
        contractId: String,
        templateId: Identifier,
        interfaceId: Option[Identifier],
        choice: String,
        choiceArgument: Json,
        actingParties: Seq[String],
        consuming: Boolean,
        witnessParties: Seq[String],
        lastDescendantNodeId: Int,
        exerciseResult: Json,
        packageName: String,
        implementedInterfaces: Seq[Identifier],
        acsDelta: Boolean,
    ) extends Event
  }

  object JsTreeEvent {
    sealed trait TreeEvent

    final case class CreatedTreeEvent(value: CreatedEvent) extends TreeEvent

    final case class ExercisedTreeEvent(value: ExercisedEvent) extends TreeEvent
  }

  final case class JsCantonError(
      code: String,
      cause: String,
      correlationId: Option[String],
      traceId: Option[String],
      context: Map[String, String],
      resources: Seq[(String, String)],
      errorCategory: Int,
      grpcCodeValue: Option[Int],
      retryInfo: Option[Duration],
      definiteAnswer: Option[Boolean],
  )

  object JsCantonError {
    import DirectScalaPbRwImplicits.*
    implicit val rw: Codec[JsCantonError] = deriveCodec
    val ledgerApiErrorContext: String = "ledger_api_error"
    val tokenProblemError: (String, String) = (ledgerApiErrorContext -> "invalid token")

    def fromErrorCode(damlError: RpcError): JsCantonError = JsCantonError(
      code = damlError.code.id,
      cause = damlError.cause,
      correlationId = damlError.correlationId,
      traceId = damlError.traceId,
      context = damlError.context,
      resources = damlError.resources.map { case (k, v) => (k.asString, v) },
      errorCategory = damlError.code.category.asInt,
      grpcCodeValue = damlError.code.category.grpcCode.map(_.value()),
      retryInfo = damlError.code.category.retryable.map(_.duration),
      definiteAnswer = damlError match {
        case errorWithDefiniteAnswer: DamlErrorWithDefiniteAnswer =>
          Some(errorWithDefiniteAnswer.definiteAnswer)
        case _ => None
      },
    )

    def fromDecodedCantonError(decodedCantonError: DecodedCantonError): JsCantonError =
      JsCantonError(
        code = decodedCantonError.code.id,
        errorCategory = decodedCantonError.code.category.asInt,
        grpcCodeValue = decodedCantonError.code.category.grpcCode.map(_.value()),
        cause = decodedCantonError.cause,
        correlationId = decodedCantonError.correlationId,
        traceId = decodedCantonError.traceId,
        context = decodedCantonError.context,
        resources = decodedCantonError.resources.map { case (k, v) => (k.toString, v) },
        retryInfo = decodedCantonError.code.category.retryable.map(_.duration),
        definiteAnswer = decodedCantonError.definiteAnswerO,
      )
  }

  object DirectScalaPbRwImplicits {
    import sttp.tapir.json.circe.*
    import sttp.tapir.generic.auto.*

    implicit val om: Codec[ObjectMeta] = deriveRelaxedCodec
    implicit val traceContext: Codec[TraceContext] = deriveRelaxedCodec
    implicit val encodeDuration: Encoder[Duration] =
      Encoder.encodeString.contramap[Duration](_.toString)

    implicit val decodeDuration: Decoder[Duration] = Decoder.decodeString.emapTry { str =>
      Try(Duration.create(str))
    }

    implicit val encodeByteString: Encoder[protobuf.ByteString] =
      Encoder.encodeString.contramap[protobuf.ByteString] { v =>
        Base64.getEncoder.encodeToString(v.toByteArray)
      }
    private def decodeByteStringEither(
        str: String
    ): Either[circe.DecodingFailure, protobuf.ByteString] =
      Try(Base64.getDecoder.decode(str))
        .map(protobuf.ByteString.copyFrom)
        .toEither
        .left
        .map(_ => DecodingFailure(BYTE_STRING_PARSE_ERROR_TEMPLATE.format(str), Nil))

    implicit val decodeByteString: Decoder[protobuf.ByteString] = Decoder.decodeString.emap { str =>
      decodeByteStringEither(str).left.map(_.message)
    }

    // proto classes use default values
    implicit val durationRW: Codec[protobuf.duration.Duration] = deriveConfiguredCodec

    implicit val field: Codec[scalapb.UnknownFieldSet.Field] = deriveConfiguredCodec
    implicit val unknownFieldSet: Codec[scalapb.UnknownFieldSet] = deriveConfiguredCodec

    implicit val fieldMask: Codec[FieldMask] = deriveConfiguredCodec

    implicit val encodeTimestamp: Encoder[protobuf.timestamp.Timestamp] =
      Encoder.encodeInstant.contramap[protobuf.timestamp.Timestamp] { timestamp =>
        Instant.ofEpochSecond(timestamp.seconds, timestamp.nanos.toLong)
      }

    implicit val decodeTimestamp: Decoder[protobuf.timestamp.Timestamp] =
      Decoder.decodeInstant.map(v => protobuf.timestamp.Timestamp(v.getEpochSecond, v.getNano))

    implicit val timestampCodec: sttp.tapir.Codec[String, protobuf.timestamp.Timestamp, TextPlain] =
      sttp.tapir.Codec.instant.mapDecode { (time: Instant) =>
        DecodeResult.Value(protobuf.timestamp.Timestamp(time.getEpochSecond, time.getNano))
      }(timestamp => Instant.ofEpochSecond(timestamp.seconds, timestamp.nanos.toLong))

    implicit val decodeStruct: Decoder[protobuf.struct.Struct] =
      Decoder.decodeJson.map { json =>
        val builder = protobuf.Struct.newBuilder
        JsonFormat.parser.ignoringUnknownFields.merge(json.toString(), builder)
        protobuf.struct.Struct.fromJavaProto(builder.build)
      }

    implicit val encodeStruct: Encoder[protobuf.struct.Struct] =
      Encoder.encodeJson.contramap { struct =>
        val printer = JsonFormat.printer()
        val jsonString = printer.print(Struct.toJavaProto(struct))
        io.circe.parser.parse(jsonString) match {
          case Right(json) => json
          case Left(error) => throw new IllegalStateException(s"Failed to parse JSON: $error")
        }
      }

    implicit val emptyCodec: Codec[com.google.protobuf.empty.Empty] =
      Codec.from(
        Decoder.decodeUnit.map(_ => com.google.protobuf.empty.Empty()),
        Encoder.encodeUnit.contramap[com.google.protobuf.empty.Empty](_ => ()),
      )

    implicit val encodeIdentifier: Encoder[com.daml.ledger.api.v2.value.Identifier] =
      Encoder.encodeString.contramap { identifier =>
        IdentifierConverter.toJson(identifier)
      }

    implicit val decodeIdentifier: Decoder[com.daml.ledger.api.v2.value.Identifier] =
      Decoder.decodeString.map(IdentifierConverter.fromJson)

    implicit val jsEvent: Codec[JsEvent.Event] = deriveConfiguredCodec
    implicit val jsCreatedEvent: Codec[JsEvent.CreatedEvent] = deriveConfiguredCodec
    implicit val jsArchivedEvent: Codec[JsEvent.ArchivedEvent] = deriveConfiguredCodec
    implicit val jsExercisedEvent: Codec[JsEvent.ExercisedEvent] = deriveConfiguredCodec

    implicit val jsInterfaceView: Codec[JsInterfaceView] = deriveConfiguredCodec

    implicit val jsTransactionTree: Codec[JsTransactionTree] = deriveConfiguredCodec

    implicit val jsSubmitAndWaitForTransactionTreeResponse
        : Codec[JsSubmitAndWaitForTransactionTreeResponse] = deriveConfiguredCodec
    implicit val jsTreeEvent: Codec[JsTreeEvent.TreeEvent] = deriveConfiguredCodec
    implicit val jsExercisedTreeEvent: Codec[JsTreeEvent.ExercisedTreeEvent] = deriveConfiguredCodec
    implicit val jsCreatedTreeEvent: Codec[JsTreeEvent.CreatedTreeEvent] = deriveConfiguredCodec

    implicit val offsetCheckpoint: Codec[offset_checkpoint.OffsetCheckpoint] = deriveRelaxedCodec
    implicit val offsetCheckpointSynchronizerTime: Codec[offset_checkpoint.SynchronizerTime] =
      deriveRelaxedCodec

    implicit val grpcStatusEncoder: Encoder[com.google.rpc.status.Status] = Encoder.instance {
      status =>
        import io.circe.syntax.*
        Json.obj(
          "code" -> status.code.asJson,
          "message" -> status.message.asJson,
          "details" -> status.details.asJson,
        )
    }

    implicit val grpcStatusDecoder: Decoder[com.google.rpc.status.Status] = Decoder.instance {
      cursor =>
        for {
          code <- cursor.downField("code").as[Int]
          message <- cursor.downField("message").as[String]
          details <- cursor.downField("details").as[Seq[com.google.protobuf.any.Any]]
        } yield com.google.rpc.status.Status(code, message, details)
    }

    implicit val grpcAnyEncoder: Encoder[com.google.protobuf.any.Any] = Encoder.instance { any =>
      import io.circe.syntax.*
      def decodeAny(source: com.google.protobuf.any.Any): String =
        try {
          source.typeUrl match {
            case "type.googleapis.com/google.rpc.ErrorInfo" =>
              ErrorInfo.parseFrom(source.value.toByteArray).toString
            case "type.googleapis.com/google.rpc.RetryInfo" =>
              RetryInfo.parseFrom(source.value.toByteArray).toString
            case _ =>
              "Unknown type for decoding"
          }
        } catch {
          case e: Exception => "Failed to decode: " + e.getMessage
        }
      Json.obj(
        "typeUrl" -> any.typeUrl.asJson,
        "value" -> Base64.getEncoder.encodeToString(any.value.toByteArray).asJson,
        "unknownFields" -> any.unknownFields.asJson,
        "valueDecoded" -> decodeAny(any).asJson,
      )
    }

    implicit val grpcAnyDecoder: Decoder[com.google.protobuf.any.Any] = Decoder.instance { cursor =>
      for {
        typeUrl <- cursor.downField("typeUrl").as[String]
        value <- cursor.downField("value").as[ByteString]
        unknownFields <- cursor.downField("unknownFields").as[scalapb.UnknownFieldSet]
      } yield com.google.protobuf.any.Any(typeUrl, value, unknownFields)
    }

    // Schema mappings are added to align generated tapir docs with a circe mapping of ADTs
    implicit val byteStringSchema: Schema[protobuf.ByteString] = Schema(
      SchemaType.SString()
    )

    implicit val unknownFieldSetMapSchema: Schema[Map[Int, UnknownFieldSet.Field]] =
      Schema.schemaForMap[Int, UnknownFieldSet.Field](_.toString)
    implicit val unknownFieldSetSchema: Schema[scalapb.UnknownFieldSet] =
      Schema.derived[scalapb.UnknownFieldSet]

    implicit val identifierSchema: Schema[com.daml.ledger.api.v2.value.Identifier] = Schema.string

    implicit val durationSchema: Schema[protobuf.duration.Duration] =
      implicitly[Derived[Schema[protobuf.duration.Duration]]].value
        .modify(_.unknownFields)(
          _.copy(isOptional = true).description(
            "This field is automatically added as part of protobuf to json mapping"
          )
        )

    implicit val timestampSchema: Schema[protobuf.timestamp.Timestamp] = Schema.string

    implicit val structSchema: Schema[protobuf.struct.Struct] = Schema.any

    implicit val emptySchema: Schema[com.google.protobuf.empty.Empty] =
      Schema(
        schemaType = SchemaType.SProduct[com.google.protobuf.empty.Empty](List.empty),
        name = Some(Schema.SName("Empty")),
      )

    implicit val anySchema: Schema[com.google.protobuf.any.Any] = Schema(
      SchemaType.SProduct[
        com.google.protobuf.any.Any
      ](
        List(
          SProductField(FieldName("typeUrl"), Schema.string, a => Option(a.typeUrl)),
          SProductField(FieldName("value"), Schema.string, a => Option(a.value.toString)),
          SProductField(
            FieldName("unknownFields"),
            Schema.derived[scalapb.UnknownFieldSet],
            a => Option(a.unknownFields),
          ),
          SProductField(
            FieldName("valueDecoded"),
            Schema
              .schemaForOption[String](
                Schema.string
              )
              .as[String],
            _ => Option(""),
          ), // valueDecoded is now optional
        )
      ),
      Some(SName("ProtoAny")),
    )

    implicit val statusSchema: Schema[com.google.rpc.status.Status] = {
      val baseSchema = Schema.derived[com.google.rpc.status.Status]
      // modified to preserve backwards compatibility with existing clients
      val adjustedType = baseSchema.schemaType match {
        case SProduct(fields) =>
          SProduct(
            fields.filter(
              _.name.name != "unknownFields"
            ) // This field is not needed and was introduced to generated code by mistake
          )
        case _ => sys.error("Error in JsSchema openapi generation expected SProduct")
      }
      baseSchema
        .name(Some(SName("JsStatus")))
        .copy(schemaType = adjustedType)

    }

    implicit val jsEventCreatedSchema: Schema[JsEvent.CreatedEvent] = Schema.derived

    @SuppressWarnings(Array("org.wartremover.warts.Product", "org.wartremover.warts.Serializable"))
    implicit val jsEventSchema: Schema[JsEvent.Event] =
      Schema.oneOfWrapped

    @SuppressWarnings(Array("org.wartremover.warts.Product", "org.wartremover.warts.Serializable"))
    implicit val jsTreeEventSchema: Schema[JsTreeEvent.TreeEvent] =
      Schema.oneOfWrapped

    implicit val eventsByIdSchema: Schema[Map[Int, JsTreeEvent.TreeEvent]] =
      Schema.schemaForMap[Int, JsTreeEvent.TreeEvent](_.toString)

    implicit val jsTransactionTreeSchema: Schema[JsTransactionTree] =
      Schema.derived

    implicit val identifierFilterSchema
        : Schema[transaction_filter.CumulativeFilter.IdentifierFilter] =
      Schema.oneOfWrapped

    implicit val valueSchema: Schema[com.google.protobuf.struct.Value] = Schema.any

  }

  object Crypto {

    implicit val signingKeySpecSchema: Schema[crypto.SigningKeySpec] = Schema.string
      .encodedExample("SIGNING_KEY_SPEC_EC_CURVE25519")
      .description("Specifies the key schema used for the signature.")

    implicit val signingKeySpecEncoder: Encoder[crypto.SigningKeySpec] = stringEncoderForEnum()
    implicit val signingKeySpecDecoder: Decoder[crypto.SigningKeySpec] = stringDecoderForEnum()

    implicit val cryptoKeyFormatSchema: Schema[crypto.CryptoKeyFormat] = Schema.string
      .encodedExample("CRYPTO_KEY_FORMAT_DER_X509_SUBJECT_PUBLIC_KEY_INFO")
      .description("Specifies the format of the cryptographic key.")
    implicit val cryptoKeyFormatEncoder: Encoder[crypto.CryptoKeyFormat] = stringEncoderForEnum()
    implicit val cryptoKeyFormatDecoder: Decoder[crypto.CryptoKeyFormat] = stringDecoderForEnum()
    implicit val signingPublicKey: Codec[crypto.SigningPublicKey] =
      deriveRelaxedCodec[crypto.SigningPublicKey]

  }

}

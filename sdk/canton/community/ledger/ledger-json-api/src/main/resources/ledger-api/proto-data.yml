fileComments:
  admin/command_inspection_service.proto:
    messages:
      CommandStatus:
        message:
          comments: null
          fieldComments:
            state: ''
            completion: ''
            updates: ''
            completed: ''
            request_statistics: ''
            started: ''
            commands: ''
      CommandUpdates:
        message:
          comments: null
          fieldComments:
            archived: ''
            looked_up_by_key: ''
            created: ''
            fetched: ''
            exercised: ''
      Contract:
        message:
          comments: null
          fieldComments:
            template_id: |-
              The identifier of the template used to create the contract.
              The identifier uses the package-id reference format.

              Required
            contract_id: |-
              The contract's ID

              Required
            contract_key: |-
              The contract key, if defined

              Optional
      GetCommandStatusRequest:
        message:
          comments: null
          fieldComments:
            command_id_prefix: optional filter by command id
            state: optional filter by state
            limit: optional limit of returned statuses, defaults to 100
      GetCommandStatusResponse:
        message:
          comments: null
          fieldComments:
            command_status: ''
      RequestStatistics:
        message:
          comments: null
          fieldComments:
            envelopes: ''
            request_size: ''
            recipients: ''
    oneOfs:
      CommandStatus: {}
      CommandUpdates: {}
      Contract: {}
      GetCommandStatusRequest: {}
      GetCommandStatusResponse: {}
      RequestStatistics: {}
    services:
      CommandInspectionService:
      - name: GetCommandStatus
        comments: |-
          Inquire about the status of a command.
          This service is used for debugging only. The command status is only tracked in memory and is not persisted.
          The service can be used to understand the failure status and the structure of a command.
          Requires admin privileges
          The service is alpha without backward compatibility guarantees.
  admin/identity_provider_config_service.proto:
    messages:
      CreateIdentityProviderConfigRequest:
        message:
          comments: null
          fieldComments:
            identity_provider_config: Required
      CreateIdentityProviderConfigResponse:
        message:
          comments: null
          fieldComments:
            identity_provider_config: ''
      DeleteIdentityProviderConfigRequest:
        message:
          comments: null
          fieldComments:
            identity_provider_id: |-
              The identity provider config to delete.
              Required
      DeleteIdentityProviderConfigResponse:
        message:
          comments: Does not (yet) contain any data.
          fieldComments: {}
      GetIdentityProviderConfigRequest:
        message:
          comments: null
          fieldComments:
            identity_provider_id: Required
      GetIdentityProviderConfigResponse:
        message:
          comments: null
          fieldComments:
            identity_provider_config: ''
      IdentityProviderConfig:
        message:
          comments: null
          fieldComments:
            audience: |-
              Specifies the audience of the JWT token.
              When set, the callers using JWT tokens issued by this identity provider are allowed to get an access
              only if the "aud" claim includes the string specified here
              Optional,
              Modifiable
            issuer: |-
              Specifies the issuer of the JWT token.
              The issuer value is a case sensitive URL using the https scheme that contains scheme, host,
              and optionally, port number and path components and no query or fragment components.
              Required
              Modifiable
            identity_provider_id: |-
              The identity provider identifier
              Must be a valid LedgerString (as describe in ``value.proto``).
              Required
            jwks_url: |-
              The JWKS (JSON Web Key Set) URL.
              The Ledger API uses JWKs (JSON Web Keys) from the provided URL to verify that the JWT has been
              signed with the loaded JWK. Only RS256 (RSA Signature with SHA-256) signing algorithm is supported.
              Required
              Modifiable
            is_deactivated: |-
              When set, the callers using JWT tokens issued by this identity provider are denied all access
              to the Ledger API.
              Optional,
              Modifiable
      ListIdentityProviderConfigsRequest:
        message:
          comments: null
          fieldComments: {}
      ListIdentityProviderConfigsResponse:
        message:
          comments: null
          fieldComments:
            identity_provider_configs: ''
      UpdateIdentityProviderConfigRequest:
        message:
          comments: null
          fieldComments:
            identity_provider_config: |-
              The identity provider config to update.
              Required,
              Modifiable
            update_mask: |-
              An update mask specifies how and which properties of the ``IdentityProviderConfig`` message are to be updated.
              An update mask consists of a set of update paths.
              A valid update path points to a field or a subfield relative to the ``IdentityProviderConfig`` message.
              A valid update mask must:

              1. contain at least one update path,
              2. contain only valid update paths.

              Fields that can be updated are marked as ``Modifiable``.
              For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
              Required
      UpdateIdentityProviderConfigResponse:
        message:
          comments: null
          fieldComments:
            identity_provider_config: Updated identity provider config
    oneOfs:
      CreateIdentityProviderConfigRequest: {}
      CreateIdentityProviderConfigResponse: {}
      DeleteIdentityProviderConfigRequest: {}
      DeleteIdentityProviderConfigResponse: {}
      GetIdentityProviderConfigRequest: {}
      GetIdentityProviderConfigResponse: {}
      IdentityProviderConfig: {}
      ListIdentityProviderConfigsRequest: {}
      ListIdentityProviderConfigsResponse: {}
      UpdateIdentityProviderConfigRequest: {}
      UpdateIdentityProviderConfigResponse: {}
    services:
      IdentityProviderConfigService:
      - name: CreateIdentityProviderConfig
        comments: |-
          Create a new identity provider configuration.
          The request will fail if the maximum allowed number of separate configurations is reached.
      - name: GetIdentityProviderConfig
        comments: Get the identity provider configuration data by id.
      - name: UpdateIdentityProviderConfig
        comments: |-
          Update selected modifiable attribute of an identity provider config resource described
          by the ``IdentityProviderConfig`` message.
      - name: ListIdentityProviderConfigs
        comments: List all existing identity provider configurations.
      - name: DeleteIdentityProviderConfig
        comments: Delete an existing identity provider configuration.
  admin/object_meta.proto:
    messages:
      ObjectMeta:
        message:
          comments: |-
            Represents metadata corresponding to a participant resource (e.g. a participant user or participant local information about a party).

            Based on ``ObjectMeta`` meta used in Kubernetes API.
            See https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L640
          fieldComments:
            resource_version: |-
              An opaque, non-empty value, populated by a participant server which represents the internal version of the resource
              this ``ObjectMeta`` message is attached to. The participant server will change it to a unique value each time the corresponding resource is updated.
              You must not rely on the format of resource version. The participant server might change it without notice.
              You can obtain the newest resource version value by issuing a read request.
              You may use it for concurrent change detection by passing it back unmodified in an update request.
              The participant server will then compare the passed value with the value maintained by the system to determine
              if any other updates took place since you had read the resource version.
              Upon a successful update you are guaranteed that no other update took place during your read-modify-write sequence.
              However, if another update took place during your read-modify-write sequence then your update will fail with an appropriate error.
              Concurrent change control is optional. It will be applied only if you include a resource version in an update request.
              When creating a new instance of a resource you must leave the resource version empty.
              Its value will be populated by the participant server upon successful resource creation.
              Optional
            annotations: |-
              A set of modifiable key-value pairs that can be used to represent arbitrary, client-specific metadata.
              Constraints:

              1. The total size over all keys and values cannot exceed 256kb in UTF-8 encoding.
              2. Keys are composed of an optional prefix segment and a required name segment such that:

                 - key prefix, when present, must be a valid DNS subdomain with at most 253 characters, followed by a '/' (forward slash) character,
                 - name segment must have at most 63 characters that are either alphanumeric ([a-z0-9A-Z]), or a '.' (dot), '-' (dash) or '_' (underscore);
                   and it must start and end with an alphanumeric character.

              3. Values can be any non-empty strings.

              Keys with empty prefix are reserved for end-users.
              Properties set by external tools or internally by the participant server must use non-empty key prefixes.
              Duplicate keys are disallowed by the semantics of the protobuf3 maps.
              See: https://developers.google.com/protocol-buffers/docs/proto3#maps
              Annotations may be a part of a modifiable resource.
              Use the resource's update RPC to update its annotations.
              In order to add a new annotation or update an existing one using an update RPC, provide the desired annotation in the update request.
              In order to remove an annotation using an update RPC, provide the target annotation's key but set its value to the empty string in the update request.
              Optional
              Modifiable
    oneOfs:
      ObjectMeta: {}
    services: {}
  admin/package_management_service.proto:
    messages:
      ListKnownPackagesRequest:
        message:
          comments: null
          fieldComments: {}
      ListKnownPackagesResponse:
        message:
          comments: null
          fieldComments:
            package_details: |-
              The details of all Daml-LF packages known to backing participant.
              Required
      PackageDetails:
        message:
          comments: null
          fieldComments:
            name: Name of the package as defined by the package metadata
            package_id: |-
              The identity of the Daml-LF package.
              Must be a valid PackageIdString (as describe in ``value.proto``).
              Required
            version: Version of the package as defined by the package metadata
            package_size: |-
              Size of the package in bytes.
              The size of the package is given by the size of the ``daml_lf``
              ArchivePayload. See further details in ``daml_lf.proto``.
              Required
            known_since: |-
              Indicates since when the package is known to the backing participant.
              Required
      UpdateVettedPackagesRequest:
        message:
          comments: null
          fieldComments:
            synchronizer_id: |-
              If set, the requested changes will take place on the specified
              synchronizer. If synchronizer_id is unset and the participant is only
              connected to a single synchronizer, that synchronizer will be used by
              default. If synchronizer_id is unset and the participant is connected to
              multiple synchronizers, the request will error out with
              PACKAGE_SERVICE_CANNOT_AUTODETECT_SYNCHRONIZER.

              Optional
            changes: |-
              Changes to apply to the current vetting state of the participant on the
              specified synchronizer. The changes are applied in order.
              Any package not changed will keep their previous vetting state.
            dry_run: |-
              If dry_run is true, then the changes are only prepared, but not applied. If
              a request would trigger an error when run (e.g. TOPOLOGY_DEPENDENCIES_NOT_VETTED),
              it will also trigger an error when dry_run.

              Use this flag to preview a change before applying it.
            expected_topology_serial: |-
              The serial of the last ``VettedPackages`` topology transaction of this
              participant and on this synchronizer.

              Execution of the request fails if this is not correct. Use this to guard
              against concurrent changes.

              If left unspecified, no validation is done against the last transaction's
              serial.

              Optional
            update_vetted_packages_force_flags: |-
              Controls whether potentially unsafe vetting updates are allowed.

              Optional, defaults to FORCE_FLAG_UNSPECIFIED.
      UpdateVettedPackagesResponse:
        message:
          comments: null
          fieldComments:
            past_vetted_packages: |-
              All vetted packages on this participant and synchronizer, before the
              specified changes. Empty if no vetting state existed beforehand.
            new_vetted_packages: All vetted packages on this participant and synchronizer,
              after the specified changes.
      UploadDarFileRequest:
        message:
          comments: null
          fieldComments:
            dar_file: |-
              Contains a Daml archive DAR file, which in turn is a jar like zipped
              container for ``daml_lf`` archives. See further details in
              ``daml_lf.proto``.
              Required
            submission_id: |-
              Unique submission identifier.
              Optional, defaults to a random identifier.
            vetting_change: How to vet packages in the DAR being uploaded
            synchronizer_id: |-
              Only used if VettingChange is set to VETTING_CHANGE_VET_ALL_PACKAGES, in
              order to specify which synchronizer to vet on.

              If synchronizer_id is set, the synchronizer with this ID will be used. If
              synchronizer_id is unset and the participant is only connected to a single
              synchronizer, that synchronizer will be used by default. If synchronizer_id
              is unset and the participant is connected to multiple synchronizers, the
              request will error out with PACKAGE_SERVICE_CANNOT_AUTODETECT_SYNCHRONIZER.

              Optional
      UploadDarFileResponse:
        message:
          comments: A message that is received when the upload operation succeeded.
          fieldComments: {}
      ValidateDarFileRequest:
        message:
          comments: |-
            Performs the same checks that UploadDarFileRequest would perform, but doesn't
            upload the DAR.
          fieldComments:
            dar_file: |-
              Contains a Daml archive DAR file, which in turn is a jar like zipped
              container for ``daml_lf`` archives. See further details in
              ``daml_lf.proto``.
              Required
            submission_id: |-
              Unique submission identifier.
              Optional, defaults to a random identifier.
            synchronizer_id: |-
              If synchronizer_id is set, the synchronizer with this ID will be used. If
              synchronizer_id is unset and the participant is only connected to a single
              synchronizer, that synchronizer will be used by default. If synchronizer_id
              is unset and the participant is connected to multiple synchronizers, the
              request will error out with PACKAGE_SERVICE_CANNOT_AUTODETECT_SYNCHRONIZER.

              Optional
      ValidateDarFileResponse:
        message:
          comments: null
          fieldComments: {}
      VettedPackagesChange:
        message:
          comments: A change to the set of vetted packages.
          fieldComments:
            vet: Add packages to or update packages in the set of vetted packages.
            unvet: Remove packages from the set of vetted packages.
      VettedPackagesRef:
        message:
          comments: |-
            A reference to identify one or more packages.

            A reference matches a package if its ``package_id`` matches the package's ID,
            its ``package_name`` matches the package's name, and its ``package_version``
            matches the package's version. If an attribute in the reference is left
            unspecified (i.e. as an empty string), that attribute is treated as a
            wildcard. At a minimum, ``package_id`` or the ``package_name`` must be
            specified.

            If a reference does not match any package, the reference is considered
            unresolved and the entire update request is rejected.
          fieldComments:
            package_id: |-
              Package's package id must be the same as this field.
              Optional
            package_name: |-
              Package's name must be the same as this field.
              Optional
            package_version: |-
              Package's version must be the same as this field.
              Optional
    oneOfs:
      ListKnownPackagesRequest: {}
      ListKnownPackagesResponse: {}
      PackageDetails: {}
      UpdateVettedPackagesRequest: {}
      UpdateVettedPackagesResponse: {}
      UploadDarFileRequest: {}
      UploadDarFileResponse: {}
      ValidateDarFileRequest: {}
      ValidateDarFileResponse: {}
      VettedPackagesChange:
        operation:
          message:
            comments: null
            fieldComments:
              vet: Add packages to or update packages in the set of vetted packages.
              unvet: Remove packages from the set of vetted packages.
      VettedPackagesRef: {}
    services:
      PackageManagementService:
      - name: ListKnownPackages
        comments: Returns the details of all Daml-LF packages known to the backing
          participant.
      - name: UploadDarFile
        comments: |-
          Upload a DAR file to the participant.

          If vetting is enabled in the request, the DAR is checked for upgrade compatibility
          with the set of the already vetted packages on the target vetting synchronizer
          See UploadDarFileRequest for details regarding vetting and the target vetting synchronizer.
      - name: ValidateDarFile
        comments: |-
          Validates the DAR and checks the upgrade compatibility of the DAR's packages
          with the set of the already vetted packages on the target vetting synchronizer.
          See ValidateDarFileRequest for details regarding the target vetting synchronizer.

          The operation has no effect on the state of the participant or the Canton ledger:
          the DAR payload and its packages are not persisted neither are the packages vetted.
      - name: UpdateVettedPackages
        comments: Update the vetted packages of this participant
  admin/participant_pruning_service.proto:
    messages:
      PruneRequest:
        message:
          comments: null
          fieldComments:
            prune_up_to: |-
              Inclusive valid absolute offset (positive integer) up to which the ledger is to be pruned.
              By default the following data is pruned:

              1. All normal and divulged contracts that have been archived before
                 `prune_up_to`.
              2. All transaction events and completions before `prune_up_to`
              3. All immediately divulged contracts created before `prune_up_to` independent of whether
                 they were archived before `prune_up_to`.
            submission_id: |-
              Unique submission identifier.
              Optional, defaults to a random identifier, used for logging.
            prune_all_divulged_contracts: |-
              Deprecated flag used to prune all immediately and retroactively divulged contracts.
              It is a no-op since the divulged contracts are pruned along with the deactivated contracts.
      PruneResponse:
        message:
          comments: null
          fieldComments: {}
    oneOfs:
      PruneRequest: {}
      PruneResponse: {}
    services:
      ParticipantPruningService:
      - name: Prune
        comments: |-
          Prune the ledger specifying the offset before and at which ledger transactions should be removed. Only returns when
          the potentially long-running prune request ends successfully or with an error.
  admin/party_management_service.proto:
    messages:
      AllocateExternalPartyRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``'
          fieldComments:
            synchronizer: |-
              TODO(#27670) support synchronizer aliases
              Synchronizer ID on which to onboard the party
              Required
            onboarding_transactions: |-
              TopologyTransactions to onboard the external party
              Can contain:
              - A namespace for the party.
              This can be either a single NamespaceDelegation,
              or DecentralizedNamespaceDefinition along with its authorized namespace owners in the form of NamespaceDelegations.
              May be provided, if so it must be fully authorized by the signatures in this request combined with the existing topology state.
              - A PartyToKeyMapping to register the party's signing keys.
              May be provided, if so it must be fully authorized by the signatures in this request combined with the existing topology state.
              - A PartyToParticipant to register the hosting relationship of the party.
              Must be provided.
              Required
            multi_hash_signatures: |-
              Optional signatures of the combined hash of all onboarding_transactions
              This may be used instead of providing signatures on each individual transaction
            identity_provider_id: |-
              The id of the ``Identity Provider``
              If not set, assume the party is managed by the default identity provider.
              Optional
      AllocateExternalPartyResponse:
        message:
          comments: null
          fieldComments:
            party_id: ''
      AllocatePartyRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``'
          fieldComments:
            synchronizer_id: |-
              The synchronizer, on which the party should be allocated.
              For backwards compatibility, this field may be omitted, if the participant is connected to only one synchronizer.
              Otherwise a synchronizer must be specified.
              Optional
            local_metadata: |-
              Formerly "display_name"
              Participant-local metadata to be stored in the ``PartyDetails`` of this newly allocated party.
              Optional
            user_id: |-
              The user who will get the act_as rights to the newly allocated party.
              If set to an empty string (the default), no user will get rights to the party.
              Optional
            party_id_hint: |-
              A hint to the participant which party ID to allocate. It can be
              ignored.
              Must be a valid PartyIdString (as described in ``value.proto``).
              Optional
            identity_provider_id: |-
              The id of the ``Identity Provider``
              Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
      AllocatePartyResponse:
        message:
          comments: null
          fieldComments:
            party_details: ''
      GenerateExternalPartyTopologyRequest:
        message:
          comments: null
          fieldComments:
            synchronizer: |-
              TODO(#27670) support synchronizer aliases
              Required: synchronizer-id for which we are building this request.
            other_confirming_participant_uids: 'Optional: other participant ids which
              should be confirming for this party'
            public_key: 'Required: public key'
            observing_participant_uids: 'Optional: other observing participant ids
              for this party'
            local_participant_observation_only: 'Optional: if true, then the local
              participant will only be observing, not confirming. Default false.'
            confirmation_threshold: 'Optional: Confirmation threshold >= 1 for the
              party. Defaults to all available confirmers (or if set to 0).'
            party_hint: 'Required: the actual party id will be constructed from this
              hint and a fingerprint of the public key'
      GenerateExternalPartyTopologyResponse:
        message:
          comments: Response message with topology transactions and the multi-hash
            to be signed.
          fieldComments:
            party_id: the generated party id
            public_key_fingerprint: the fingerprint of the supplied public key
            topology_transactions: |-
              The serialized topology transactions which need to be signed and submitted as part of the allocate party process
              Note that the serialization includes the versioning information. Therefore, the transaction here is serialized
              as an `UntypedVersionedMessage` which in turn contains the serialized `TopologyTransaction` in the version
              supported by the synchronizer.
            multi_hash: the multi-hash which may be signed instead of each individual
              transaction
      GetParticipantIdRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin)``'
          fieldComments: {}
      GetParticipantIdResponse:
        message:
          comments: null
          fieldComments:
            participant_id: |-
              Identifier of the participant, which SHOULD be globally unique.
              Must be a valid LedgerString (as describe in ``value.proto``).
      GetPartiesRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``'
          fieldComments:
            parties: |-
              The stable, unique identifier of the Daml parties.
              Must be valid PartyIdStrings (as described in ``value.proto``).
              Required
            identity_provider_id: |-
              The id of the ``Identity Provider`` whose parties should be retrieved.
              Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
      GetPartiesResponse:
        message:
          comments: null
          fieldComments:
            party_details: |-
              The details of the requested Daml parties by the participant, if known.
              The party details may not be in the same order as requested.
              Required
      ListKnownPartiesRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``'
          fieldComments:
            page_token: |-
              Pagination token to determine the specific page to fetch. Using the token guarantees that parties on a subsequent
              page are all lexically greater than the last party on a previous page. Server does not store intermediate results
              between calls chained by a series of page tokens. As a consequence, if new parties are being added and a page is
              requested twice using the same token, more parties can be returned on the second call.
              Leave empty to fetch the first page.
              Optional
            page_size: |-
              Maximum number of results to be returned by the server. The server will return no more than that many results,
              but it might return fewer. If the page_size is 0, the server will decide the number of results to be returned.
              If the page_size exceeds the maximum supported by the server, an error will be returned. To obtain the server's
              maximum consult the PartyManagementFeature descriptor available in the VersionService.
              Optional
            identity_provider_id: |-
              The id of the ``Identity Provider`` whose parties should be retrieved.
              Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
      ListKnownPartiesResponse:
        message:
          comments: null
          fieldComments:
            party_details: |-
              The details of all Daml parties known by the participant.
              Required
            next_page_token: |-
              Pagination token to retrieve the next page.
              Empty, if there are no further results.
      PartyDetails:
        message:
          comments: null
          fieldComments:
            party: |-
              The stable unique identifier of a Daml party.
              Must be a valid PartyIdString (as described in ``value.proto``).
              Required
            is_local: |-
              true if party is hosted by the participant and the party shares the same identity provider as the user issuing the request.
              Optional
            local_metadata: |-
              Participant-local metadata of this party.
              Optional,
              Modifiable
            identity_provider_id: |-
              The id of the ``Identity Provider``
              Optional, if not set, there could be 3 options:

              1. the party is managed by the default identity provider.
              2. party is not hosted by the participant.
              3. party is hosted by the participant, but is outside of the user's identity provider.
      UpdatePartyDetailsRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(party_details.identity_provider_id)``'
          fieldComments:
            party_details: |-
              Party to be updated
              Required,
              Modifiable
            update_mask: |-
              An update mask specifies how and which properties of the ``PartyDetails`` message are to be updated.
              An update mask consists of a set of update paths.
              A valid update path points to a field or a subfield relative to the ``PartyDetails`` message.
              A valid update mask must:

              1. contain at least one update path,
              2. contain only valid update paths.

              Fields that can be updated are marked as ``Modifiable``.
              An update path can also point to non-``Modifiable`` fields such as 'party' and 'local_metadata.resource_version'
              because they are used:

              1. to identify the party details resource subject to the update,
              2. for concurrent change control.

              An update path can also point to non-``Modifiable`` fields such as 'is_local'
              as long as the values provided in the update request match the server values.
              Examples of update paths: 'local_metadata.annotations', 'local_metadata'.
              For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
              For similar Ledger API see ``com.daml.ledger.api.v2.admin.UpdateUserRequest``.
              Required
      UpdatePartyDetailsResponse:
        message:
          comments: null
          fieldComments:
            party_details: Updated party details
      UpdatePartyIdentityProviderIdRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin)``'
          fieldComments:
            party: Party to update
            source_identity_provider_id: Current identity provider id of the party
            target_identity_provider_id: Target identity provider id of the party
      UpdatePartyIdentityProviderIdResponse:
        message:
          comments: null
          fieldComments: {}
    oneOfs:
      AllocateExternalPartyRequest: {}
      AllocateExternalPartyResponse: {}
      AllocatePartyRequest: {}
      AllocatePartyResponse: {}
      GenerateExternalPartyTopologyRequest: {}
      GenerateExternalPartyTopologyResponse: {}
      GetParticipantIdRequest: {}
      GetParticipantIdResponse: {}
      GetPartiesRequest: {}
      GetPartiesResponse: {}
      ListKnownPartiesRequest: {}
      ListKnownPartiesResponse: {}
      PartyDetails: {}
      UpdatePartyDetailsRequest: {}
      UpdatePartyDetailsResponse: {}
      UpdatePartyIdentityProviderIdRequest: {}
      UpdatePartyIdentityProviderIdResponse: {}
    services:
      PartyManagementService:
      - name: GetParticipantId
        comments: |-
          Return the identifier of the participant.
          All horizontally scaled replicas should return the same id.
          daml-on-kv-ledger: returns an identifier supplied on command line at launch time
          canton: returns globally unique identifier of the participant
      - name: GetParties
        comments: |-
          Get the party details of the given parties. Only known parties will be
          returned in the list.
      - name: ListKnownParties
        comments: |-
          List the parties known by the participant.
          The list returned contains parties whose ledger access is facilitated by
          the participant and the ones maintained elsewhere.
      - name: AllocateParty
        comments: |-
          Allocates a new party on a ledger and adds it to the set managed by the participant.
          Caller specifies a party identifier suggestion, the actual identifier
          allocated might be different and is implementation specific.
          Caller can specify party metadata that is stored locally on the participant.
          This call may:

          - Succeed, in which case the actual allocated identifier is visible in
            the response.
          - Respond with a gRPC error

          daml-on-kv-ledger: suggestion's uniqueness is checked by the validators in
          the consensus layer and call rejected if the identifier is already present.
          canton: completely different globally unique identifier is allocated.
          Behind the scenes calls to an internal protocol are made. As that protocol
          is richer than the surface protocol, the arguments take implicit values
          The party identifier suggestion must be a valid party name. Party names are required to be non-empty US-ASCII strings built from letters, digits, space,
          colon, minus and underscore limited to 255 chars
      - name: AllocateExternalParty
        comments: |-
          Alpha 3.3: Endpoint to allocate a new external party on a synchronizer

          Expected to be stable in 3.5

          The external party must be hosted (at least) on this node with either confirmation or observation permissions
          It can optionally be hosted on other nodes (then called a multi-hosted party).
          If hosted on additional nodes, explicit authorization of the hosting relationship must be performed on those nodes
          before the party can be used.
          Decentralized namespaces are supported but must be provided fully authorized by their owners.
          The individual owner namespace transactions can be submitted in the same call (fully authorized as well).
          In the simple case of a non-multi hosted, non-decentralized party, the RPC will return once the party is
          effectively allocated and ready to use, similarly to the AllocateParty behavior.
          For more complex scenarios applications may need to query the party status explicitly (only through the admin API as of now).
      - name: UpdatePartyDetails
        comments: |-
          Update selected modifiable participant-local attributes of a party details resource.
          Can update the participant's local information for local parties.
      - name: UpdatePartyIdentityProviderId
        comments: Update the assignment of a party from one IDP to another.
      - name: GenerateExternalPartyTopology
        comments: |-
          Alpha 3.3: Convenience endpoint to generate topology transactions for external signing

          Expected to be stable in 3.5

          You may use this endpoint to generate the common external topology transactions
          which can be signed externally and uploaded as part of the allocate party process

          Note that this request will create a normal namespace using the same key for the
          identity as for signing. More elaborate schemes such as multi-signature
          or decentralized parties require you to construct the topology transactions yourself.
  admin/user_management_service.proto:
    messages:
      CreateUserRequest:
        message:
          comments: |2-
             RPC requests and responses
            ///////////////////////////
             Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)``
          fieldComments:
            user: |-
              The user to create.
              Required
            rights: |-
              The rights to be assigned to the user upon creation,
              which SHOULD include appropriate rights for the ``user.primary_party``.
              Optional
      CreateUserResponse:
        message:
          comments: null
          fieldComments:
            user: Created user.
      DeleteUserRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``'
          fieldComments:
            user_id: |-
              The user to delete.
              Required
            identity_provider_id: |-
              The id of the ``Identity Provider``
              Optional, if not set, assume the user is managed by the default identity provider.
      DeleteUserResponse:
        message:
          comments: Does not (yet) contain any data.
          fieldComments: {}
      GetUserRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)
            OR IsAuthenticatedUser(user_id)``'
          fieldComments:
            user_id: |-
              The user whose data to retrieve.
              If set to empty string (the default), then the data for the authenticated user will be retrieved.
              Optional
            identity_provider_id: |-
              The id of the ``Identity Provider``
              Optional, if not set, assume the user is managed by the default identity provider.
      GetUserResponse:
        message:
          comments: null
          fieldComments:
            user: Retrieved user.
      GrantUserRightsRequest:
        message:
          comments: |-
            Add the rights to the set of rights granted to the user.

            Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
          fieldComments:
            user_id: |-
              The user to whom to grant rights.
              Required
            rights: |-
              The rights to grant.
              Optional
            identity_provider_id: |-
              The id of the ``Identity Provider``
              Optional, if not set, assume the user is managed by the default identity provider.
      GrantUserRightsResponse:
        message:
          comments: null
          fieldComments:
            newly_granted_rights: The rights that were newly granted by the request.
      ListUserRightsRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)
            OR IsAuthenticatedUser(user_id)``'
          fieldComments:
            user_id: |-
              The user for which to list the rights.
              If set to empty string (the default), then the rights for the authenticated user will be listed.
              Required
            identity_provider_id: |-
              The id of the ``Identity Provider``
              Optional, if not set, assume the user is managed by the default identity provider.
      ListUserRightsResponse:
        message:
          comments: null
          fieldComments:
            rights: All rights of the user.
      ListUsersRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``'
          fieldComments:
            page_token: |-
              Pagination token to determine the specific page to fetch.
              Leave empty to fetch the first page.
              Optional
            page_size: |-
              Maximum number of results to be returned by the server. The server will return no more than that many results, but it might return fewer.
              If 0, the server will decide the number of results to be returned.
              Optional
            identity_provider_id: |-
              The id of the ``Identity Provider``
              Optional, if not set, assume the user is managed by the default identity provider.
      ListUsersResponse:
        message:
          comments: null
          fieldComments:
            users: A subset of users of the participant node that fit into this page.
            next_page_token: |-
              Pagination token to retrieve the next page.
              Empty, if there are no further results.
      RevokeUserRightsRequest:
        message:
          comments: |-
            Remove the rights from the set of rights granted to the user.

            Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
          fieldComments:
            user_id: |-
              The user from whom to revoke rights.
              Required
            rights: |-
              The rights to revoke.
              Optional
            identity_provider_id: |-
              The id of the ``Identity Provider``
              Optional, if not set, assume the user is managed by the default identity provider.
      RevokeUserRightsResponse:
        message:
          comments: null
          fieldComments:
            newly_revoked_rights: The rights that were actually revoked by the request.
      Right:
        message:
          comments: A right granted to a user.
          fieldComments:
            can_execute_as: The user can prepare and execute submissions as a specific
              party.
            can_execute_as_any_party: The user can prepare and execute submissions
              as any party on a participant.
            can_read_as_any_party: The user can read as any party on a participant
            identity_provider_admin: The user can administer users and parties assigned
              to the same identity provider as the one of the user.
            can_read_as: The user can read ledger data visible to a specific party.
            participant_admin: The user can administer the participant node.
            can_act_as: The user can act as a specific party.
      UpdateUserIdentityProviderIdRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin)``'
          fieldComments:
            user_id: User to update
            source_identity_provider_id: Current identity provider ID of the user
            target_identity_provider_id: Target identity provider ID of the user
      UpdateUserIdentityProviderIdResponse:
        message:
          comments: null
          fieldComments: {}
      UpdateUserRequest:
        message:
          comments: 'Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)``'
          fieldComments:
            user: |-
              The user to update.
              Required,
              Modifiable
            update_mask: |-
              An update mask specifies how and which properties of the ``User`` message are to be updated.
              An update mask consists of a set of update paths.
              A valid update path points to a field or a subfield relative to the ``User`` message.
              A valid update mask must:

              1. contain at least one update path,
              2. contain only valid update paths.

              Fields that can be updated are marked as ``Modifiable``.
              An update path can also point to a non-``Modifiable`` fields such as 'id' and 'metadata.resource_version'
              because they are used:

              1. to identify the user resource subject to the update,
              2. for concurrent change control.

              Examples of valid update paths: 'primary_party', 'metadata', 'metadata.annotations'.
              For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
              For similar Ledger API see ``com.daml.ledger.api.v2.admin.UpdatePartyDetailsRequest``.
              Required
      UpdateUserResponse:
        message:
          comments: null
          fieldComments:
            user: Updated user
      User:
        message:
          comments: |2-
             Users and rights
            /////////////////
             Users are used to dynamically manage the rights given to Daml applications.
             They are stored and managed per participant node.
          fieldComments:
            primary_party: |-
              The primary party as which this user reads and acts by default on the ledger
              *provided* it has the corresponding ``CanReadAs(primary_party)`` or
              ``CanActAs(primary_party)`` rights.
              Ledger API clients SHOULD set this field to a non-empty value for all users to
              enable the users to act on the ledger using their own Daml party.
              Users for participant administrators MAY have an associated primary party.
              Optional,
              Modifiable
            id: |-
              The user identifier, which must be a non-empty string of at most 128
              characters that are either alphanumeric ASCII characters or one of the symbols "@^$.!`-#+'~_|:".
              Required
            is_deactivated: |-
              When set, then the user is denied all access to the Ledger API.
              Otherwise, the user has access to the Ledger API as per the user's rights.
              Optional,
              Modifiable
            metadata: |-
              The metadata of this user.
              Note that the ``metadata.resource_version`` tracks changes to the properties described by the ``User`` message and not the user's rights.
              Optional,
              Modifiable
            identity_provider_id: |-
              The ID of the identity provider configured by ``Identity Provider Config``
              Optional, if not set, assume the user is managed by the default identity provider.
    oneOfs:
      CreateUserRequest: {}
      CreateUserResponse: {}
      DeleteUserRequest: {}
      DeleteUserResponse: {}
      GetUserRequest: {}
      GetUserResponse: {}
      GrantUserRightsRequest: {}
      GrantUserRightsResponse: {}
      ListUserRightsRequest: {}
      ListUserRightsResponse: {}
      ListUsersRequest: {}
      ListUsersResponse: {}
      RevokeUserRightsRequest: {}
      RevokeUserRightsResponse: {}
      Right:
        kind:
          message:
            comments: Required
            fieldComments:
              can_execute_as: The user can prepare and execute submissions as a specific
                party.
              can_execute_as_any_party: The user can prepare and execute submissions
                as any party on a participant.
              can_read_as_any_party: The user can read as any party on a participant
              identity_provider_admin: The user can administer users and parties assigned
                to the same identity provider as the one of the user.
              can_read_as: The user can read ledger data visible to a specific party.
              participant_admin: The user can administer the participant node.
              can_act_as: The user can act as a specific party.
      UpdateUserIdentityProviderIdRequest: {}
      UpdateUserIdentityProviderIdResponse: {}
      UpdateUserRequest: {}
      UpdateUserResponse: {}
      User: {}
    services:
      UserManagementService:
      - name: CreateUser
        comments: Create a new user.
      - name: GetUser
        comments: Get the user data of a specific user or the authenticated user.
      - name: UpdateUser
        comments: Update selected modifiable attribute of a user resource described
          by the ``User`` message.
      - name: DeleteUser
        comments: Delete an existing user and all its rights.
      - name: ListUsers
        comments: List all existing users.
      - name: GrantUserRights
        comments: |-
          Grant rights to a user.
          Granting rights does not affect the resource version of the corresponding user.
      - name: RevokeUserRights
        comments: |-
          Revoke rights from a user.
          Revoking rights does not affect the resource version of the corresponding user.
      - name: ListUserRights
        comments: List the set of all rights granted to a user.
      - name: UpdateUserIdentityProviderId
        comments: Update the assignment of a user from one IDP to another.
  command_completion_service.proto:
    messages:
      CompletionStreamRequest:
        message:
          comments: null
          fieldComments:
            user_id: |-
              Only completions of commands submitted with the same user_id will be visible in the stream.
              Must be a valid UserIdString (as described in ``value.proto``).
              Required unless authentication is used with a user token.
              In that case, the token's user-id will be used for the request's user_id.
            parties: |-
              Non-empty list of parties whose data should be included.
              The stream shows only completions of commands for which at least one of the ``act_as`` parties is in the given set of parties.
              Must be a valid PartyIdString (as described in ``value.proto``).
              Required
            begin_exclusive: |-
              This optional field indicates the minimum offset for completions. This can be used to resume an earlier completion stream.
              If not set the ledger uses the ledger begin offset instead.
              If specified, it must be a valid absolute offset (positive integer) or zero (ledger begin offset).
              If the ledger has been pruned, this parameter must be specified and greater than the pruning offset.
      CompletionStreamResponse:
        message:
          comments: null
          fieldComments:
            completion: ''
            offset_checkpoint: ''
    oneOfs:
      CompletionStreamRequest: {}
      CompletionStreamResponse:
        completion_response:
          message:
            comments: null
            fieldComments:
              completion: ''
              offset_checkpoint: ''
    services:
      CommandCompletionService:
      - name: CompletionStream
        comments: Subscribe to command completion events.
  command_service.proto:
    messages:
      SubmitAndWaitForReassignmentRequest:
        message:
          comments: This reassignment is executed as a single atomic update.
          fieldComments:
            reassignment_commands: |-
              The reassignment commands to be submitted.
              Required
            event_format: |-
              Optional
              If no event_format provided, the result will contain no events.
              The events in the result, will take shape TRANSACTION_SHAPE_ACS_DELTA.
      SubmitAndWaitForReassignmentResponse:
        message:
          comments: null
          fieldComments:
            reassignment: |-
              The reassignment that resulted from the submitted reassignment command.
              The reassignment might contain no events (request conditions result in filtering out all of them).
              Required
      SubmitAndWaitForTransactionRequest:
        message:
          comments: These commands are executed as a single atomic transaction.
          fieldComments:
            commands: |-
              The commands to be submitted.
              Required
            transaction_format: |-
              If no ``transaction_format`` is provided, a default will be used where ``transaction_shape`` is set to
              TRANSACTION_SHAPE_ACS_DELTA, ``event_format`` is defined with ``filters_by_party`` containing wildcard-template
              filter for all original ``act_as`` and ``read_as`` parties and the ``verbose`` flag is set.
              Optional
      SubmitAndWaitForTransactionResponse:
        message:
          comments: null
          fieldComments:
            transaction: |-
              The transaction that resulted from the submitted command.
              The transaction might contain no events (request conditions result in filtering out all of them).
              Required
      SubmitAndWaitRequest:
        message:
          comments: These commands are executed as a single atomic transaction.
          fieldComments:
            commands: |-
              The commands to be submitted.
              Required
      SubmitAndWaitResponse:
        message:
          comments: null
          fieldComments:
            update_id: |-
              The id of the transaction that resulted from the submitted command.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            completion_offset: |-
              The details of the offset field are described in ``community/ledger-api/README.md``.
              Required
    oneOfs:
      SubmitAndWaitForReassignmentRequest: {}
      SubmitAndWaitForReassignmentResponse: {}
      SubmitAndWaitForTransactionRequest: {}
      SubmitAndWaitForTransactionResponse: {}
      SubmitAndWaitRequest: {}
      SubmitAndWaitResponse: {}
    services:
      CommandService:
      - name: SubmitAndWait
        comments: |-
          Submits a single composite command and waits for its result.
          Propagates the gRPC error of failed submissions including Daml interpretation errors.
      - name: SubmitAndWaitForTransaction
        comments: |-
          Submits a single composite command, waits for its result, and returns the transaction.
          Propagates the gRPC error of failed submissions including Daml interpretation errors.
      - name: SubmitAndWaitForReassignment
        comments: |-
          Submits a single composite reassignment command, waits for its result, and returns the reassignment.
          Propagates the gRPC error of failed submission.
  command_submission_service.proto:
    messages:
      SubmitReassignmentRequest:
        message:
          comments: null
          fieldComments:
            reassignment_commands: |-
              The reassignment command to be submitted.
              Required
      SubmitReassignmentResponse:
        message:
          comments: null
          fieldComments: {}
      SubmitRequest:
        message:
          comments: The submitted commands will be processed atomically in a single
            transaction. Moreover, each ``Command`` in ``commands`` will be executed
            in the order specified by the request.
          fieldComments:
            commands: |-
              The commands to be submitted in a single transaction.
              Required
      SubmitResponse:
        message:
          comments: null
          fieldComments: {}
    oneOfs:
      SubmitReassignmentRequest: {}
      SubmitReassignmentResponse: {}
      SubmitRequest: {}
      SubmitResponse: {}
    services:
      CommandSubmissionService:
      - name: Submit
        comments: Submit a single composite command.
      - name: SubmitReassignment
        comments: Submit a single reassignment.
  commands.proto:
    messages:
      Command:
        message:
          comments: A command can either create a new contract or exercise a choice
            on an existing contract.
          fieldComments:
            create: ''
            exercise: ''
            exercise_by_key: ''
            create_and_exercise: ''
      Commands:
        message:
          comments: A composite command that groups multiple commands together.
          fieldComments:
            command_id: |-
              Uniquely identifies the command.
              The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
              where act_as is interpreted as a set of party names.
              The change ID can be used for matching the intended ledger changes with all their completions.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            synchronizer_id: |-
              Must be a valid synchronizer id
              Optional
            disclosed_contracts: |-
              Additional contracts used to resolve contract & contract key lookups.
              Optional
            user_id: |-
              Uniquely identifies the participant user that issued the command.
              Must be a valid UserIdString (as described in ``value.proto``).
              Required unless authentication is used with a user token.
              In that case, the token's user-id will be used for the request's user_id.
            prefetch_contract_keys: |-
              Fetches the contract keys into the caches to speed up the command processing.
              Should only contain contract keys that are expected to be resolved during interpretation of the commands.
              Keys of disclosed contracts do not need prefetching.

              Optional
            min_ledger_time_abs: |-
              Lower bound for the ledger time assigned to the resulting transaction.
              Note: The ledger time of a transaction is assigned as part of command interpretation.
              Use this property if you expect that command interpretation will take a considerate amount of time, such that by
              the time the resulting transaction is sequenced, its assigned ledger time is not valid anymore.
              Must not be set at the same time as min_ledger_time_rel.
              Optional
            deduplication_offset: |-
              Specifies the start of the deduplication period by a completion stream offset (exclusive).
              Must be a valid absolute offset (positive integer) or participant begin (zero).
            workflow_id: |-
              Identifier of the on-ledger workflow that this command is a part of.
              Must be a valid LedgerString (as described in ``value.proto``).
              Optional
            min_ledger_time_rel: |-
              Same as min_ledger_time_abs, but specified as a duration, starting from the time the command is received by the server.
              Must not be set at the same time as min_ledger_time_abs.
              Optional
            commands: |-
              Individual elements of this atomic command. Must be non-empty.
              Required
            submission_id: |-
              A unique identifier to distinguish completions for different submissions with the same change ID.
              Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
              with the same change ID.
              Must be a valid LedgerString (as described in ``value.proto``).

              If omitted, the participant or the committer may set a value of their choice.
              Optional
            package_id_selection_preference: |-
              The package-id selection preference of the client for resolving
              package names and interface instances in command submission and interpretation
            deduplication_duration: |-
              Specifies the length of the deduplication period.
              It is interpreted relative to the local clock at some point during the submission's processing.
              Must be non-negative. Must not exceed the maximum deduplication time.
            read_as: |-
              Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
              This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
              Note: A participant node of a Daml network can host multiple parties. Each contract present on the participant
              node is only visible to a subset of these parties. A command can only use contracts that are visible to at least
              one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
              rules for fetch operations.
              If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
              to read contract data on behalf of each of the given parties.
              Optional
            act_as: |-
              Set of parties on whose behalf the command should be executed.
              If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
              to act on behalf of each of the given parties.
              Each element must be a valid PartyIdString (as described in ``value.proto``).
              Required, must be non-empty.
      CreateAndExerciseCommand:
        message:
          comments: Create a contract and exercise a choice on it in the same transaction.
          fieldComments:
            template_id: |-
              The template of the contract the client wants to create.
              Both package-name and package-id reference identifier formats for the template-id are supported.
              Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.

              Required
            create_arguments: |-
              The arguments required for creating a contract from this template.
              Required
            choice: |-
              The name of the choice the client wants to exercise.
              Must be a valid NameString (as described in ``value.proto``).
              Required
            choice_argument: |-
              The argument for this choice.
              Required
      CreateCommand:
        message:
          comments: Create a new contract instance based on a template.
          fieldComments:
            template_id: |-
              The template of contract the client wants to create.
              Both package-name and package-id reference identifier formats for the template-id are supported.
              Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.

              Required
            create_arguments: |-
              The arguments required for creating a contract from this template.
              Required
      DisclosedContract:
        message:
          comments: |-
            An additional contract that is used to resolve
            contract & contract key lookups.
          fieldComments:
            template_id: |-
              The template id of the contract.
              The identifier uses the package-id reference format.

              If provided, used to validate the template id of the contract serialized in the created_event_blob.
              Optional
            contract_id: |-
              The contract id

              If provided, used to validate the contract id of the contract serialized in the created_event_blob.
              Optional
            created_event_blob: |-
              Opaque byte string containing the complete payload required by the Daml engine
              to reconstruct a contract not known to the receiving participant.
              Required
            synchronizer_id: |-
              The ID of the synchronizer where the contract is currently assigned
              Optional
      ExerciseByKeyCommand:
        message:
          comments: Exercise a choice on an existing contract specified by its key.
          fieldComments:
            template_id: |-
              The template of contract the client wants to exercise.
              Both package-name and package-id reference identifier formats for the template-id are supported.
              Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.

              Required
            contract_key: |-
              The key of the contract the client wants to exercise upon.
              Required
            choice: |-
              The name of the choice the client wants to exercise.
              Must be a valid NameString (as described in ``value.proto``)
              Required
            choice_argument: |-
              The argument for this choice.
              Required
      ExerciseCommand:
        message:
          comments: Exercise a choice on an existing contract.
          fieldComments:
            template_id: |-
              The template or interface of the contract the client wants to exercise.
              Both package-name and package-id reference identifier formats for the template-id are supported.
              Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
              To exercise a choice on an interface, specify the interface identifier in the template_id field.

              Required
            contract_id: |-
              The ID of the contract the client wants to exercise upon.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            choice: |-
              The name of the choice the client wants to exercise.
              Must be a valid NameString (as described in ``value.proto``)
              Required
            choice_argument: |-
              The argument for this choice.
              Required
      PrefetchContractKey:
        message:
          comments: Preload contracts
          fieldComments:
            template_id: |-
              The template of contract the client wants to prefetch.
              Both package-name and package-id reference identifier formats for the template-id are supported.
              Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.

              Required
            contract_key: |-
              The key of the contract the client wants to prefetch.
              Required
    oneOfs:
      Command:
        command:
          message:
            comments: null
            fieldComments:
              create: ''
              exercise: ''
              exercise_by_key: ''
              create_and_exercise: ''
      Commands:
        deduplication_period:
          message:
            comments: |-
              Specifies the deduplication period for the change ID.
              If omitted, the participant will assume the configured maximum deduplication time.
            fieldComments:
              deduplication_duration: |-
                Specifies the length of the deduplication period.
                It is interpreted relative to the local clock at some point during the submission's processing.
                Must be non-negative. Must not exceed the maximum deduplication time.
              deduplication_offset: |-
                Specifies the start of the deduplication period by a completion stream offset (exclusive).
                Must be a valid absolute offset (positive integer) or participant begin (zero).
      CreateAndExerciseCommand: {}
      CreateCommand: {}
      DisclosedContract: {}
      ExerciseByKeyCommand: {}
      ExerciseCommand: {}
      PrefetchContractKey: {}
    services: {}
  completion.proto:
    messages:
      Completion:
        message:
          comments: 'A completion represents the status of a submitted command on
            the ledger: it can be successful or failed.'
          fieldComments:
            command_id: |-
              The ID of the succeeded or failed command.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            deduplication_duration: |-
              Specifies the length of the deduplication period.
              It is measured in record time of completions.

              Must be non-negative.
            update_id: |-
              The update_id of the transaction or reassignment that resulted from the command with command_id.
              Only set for successfully executed commands.
              Must be a valid LedgerString (as described in ``value.proto``).
            act_as: |-
              The set of parties on whose behalf the commands were executed.
              Contains the ``act_as`` parties from ``commands.proto``
              filtered to the requesting parties in CompletionStreamRequest.
              The order of the parties need not be the same as in the submission.
              Each element must be a valid PartyIdString (as described in ``value.proto``).
              Optional for historic completions where this data is not available.
            user_id: |-
              The user-id that was used for the submission, as described in ``commands.proto``.
              Must be a valid UserIdString (as described in ``value.proto``).
              Optional for historic completions where this data is not available.
            offset: |-
              May be used in a subsequent CompletionStreamRequest to resume the consumption of this stream at a later time.
              Required, must be a valid absolute offset (positive integer).
            status: |-
              Identifies the exact type of the error.
              It uses the same format of conveying error details as it is used for the RPC responses of the APIs.
              Optional
            deduplication_offset: |-
              Specifies the start of the deduplication period by a completion stream offset (exclusive).

              Must be a valid absolute offset (positive integer) or participant begin (zero).
            submission_id: |-
              The submission ID this completion refers to, as described in ``commands.proto``.
              Must be a valid LedgerString (as described in ``value.proto``).
              Optional
            synchronizer_time: |-
              The synchronizer along with its record time.
              The synchronizer id provided, in case of

              - successful/failed transactions: identifies the synchronizer of the transaction
              - for successful/failed unassign commands: identifies the source synchronizer
              - for successful/failed assign commands: identifies the target synchronizer

              Required
            trace_context: |-
              Optional; ledger API trace context

              The trace context transported in this message corresponds to the trace context supplied
              by the client application in a HTTP2 header of the original command submission.
              We typically use a header to transfer this type of information. Here we use message
              body, because it is used in gRPC streams which do not support per message headers.
              This field will be populated with the trace context contained in the original submission.
              If that was not provided, a unique ledger-api-server generated trace context will be used
              instead.
    oneOfs:
      Completion:
        deduplication_period:
          message:
            comments: |-
              The actual deduplication window used for the submission, which is derived from
              ``Commands.deduplication_period``. The ledger may convert the deduplication period into other
              descriptions and extend the period in implementation-specified ways.

              Used to audit the deduplication guarantee described in ``commands.proto``.

              Optional; the deduplication guarantee applies even if the completion omits this field.
            fieldComments:
              deduplication_offset: |-
                Specifies the start of the deduplication period by a completion stream offset (exclusive).

                Must be a valid absolute offset (positive integer) or participant begin (zero).
              deduplication_duration: |-
                Specifies the length of the deduplication period.
                It is measured in record time of completions.

                Must be non-negative.
    services: {}
  crypto.proto:
    messages:
      Signature:
        message:
          comments: null
          fieldComments:
            format: ''
            signature: ''
            signed_by: The fingerprint/id of the keypair used to create this signature
              and needed to verify.
            signing_algorithm_spec: The signing algorithm specification used to produce
              this signature
      SigningPublicKey:
        message:
          comments: null
          fieldComments:
            format: The serialization format of the public key
            key_data: Serialized public key in the format specified above
            key_spec: The key specification
    oneOfs:
      Signature: {}
      SigningPublicKey: {}
    services: {}
  event.proto:
    messages:
      ArchivedEvent:
        message:
          comments: Records that a contract has been archived, and choices may no
            longer be exercised on it.
          fieldComments:
            implemented_interfaces: |-
              The interfaces implemented by the target template that have been
              matched from the interface filter query.
              Populated only in case interface filters with include_interface_view set.

              If defined, the identifier uses the package-id reference format.

              Optional
            node_id: |-
              The position of this event in the originating transaction or reassignment.
              Node IDs are not necessarily equal across participants,
              as these may see different projections/parts of transactions.
              Required, must be valid node ID (non-negative integer)
            witness_parties: |-
              The parties that are notified of this event. For an ``ArchivedEvent``,
              these are the intersection of the stakeholders of the contract in
              question and the parties specified in the ``TransactionFilter``. The
              stakeholders are the union of the signatories and the observers of
              the contract.
              Each one of its elements must be a valid PartyIdString (as described
              in ``value.proto``).
              Required
            offset: |-
              The offset of origin.
              Offsets are managed by the participant nodes.
              Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
              Required, it is a valid absolute offset (positive integer)
            package_name: |-
              The package name of the contract.
              Required
            template_id: |-
              Identifies the template that defines the choice that archived the contract.
              This template's package-id may differ from the target contract's package-id
              if the target contract has been upgraded or downgraded.

              The identifier uses the package-id reference format.

              Required
            contract_id: |-
              The ID of the archived contract.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
      CreatedEvent:
        message:
          comments: Records that a contract has been created, and choices may now
            be exercised on it.
          fieldComments:
            observers: |-
              The observers for this contract as specified explicitly by the template or implicitly as choice controllers.
              This field never contains parties that are signatories.
              Required
            interface_views: |-
              Interface views specified in the transaction filter.
              Includes an ``InterfaceView`` for each interface for which there is a ``InterfaceFilter`` with

              - its party in the ``witness_parties`` of this event,
              - and which is implemented by the template of this event,
              - and which has ``include_interface_view`` set.

              Optional
            signatories: |-
              The signatories for this contract as specified by the template.
              Required
            witness_parties: |-
              The parties that are notified of this event. When a ``CreatedEvent``
              is returned as part of a transaction tree or ledger-effects transaction, this will include all
              the parties specified in the ``TransactionFilter`` that are witnesses  of the event
              (the stakeholders of the contract and all informees of all the ancestors
              of this create action that this participant knows about).
              If served as part of a ACS delta transaction those will
              be limited to all parties specified in the ``TransactionFilter`` that
              are stakeholders of the contract (i.e. either signatories or observers).
              If the ``CreatedEvent`` is returned as part of an AssignedEvent,
              ActiveContract or IncompleteUnassigned (so the event is related to
              an assignment or unassignment): this will include all parties of the
              ``TransactionFilter`` that are stakeholders of the contract.

              The behavior of reading create events visible to parties not hosted
              on the participant node serving the Ledger API is undefined. Concretely,
              there is neither a guarantee that the participant node will serve all their
              create events on the ACS stream, nor is there a guarantee that matching archive
              events are delivered for such create events.

              For most clients this is not a problem, as they only read events for parties
              that are hosted on the participant node. If you need to read events
              for parties that may not be hosted at all times on the participant node,
              subscribe to the ``TopologyEvent``s for that party by setting a corresponding
              ``UpdateFormat``.  Using these events, query the ACS as-of an offset where the
              party is hosted on the participant node, and ignore create events at offsets
              where the party is not hosted on the participant node.
              Required
            created_event_blob: |-
              Opaque representation of contract create event payload intended for forwarding
              to an API server as a contract disclosed as part of a command
              submission.
              Optional
            offset: |-
              The offset of origin, which has contextual meaning, please see description at messages that include a CreatedEvent.
              Offsets are managed by the participant nodes.
              Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
              Required, it is a valid absolute offset (positive integer)
            package_name: |-
              The package name of the created contract.
              Required
            representative_package_id: |-
              A package-id present in the participant package store that typechecks the contract's argument.
              This may differ from the package-id of the template used to create the contract.
              For contracts created before Canton 3.4, this field matches the contract's creation package-id.

              NOTE: Experimental, server internal concept, not for client consumption. Subject to change without notice.

              Required
            acs_delta: |-
              Whether this event would be part of respective ACS_DELTA shaped stream,
              and should therefore considered when tracking contract activeness on the client-side.
              Required
            node_id: |-
              The position of this event in the originating transaction or reassignment.
              The origin has contextual meaning, please see description at messages that include a CreatedEvent.
              Node IDs are not necessarily equal across participants,
              as these may see different projections/parts of transactions.
              Required, must be valid node ID (non-negative integer)
            contract_key: |-
              The key of the created contract.
              This will be set if and only if ``template_id`` defines a contract key.
              Optional
            created_at: |-
              Ledger effective time of the transaction that created the contract.
              Required
            create_arguments: |-
              The arguments that have been used to create the contract.

              Required
            template_id: |-
              The template of the created contract.
              The identifier uses the package-id reference format.

              Required
            contract_id: |-
              The ID of the created contract.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
      Event:
        message:
          comments: |-
            Events in transactions can have two primary shapes:

            - ACS delta: events can be CreatedEvent or ArchivedEvent
            - ledger effects: events can be CreatedEvent or ExercisedEvent

            In the update service the events are restricted to the events
            visible for the parties specified in the transaction filter. Each
            event message type below contains a ``witness_parties`` field which
            indicates the subset of the requested parties that can see the event
            in question.
          fieldComments:
            created: |-
              The event as it appeared in the context of its original daml transaction on this participant node.
              In particular, the offset, node_id pair of the daml transaction are preserved.
            archived: ''
            exercised: ''
      ExercisedEvent:
        message:
          comments: Records that a choice has been exercised on a target contract.
          fieldComments:
            implemented_interfaces: |-
              If the event is consuming, the interfaces implemented by the target template that have been
              matched from the interface filter query.
              Populated only in case interface filters with include_interface_view set.

              The identifier uses the package-id reference format.

              Optional
            choice_argument: |-
              The argument of the exercised choice.
              Required
            interface_id: |-
              The interface where the choice is defined, if inherited.
              If defined, the identifier uses the package-id reference format.

              Optional
            consuming: |-
              If true, the target contract may no longer be exercised.
              Required
            witness_parties: |-
              The parties that are notified of this event. The witnesses of an exercise
              node will depend on whether the exercise was consuming or not.
              If consuming, the witnesses are the union of the stakeholders,
              the actors and all informees of all the ancestors of this event this
              participant knows about.
              If not consuming, the witnesses are the union of the signatories,
              the actors and all informees of all the ancestors of this event this
              participant knows about.
              In both cases the witnesses are limited to the querying parties, or not
              limited in case anyParty filters are used.
              Note that the actors might not necessarily be observers
              and thus stakeholders. This is the case when the controllers of a
              choice are specified using "flexible controllers", using the
              ``choice ... controller`` syntax, and said controllers are not
              explicitly marked as observers.
              Each element must be a valid PartyIdString (as described in ``value.proto``).
              Required
            acting_parties: |-
              The parties that exercised the choice.
              Each element must be a valid PartyIdString (as described in ``value.proto``).
              Required
            offset: |-
              The offset of origin.
              Offsets are managed by the participant nodes.
              Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
              Required, it is a valid absolute offset (positive integer)
            package_name: |-
              The package name of the contract.
              Required
            choice: |-
              The choice that was exercised on the target contract.
              Must be a valid NameString (as described in ``value.proto``).
              Required
            acs_delta: |-
              Whether this event would be part of respective ACS_DELTA shaped stream,
              and should therefore considered when tracking contract activeness on the client-side.
              Required
            node_id: |-
              The position of this event in the originating transaction or reassignment.
              Node IDs are not necessarily equal across participants,
              as these may see different projections/parts of transactions.
              Required, must be valid node ID (non-negative integer)
            last_descendant_node_id: |-
              Specifies the upper boundary of the node ids of the events in the same transaction that appeared as a result of
              this ``ExercisedEvent``. This allows unambiguous identification of all the members of the subtree rooted at this
              node. A full subtree can be constructed when all descendant nodes are present in the stream. If nodes are heavily
              filtered, it is only possible to determine if a node is in a consequent subtree or not.
              Required
            exercise_result: |-
              The result of exercising the choice.
              Required
            template_id: |-
              Identifies the template that defines the executed choice.
              This template's package-id may differ from the target contract's package-id
              if the target contract has been upgraded or downgraded.

              The identifier uses the package-id reference format.

              Required
            contract_id: |-
              The ID of the target contract.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
      InterfaceView:
        message:
          comments: View of a create event matched by an interface filter.
          fieldComments:
            interface_id: |-
              The interface implemented by the matched event.
              The identifier uses the package-id reference format.

              Required
            view_status: |-
              Whether the view was successfully computed, and if not,
              the reason for the error. The error is reported using the same rules
              for error codes and messages as the errors returned for API requests.
              Required
            view_value: |-
              The value of the interface's view method on this event.
              Set if it was requested in the ``InterfaceFilter`` and it could be
              successfully computed.
              Optional
    oneOfs:
      ArchivedEvent: {}
      CreatedEvent: {}
      Event:
        event:
          message:
            comments: null
            fieldComments:
              created: |-
                The event as it appeared in the context of its original daml transaction on this participant node.
                In particular, the offset, node_id pair of the daml transaction are preserved.
              archived: ''
              exercised: ''
      ExercisedEvent: {}
      InterfaceView: {}
    services: {}
  event_query_service.proto:
    messages:
      Archived:
        message:
          comments: null
          fieldComments:
            archived_event: Required
            synchronizer_id: |-
              Required
              The synchronizer which sequenced the archival of the contract
      Created:
        message:
          comments: null
          fieldComments:
            created_event: |-
              Required
              The event as it appeared in the context of its original update (i.e. daml transaction or
              reassignment) on this participant node. You can use its offset and node_id to find the
              corresponding update and the node within it.
            synchronizer_id: |-
              The synchronizer which sequenced the creation of the contract
              Required
      GetEventsByContractIdRequest:
        message:
          comments: null
          fieldComments:
            contract_id: |-
              The contract id being queried.
              Required
            event_format: |-
              Format of the events in the result, the presentation will be of TRANSACTION_SHAPE_ACS_DELTA.
              Required
      GetEventsByContractIdResponse:
        message:
          comments: null
          fieldComments:
            created: |-
              The create event for the contract with the ``contract_id`` given in the request
              provided it exists and has not yet been pruned.
              Optional
            archived: |-
              The archive event for the contract with the ``contract_id`` given in the request
              provided such an archive event exists and it has not yet been pruned.
              Optional
    oneOfs:
      Archived: {}
      Created: {}
      GetEventsByContractIdRequest: {}
      GetEventsByContractIdResponse: {}
    services:
      EventQueryService:
      - name: GetEventsByContractId
        comments: |-
          Get the create and the consuming exercise event for the contract with the provided ID.
          No events will be returned for contracts that have been pruned because they
          have already been archived before the latest pruning offset.
          If the contract cannot be found for the request, or all the contract-events are filtered, a CONTRACT_EVENTS_NOT_FOUND error will be raised.
  experimental_features.proto:
    messages:
      ExperimentalCommandInspectionService:
        message:
          comments: Whether the Ledger API supports command inspection service
          fieldComments:
            supported: ''
      ExperimentalFeatures:
        message:
          comments: See the feature message definitions for descriptions.
          fieldComments:
            static_time: ''
            command_inspection_service: ''
      ExperimentalPartyTopologyEvents:
        message:
          comments: Whether the Ledger API supports party events
          fieldComments:
            supported: ''
      ExperimentalStaticTime:
        message:
          comments: Ledger is in the static time mode and exposes a time service.
          fieldComments:
            supported: ''
    oneOfs:
      ExperimentalCommandInspectionService: {}
      ExperimentalFeatures: {}
      ExperimentalPartyTopologyEvents: {}
      ExperimentalStaticTime: {}
    services: {}
  interactive/interactive_submission_common_data.proto:
    messages:
      GlobalKey:
        message:
          comments: null
          fieldComments:
            template_id: The identifier uses the package-id reference format.
            package_name: ''
            key: ''
            hash: ''
    oneOfs:
      GlobalKey: {}
    services: {}
  interactive/interactive_submission_service.proto:
    messages:
      CostEstimation:
        message:
          comments: |-
            Estimation of the cost of submitting the prepared transaction
            The estimation is done against the synchronizer chosen during preparation of the transaction
            (or the one explicitly requested).
            The cost of re-assigning contracts to another synchronizer when necessary is not included in the estimation.
          fieldComments:
            estimation_timestamp: Timestamp at which the estimation was made
            confirmation_request_traffic_cost_estimation: Estimated traffic cost of
              the confirmation request associated with the transaction
            confirmation_response_traffic_cost_estimation: |-
              Estimated traffic cost of the confirmation response associated with the transaction
              This field can also be used as an indication of the cost that other potential confirming nodes
              of the party will incur to approve or reject the transaction
            total_traffic_cost_estimation: Sum of the fields above
      CostEstimationHints:
        message:
          comments: Hints to improve cost estimation precision of a prepared transaction
          fieldComments:
            disabled: |-
              Disable cost estimation
              Default (not set) is false
            expected_signatures: |-
              Details on the keys that will be used to sign the transaction (how many and of which type).
              Signature size impacts the cost of the transaction.
              If empty, the signature sizes will be approximated with threshold-many signatures (where threshold is defined
              in the PartyToKeyMapping of the external party), using keys in the order they are registered.
              Optional (empty list is equivalent to not providing this field)
      DamlTransaction:
        message:
          comments: null
          fieldComments:
            version: |-
              [docs-entry-end: DamlTransaction.Node]
              serialization version, will be >= max(nodes version)
            roots: Root nodes of the transaction
            nodes: List of nodes in the transaction
            node_seeds: Node seeds are values associated with certain nodes used for
              generating cryptographic salts
      ExecuteSubmissionAndWaitForTransactionRequest:
        message:
          comments: null
          fieldComments:
            party_signatures: |-
              The party(ies) signatures that authorize the prepared submission to be executed by this node.
              Each party can provide one or more signatures..
              and one or more parties can sign.
              Note that currently, only single party submissions are supported.
              Required
            hashing_scheme_version: |-
              The hashing scheme version used when building the hash
              Required
            deduplication_duration: |-
              Specifies the length of the deduplication period.
              It is interpreted relative to the local clock at some point during the submission's processing.
              Must be non-negative. Must not exceed the maximum deduplication time.
            transaction_format: |-
              If no ``transaction_format`` is provided, a default will be used where ``transaction_shape`` is set to
              TRANSACTION_SHAPE_ACS_DELTA, ``event_format`` is defined with ``filters_by_party`` containing wildcard-template
              filter for all original ``act_as`` and ``read_as`` parties and the ``verbose`` flag is set.
              When the ``transaction_shape`` TRANSACTION_SHAPE_ACS_DELTA shape is used (explicitly or is defaulted to as explained above),
              events will only be returned if the submitting party is hosted on this node.
              Optional
            prepared_transaction: |-
              the prepared transaction
              Typically this is the value of the `prepared_transaction` field in `PrepareSubmissionResponse`
              obtained from calling `prepareSubmission`.
              Required
            deduplication_offset: |-
              Specifies the start of the deduplication period by a completion stream offset (exclusive).
              Must be a valid absolute offset (positive integer).
            submission_id: |-
              A unique identifier to distinguish completions for different submissions with the same change ID.
              Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
              with the same change ID.
              Must be a valid LedgerString (as described in ``value.proto``).

              Required
            min_ledger_time: |-
              If set will influence the chosen ledger effective time but will not result in a submission delay so any override
              should be scheduled to executed within the window allowed by synchronizer.
              Optional
            user_id: |-
              See [PrepareSubmissionRequest.user_id]
              Optional
      ExecuteSubmissionAndWaitForTransactionResponse:
        message:
          comments: null
          fieldComments:
            transaction: |-
              The transaction that resulted from the submitted command.
              The transaction might contain no events (request conditions result in filtering out all of them).
              Required
      ExecuteSubmissionAndWaitRequest:
        message:
          comments: null
          fieldComments:
            party_signatures: |-
              The party(ies) signatures that authorize the prepared submission to be executed by this node.
              Each party can provide one or more signatures..
              and one or more parties can sign.
              Note that currently, only single party submissions are supported.
              Required
            hashing_scheme_version: |-
              The hashing scheme version used when building the hash
              Required
            deduplication_duration: |-
              Specifies the length of the deduplication period.
              It is interpreted relative to the local clock at some point during the submission's processing.
              Must be non-negative. Must not exceed the maximum deduplication time.
            prepared_transaction: |-
              the prepared transaction
              Typically this is the value of the `prepared_transaction` field in `PrepareSubmissionResponse`
              obtained from calling `prepareSubmission`.
              Required
            deduplication_offset: |-
              Specifies the start of the deduplication period by a completion stream offset (exclusive).
              Must be a valid absolute offset (positive integer).
            submission_id: |-
              A unique identifier to distinguish completions for different submissions with the same change ID.
              Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
              with the same change ID.
              Must be a valid LedgerString (as described in ``value.proto``).

              Required
            min_ledger_time: |-
              If set will influence the chosen ledger effective time but will not result in a submission delay so any override
              should be scheduled to executed within the window allowed by synchronizer.
              Optional
            user_id: |-
              See [PrepareSubmissionRequest.user_id]
              Optional
      ExecuteSubmissionAndWaitResponse:
        message:
          comments: null
          fieldComments:
            update_id: |-
              The id of the transaction that resulted from the submitted command.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            completion_offset: |-
              The details of the offset field are described in ``community/ledger-api/README.md``.
              Required
      ExecuteSubmissionRequest:
        message:
          comments: null
          fieldComments:
            party_signatures: |-
              The party(ies) signatures that authorize the prepared submission to be executed by this node.
              Each party can provide one or more signatures..
              and one or more parties can sign.
              Note that currently, only single party submissions are supported.
              Required
            hashing_scheme_version: |-
              The hashing scheme version used when building the hash
              Required
            deduplication_duration: |-
              Specifies the length of the deduplication period.
              It is interpreted relative to the local clock at some point during the submission's processing.
              Must be non-negative. Must not exceed the maximum deduplication time.
            prepared_transaction: |-
              the prepared transaction
              Typically this is the value of the `prepared_transaction` field in `PrepareSubmissionResponse`
              obtained from calling `prepareSubmission`.
              Required
            deduplication_offset: |-
              Specifies the start of the deduplication period by a completion stream offset (exclusive).
              Must be a valid absolute offset (positive integer).
            submission_id: |-
              A unique identifier to distinguish completions for different submissions with the same change ID.
              Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
              with the same change ID.
              Must be a valid LedgerString (as described in ``value.proto``).

              Required
            min_ledger_time: |-
              If set will influence the chosen ledger effective time but will not result in a submission delay so any override
              should be scheduled to executed within the window allowed by synchronizer.
              Optional
            user_id: |-
              See [PrepareSubmissionRequest.user_id]
              Optional
      ExecuteSubmissionResponse:
        message:
          comments: null
          fieldComments: {}
      GetPreferredPackageVersionRequest:
        message:
          comments: null
          fieldComments:
            parties: |-
              The parties whose participants' vetting state should be considered when resolving the preferred package.
              Required
            package_name: |-
              The package-name for which the preferred package should be resolved.
              Required
            synchronizer_id: |-
              The synchronizer whose vetting state should be used for resolving this query.
              If not specified, the vetting states of all synchronizers to which the participant is connected are used.
              Optional
            vetting_valid_at: |-
              The timestamp at which the package vetting validity should be computed
              on the latest topology snapshot as seen by the participant.
              If not provided, the participant's current clock time is used.
              Optional
      GetPreferredPackageVersionResponse:
        message:
          comments: null
          fieldComments:
            package_preference: |-
              Not populated when no preferred package is found
              Optional
      GetPreferredPackagesRequest:
        message:
          comments: null
          fieldComments:
            package_vetting_requirements: |-
              The package-name vetting requirements for which the preferred packages should be resolved.

              Generally it is enough to provide the requirements for the intended command's root package-names.
              Additional package-name requirements can be provided when additional Daml transaction informees need to use
              package dependencies of the command's root packages.

              Required
            synchronizer_id: |-
              The synchronizer whose vetting state should be used for resolving this query.
              If not specified, the vetting states of all synchronizers to which the participant is connected are used.
              Optional
            vetting_valid_at: |-
              The timestamp at which the package vetting validity should be computed
              on the latest topology snapshot as seen by the participant.
              If not provided, the participant's current clock time is used.
              Optional
      GetPreferredPackagesResponse:
        message:
          comments: null
          fieldComments:
            package_references: |-
              The package references of the preferred packages.
              Must contain one package reference for each requested package-name.

              If you build command submissions whose content depends on the returned
              preferred packages, then we recommend submitting the preferred package-ids
              in the ``package_id_selection_preference`` of the command submission to
              avoid race conditions with concurrent changes of the on-ledger package vetting state.

              Required
            synchronizer_id: |-
              The synchronizer for which the package preferences are computed.
              If the synchronizer_id was specified in the request, then it matches the request synchronizer_id.
              Required
      Metadata:
        message:
          comments: |-
            Transaction Metadata
            Refer to the hashing documentation for information on how it should be hashed.
          fieldComments:
            max_record_time: |-
              Maximum timestamp at which the transaction can be recorded onto the ledger via the synchronizer `synchronizer_id`.
              If submitted after it will be rejected even if otherwise valid, in which case it needs to be prepared and signed again
              with a new valid max_record_time.
              Unsigned in 3.3 to avoid a breaking protocol change
              Will be signed in 3.4+
              Set max_record_time in the PreparedTransactionRequest to get this field set accordingly
            synchronizer_id: ''
            preparation_time: ''
            min_ledger_effective_time: ''
            mediator_group: ''
            submitter_info: ''
            global_key_mapping: |-
              Contextual information needed to process the transaction but not signed, either because it's already indirectly
              signed by signing the transaction, or because it doesn't impact the ledger state
            input_contracts: ''
            transaction_uuid: ''
            max_ledger_effective_time: ''
      MinLedgerTime:
        message:
          comments: null
          fieldComments:
            min_ledger_time_abs: |-
              Lower bound for the ledger time assigned to the resulting transaction.
              The ledger time of a transaction is assigned as part of command interpretation.
              Important note: for interactive submissions, if the transaction depends on time, it **must** be signed
              and submitted within a time window around the ledger time assigned to the transaction during the prepare method.
              The time delta around that ledger time is a configuration of the ledger, usually short, around 1 minute.
              If however the transaction does not depend on time, the available time window to sign and submit the transaction is bound
              by the preparation time, which is also assigned in the "prepare" step (this request),
              but can be configured with a much larger skew, allowing for more time to sign the request (in the order of hours).
              Must not be set at the same time as min_ledger_time_rel.
              Optional
            min_ledger_time_rel: |-
              Same as min_ledger_time_abs, but specified as a duration, starting from the time this request is received by the server.
              Must not be set at the same time as min_ledger_time_abs.
              Optional
      PackagePreference:
        message:
          comments: null
          fieldComments:
            package_reference: |-
              The package reference of the preferred package.
              Required
            synchronizer_id: |-
              The synchronizer for which the preferred package was computed.
              If the synchronizer_id was specified in the request, then it matches the request synchronizer_id.
              Required
      PackageVettingRequirement:
        message:
          comments: Defines a package-name for which the commonly vetted package with
            the highest version must be found.
          fieldComments:
            parties: |-
              The parties whose participants' vetting state should be considered when resolving the preferred package.
              Required
            package_name: |-
              The package-name for which the preferred package should be resolved.
              Required
      PartySignatures:
        message:
          comments: Additional signatures provided by the submitting parties
          fieldComments:
            signatures: |-
              Additional signatures provided by all individual parties
              Required
      PrepareSubmissionRequest:
        message:
          comments: null
          fieldComments:
            command_id: |-
              Uniquely identifies the command.
              The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
              where act_as is interpreted as a set of party names.
              The change ID can be used for matching the intended ledger changes with all their completions.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            max_record_time: |-
              Maximum timestamp at which the transaction can be recorded onto the ledger via the synchronizer specified in the `PrepareSubmissionResponse`.
              If submitted after it will be rejected even if otherwise valid, in which case it needs to be prepared and signed again
              with a new valid max_record_time.
              Use this to limit the time-to-life of a prepared transaction,
              which is useful to know when it can definitely not be accepted
              anymore and resorting to preparing another transaction for the same
              intent is safe again.
              Optional
            synchronizer_id: |-
              Must be a valid synchronizer id
              If not set, a suitable synchronizer that this node is connected to will be chosen
              Optional
            package_id_selection_preference: |-
              The package-id selection preference of the client for resolving
              package names and interface instances in command submission and interpretation
              Optional
            disclosed_contracts: |-
              Additional contracts used to resolve contract & contract key lookups.
              Optional
            verbose_hashing: |-
              When true, the response will contain additional details on how the transaction was encoded and hashed
              This can be useful for troubleshooting of hash mismatches. Should only be used for debugging.
              Optional, default to false
            prefetch_contract_keys: |-
              Fetches the contract keys into the caches to speed up the command processing.
              Should only contain contract keys that are expected to be resolved during interpretation of the commands.
              Keys of disclosed contracts do not need prefetching.

              Optional
            commands: |-
              Individual elements of this atomic command. Must be non-empty.
              Limitation: Only single command transaction are currently supported by the API.
              The field is marked as repeated in preparation for future support of multiple commands.
              Required
            read_as: |-
              Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
              This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
              Note: A command can only use contracts that are visible to at least
              one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
              rules for fetch operations.
              If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
              to read contract data on behalf of each of the given parties.
              Optional
            estimate_traffic_cost: |-
              Hints to improve the accuracy of traffic cost estimation.
              The estimation logic assumes that this node will be used for the execution of the transaction
              If another node is used instead, the estimation may be less precise.
              Request amplification is not accounted for in the estimation: each amplified request will
              result in the cost of the confirmation request to be charged additionally.

              Optional - Traffic cost estimation is enabled by default if this field is not set
              To turn off cost estimation, set the CostEstimationHints#disabled field to true
            act_as: |-
              Set of parties on whose behalf the command should be executed, if submitted.
              If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
              to **read** (not act) on behalf of each of the given parties. This is because this RPC merely prepares a transaction
              and does not execute it. Therefore read authorization is sufficient even for actAs parties.
              Note: This may change, and more specific authorization scope may be introduced in the future.
              Each element must be a valid PartyIdString (as described in ``value.proto``).
              Required, must be non-empty.
            min_ledger_time: Optional
            user_id: |-
              Uniquely identifies the participant user that prepares the transaction.
              Must be a valid UserIdString (as described in ``value.proto``).
              Required unless authentication is used with a user token.
              In that case, the token's user-id will be used for the request's user_id.
              Optional
      PrepareSubmissionResponse:
        message:
          comments: '[docs-entry-end: HashingSchemeVersion]'
          fieldComments:
            hashing_details: |-
              Optional additional details on how the transaction was encoded and hashed. Only set if verbose_hashing = true in the request
              Note that there are no guarantees on the stability of the format or content of this field.
              Its content should NOT be parsed and should only be used for troubleshooting purposes.
            prepared_transaction_hash: |-
              Hash of the transaction, this is what needs to be signed by the party to authorize the transaction.
              Only provided for convenience, clients MUST recompute the hash from the raw transaction if the preparing participant is not trusted.
              May be removed in future versions
            prepared_transaction: |-
              The interpreted transaction, it represents the ledger changes necessary to execute the commands specified in the request.
              Clients MUST display the content of the transaction to the user for them to validate before signing the hash if the preparing participant is not trusted.
            cost_estimation: |-
              Traffic cost estimation of the prepared transaction
              Optional
            hashing_scheme_version: The hashing scheme version used when building
              the hash
      PreparedTransaction:
        message:
          comments: null
          fieldComments:
            transaction: Daml Transaction representing the ledger effect if executed.
              See below
            metadata: Metadata context necessary to execute the transaction
      SinglePartySignatures:
        message:
          comments: Signatures provided by a single party
          fieldComments:
            party: |-
              Submitting party
              Required
            signatures: |-
              Signatures
              Required
    oneOfs:
      CostEstimation: {}
      CostEstimationHints: {}
      DamlTransaction: {}
      ExecuteSubmissionAndWaitForTransactionRequest:
        deduplication_period:
          message:
            comments: |-
              Specifies the deduplication period for the change ID (See PrepareSubmissionRequest).
              If omitted, the participant will assume the configured maximum deduplication time.
              Optional
            fieldComments:
              deduplication_duration: |-
                Specifies the length of the deduplication period.
                It is interpreted relative to the local clock at some point during the submission's processing.
                Must be non-negative. Must not exceed the maximum deduplication time.
              deduplication_offset: |-
                Specifies the start of the deduplication period by a completion stream offset (exclusive).
                Must be a valid absolute offset (positive integer).
      ExecuteSubmissionAndWaitForTransactionResponse: {}
      ExecuteSubmissionAndWaitRequest:
        deduplication_period:
          message:
            comments: |-
              Specifies the deduplication period for the change ID (See PrepareSubmissionRequest).
              If omitted, the participant will assume the configured maximum deduplication time.
              Optional
            fieldComments:
              deduplication_duration: |-
                Specifies the length of the deduplication period.
                It is interpreted relative to the local clock at some point during the submission's processing.
                Must be non-negative. Must not exceed the maximum deduplication time.
              deduplication_offset: |-
                Specifies the start of the deduplication period by a completion stream offset (exclusive).
                Must be a valid absolute offset (positive integer).
      ExecuteSubmissionAndWaitResponse: {}
      ExecuteSubmissionRequest:
        deduplication_period:
          message:
            comments: |-
              Specifies the deduplication period for the change ID (See PrepareSubmissionRequest).
              If omitted, the participant will assume the configured maximum deduplication time.
              Optional
            fieldComments:
              deduplication_duration: |-
                Specifies the length of the deduplication period.
                It is interpreted relative to the local clock at some point during the submission's processing.
                Must be non-negative. Must not exceed the maximum deduplication time.
              deduplication_offset: |-
                Specifies the start of the deduplication period by a completion stream offset (exclusive).
                Must be a valid absolute offset (positive integer).
      ExecuteSubmissionResponse: {}
      GetPreferredPackageVersionRequest: {}
      GetPreferredPackageVersionResponse: {}
      GetPreferredPackagesRequest: {}
      GetPreferredPackagesResponse: {}
      Metadata: {}
      MinLedgerTime:
        time:
          message:
            comments: null
            fieldComments:
              min_ledger_time_abs: |-
                Lower bound for the ledger time assigned to the resulting transaction.
                The ledger time of a transaction is assigned as part of command interpretation.
                Important note: for interactive submissions, if the transaction depends on time, it **must** be signed
                and submitted within a time window around the ledger time assigned to the transaction during the prepare method.
                The time delta around that ledger time is a configuration of the ledger, usually short, around 1 minute.
                If however the transaction does not depend on time, the available time window to sign and submit the transaction is bound
                by the preparation time, which is also assigned in the "prepare" step (this request),
                but can be configured with a much larger skew, allowing for more time to sign the request (in the order of hours).
                Must not be set at the same time as min_ledger_time_rel.
                Optional
              min_ledger_time_rel: |-
                Same as min_ledger_time_abs, but specified as a duration, starting from the time this request is received by the server.
                Must not be set at the same time as min_ledger_time_abs.
                Optional
      PackagePreference: {}
      PackageVettingRequirement: {}
      PartySignatures: {}
      PrepareSubmissionRequest: {}
      PrepareSubmissionResponse: {}
      PreparedTransaction: {}
      SinglePartySignatures: {}
    services:
      InteractiveSubmissionService:
      - name: PrepareSubmission
        comments: Requires `readAs` scope for the submitting party when LAPI User
          authorization is enabled
      - name: ExecuteSubmission
        comments: |-
          Execute a prepared submission _asynchronously_ on the ledger.
          Requires a signature of the transaction from the submitting external party.
      - name: ExecuteSubmissionAndWait
        comments: |-
          Similar to ExecuteSubmission but _synchronously_ wait for the completion of the transaction
          IMPORTANT: Relying on the response from this endpoint requires trusting the Participant Node to be honest.
          A malicious node could make a successfully committed request appeared failed and vice versa
      - name: ExecuteSubmissionAndWaitForTransaction
        comments: |-
          Similar to ExecuteSubmissionAndWait but additionally returns the transaction
          IMPORTANT: Relying on the response from this endpoint requires trusting the Participant Node to be honest.
          A malicious node could make a successfully committed request appear as failed and vice versa
      - name: GetPreferredPackageVersion
        comments: |-
          A preferred package is the highest-versioned package for a provided package-name
          that is vetted by all the participants hosting the provided parties.

          Ledger API clients should use this endpoint for constructing command submissions
          that are compatible with the provided preferred package, by making informed decisions on:
          - which are the compatible packages that can be used to create contracts
          - which contract or exercise choice argument version can be used in the command
          - which choices can be executed on a template or interface of a contract

          Can be accessed by any Ledger API client with a valid token when Ledger API authorization is enabled.

          Provided for backwards compatibility, it will be removed in the Canton version 3.4.0
      - name: GetPreferredPackages
        comments: |-
          Compute the preferred packages for the vetting requirements in the request.
          A preferred package is the highest-versioned package for a provided package-name
          that is vetted by all the participants hosting the provided parties.

          Ledger API clients should use this endpoint for constructing command submissions
          that are compatible with the provided preferred packages, by making informed decisions on:
          - which are the compatible packages that can be used to create contracts
          - which contract or exercise choice argument version can be used in the command
          - which choices can be executed on a template or interface of a contract

          If the package preferences could not be computed due to no selection satisfying the requirements,
          a `FAILED_PRECONDITION` error will be returned.

          Can be accessed by any Ledger API client with a valid token when Ledger API authorization is enabled.

          Experimental API: this endpoint is not guaranteed to provide backwards compatibility in future releases
  interactive/transaction/v1/interactive_submission_data.proto:
    messages:
      Create:
        message:
          comments: Create Node
          fieldComments:
            signatories: ''
            package_name: ''
            argument: ''
            stakeholders: ''
            lf_version: Specific LF version of the node
            template_id: The identifier uses the package-id reference format.
            contract_id: ''
      Exercise:
        message:
          comments: Exercise node
          fieldComments:
            children: ''
            interface_id: The identifier uses the package-id reference format.
            signatories: ''
            consuming: ''
            acting_parties: ''
            package_name: ''
            exercise_result: ''
            chosen_value: ''
            choice_id: ''
            choice_observers: ''
            stakeholders: ''
            lf_version: Specific LF version of the node
            template_id: The identifier uses the package-id reference format.
            contract_id: ''
      Fetch:
        message:
          comments: Fetch node
          fieldComments:
            interface_id: Optional
            signatories: ''
            acting_parties: ''
            package_name: ''
            stakeholders: ''
            lf_version: Specific LF version of the node
            template_id: The identifier uses the package-id reference format.
            contract_id: ''
      Node:
        message:
          comments: null
          fieldComments:
            create: ''
            fetch: ''
            exercise: ''
            rollback: ''
      Rollback:
        message:
          comments: Rollback Node
          fieldComments:
            children: ''
    oneOfs:
      Create: {}
      Exercise: {}
      Fetch: {}
      Node:
        node_type:
          message:
            comments: null
            fieldComments:
              create: ''
              fetch: ''
              exercise: ''
              rollback: ''
      Rollback: {}
    services: {}
  offset_checkpoint.proto:
    messages:
      OffsetCheckpoint:
        message:
          comments: |-
            OffsetCheckpoints may be used to:

            - detect time out of commands.
            - provide an offset which can be used to restart consumption.
          fieldComments:
            offset: |-
              The participant's offset, the details of the offset field are described in ``community/ledger-api/README.md``.
              Required, must be a valid absolute offset (positive integer).
            synchronizer_times: ''
      SynchronizerTime:
        message:
          comments: null
          fieldComments:
            synchronizer_id: |-
              The id of the synchronizer.
              Required
            record_time: |-
              All commands with a maximum record time below this value MUST be considered lost if their completion has not arrived before this checkpoint.
              Required
    oneOfs:
      OffsetCheckpoint: {}
      SynchronizerTime: {}
    services: {}
  package_reference.proto:
    messages:
      PackageReference:
        message:
          comments: null
          fieldComments:
            package_id: Required
            package_name: Required
            package_version: Required
      PriorTopologySerial:
        message:
          comments: |-
            The serial of last ``VettedPackages`` topology transaction on a given
            participant and synchronizer.
          fieldComments:
            prior: Previous transaction's serial.
            no_prior: No previous transaction exists.
      VettedPackage:
        message:
          comments: |-
            A package that is vetting on a given participant and synchronizer,
            modelled after ``VettedPackage`` in `topology.proto <https://github.com/digital-asset/canton/blob/main/community/base/src/main/protobuf/com/digitalasset/canton/protocol/v30/topology.proto#L206>`_,
            enriched with the package name and version.
          fieldComments:
            valid_until_exclusive: |-
              The time until which this package is vetted. Empty if vetting time has no
              upper bound.
            package_version: |-
              Version of this package.
              Only available if the package has been uploaded to the current participant.
              If unavailable, is empty string.
            package_name: |-
              Name of this package.
              Only available if the package has been uploaded to the current participant.
              If unavailable, is empty string.
            package_id: Package ID of this package. Always present.
            valid_from_inclusive: |-
              The time from which this package is vetted. Empty if vetting time has no
              lower bound.
      VettedPackages:
        message:
          comments: |-
            The list of packages vetted on a given participant and synchronizer, modelled
            after ``VettedPackages`` in `topology.proto <https://github.com/digital-asset/canton/blob/main/community/base/src/main/protobuf/com/digitalasset/canton/protocol/v30/topology.proto#L206>`_.
            The list only contains packages that matched a filter in the query that
            originated it.
          fieldComments:
            packages: |-
              Sorted by package_name and package_version where known, and package_id as a
              last resort.
            participant_id: Participant on which these packages are vetted. Always
              present.
            synchronizer_id: Synchronizer on which these packages are vetted. Always
              present.
            topology_serial: |-
              Serial of last ``VettedPackages`` topology transaction of this participant
              and on this synchronizer. Always present.
    oneOfs:
      PackageReference: {}
      PriorTopologySerial:
        serial:
          message:
            comments: null
            fieldComments:
              prior: Previous transaction's serial.
              no_prior: No previous transaction exists.
      VettedPackage: {}
      VettedPackages: {}
    services: {}
  package_service.proto:
    messages:
      GetPackageRequest:
        message:
          comments: null
          fieldComments:
            package_id: |-
              The ID of the requested package.
              Must be a valid PackageIdString (as described in ``value.proto``).
              Required
      GetPackageResponse:
        message:
          comments: null
          fieldComments:
            hash_function: |-
              The hash function we use to calculate the hash.
              Required
            archive_payload: |-
              Contains a ``daml_lf`` ArchivePayload. See further details in ``daml_lf.proto``.
              Required
            hash: |-
              The hash of the archive payload, can also used as a ``package_id``.
              Must be a valid PackageIdString (as described in ``value.proto``).
              Required
      GetPackageStatusRequest:
        message:
          comments: null
          fieldComments:
            package_id: |-
              The ID of the requested package.
              Must be a valid PackageIdString (as described in ``value.proto``).
              Required
      GetPackageStatusResponse:
        message:
          comments: null
          fieldComments:
            package_status: The status of the package.
      ListPackagesRequest:
        message:
          comments: null
          fieldComments: {}
      ListPackagesResponse:
        message:
          comments: null
          fieldComments:
            package_ids: |-
              The IDs of all Daml-LF packages supported by the server.
              Each element must be a valid PackageIdString (as described in ``value.proto``).
              Required
      ListVettedPackagesRequest:
        message:
          comments: null
          fieldComments:
            package_metadata_filter: |-
              The package metadata filter the returned vetted packages set must satisfy.
              Optional
            topology_state_filter: |-
              The topology filter the returned vetted packages set must satisfy.
              Optional
            page_token: |-
              Pagination token to determine the specific page to fetch. Using the token
              guarantees that ``VettedPackages`` on a subsequent page are all greater
              (``VettedPackages`` are sorted by synchronizer ID then participant ID) than
              the last ``VettedPackages`` on a previous page.

              The server does not store intermediate results between calls chained by a
              series of page tokens. As a consequence, if new vetted packages are being
              added and a page is requested twice using the same token, more packages can
              be returned on the second call.

              Leave unspecified (i.e. as empty string) to fetch the first page.

              Optional
            page_size: |-
              Maximum number of ``VettedPackages`` results to return in a single page.

              If the page_size is unspecified (i.e. left as 0), the server will decide
              the number of results to be returned.

              If the page_size exceeds the maximum supported by the server, an
              error will be returned.

              To obtain the server's maximum consult the PackageService descriptor
              available in the VersionService.

              Optional
      ListVettedPackagesResponse:
        message:
          comments: null
          fieldComments:
            vetted_packages: |-
              All ``VettedPackages`` that contain at least one ``VettedPackage`` matching
              both a ``PackageMetadataFilter`` and a ``TopologyStateFilter``.
              Sorted by synchronizer_id then participant_id.
            next_page_token: |-
              Pagination token to retrieve the next page.
              Empty string if there are no further results.
      PackageMetadataFilter:
        message:
          comments: |-
            Filter the VettedPackages by package metadata.

            A PackageMetadataFilter without package_ids and without package_name_prefixes
            matches any vetted package.

            Non-empty fields specify candidate values of which at least one must match.
            If both fields are set, then a candidate is returned if it matches one of the fields.
          fieldComments:
            package_ids: |-
              If this list is non-empty, any vetted package with a package ID in this
              list will match the filter.
            package_name_prefixes: |-
              If this list is non-empty, any vetted package with a name matching at least
              one prefix in this list will match the filter.
      TopologyStateFilter:
        message:
          comments: |-
            Filter the vetted packages by the participant and synchronizer that they are
            hosted on.

            Empty fields are ignored, such that a ``TopologyStateFilter`` without
            participant_ids and without synchronizer_ids matches a vetted package hosted
            on any participant and synchronizer.

            Non-empty fields specify candidate values of which at least one must match.
            If both fields are set then at least one candidate value must match from each
            field.
          fieldComments:
            participant_ids: |-
              If this list is non-empty, only vetted packages hosted on participants
              listed in this field match the filter.
              Query the current Ledger API's participant's ID via the public
              ``GetParticipantId`` command in ``PartyManagementService``.
            synchronizer_ids: |-
              If this list is non-empty, only vetted packages from the topology state of
              the synchronizers in this list match the filter.
    oneOfs:
      GetPackageRequest: {}
      GetPackageResponse: {}
      GetPackageStatusRequest: {}
      GetPackageStatusResponse: {}
      ListPackagesRequest: {}
      ListPackagesResponse: {}
      ListVettedPackagesRequest: {}
      ListVettedPackagesResponse: {}
      PackageMetadataFilter: {}
      TopologyStateFilter: {}
    services:
      PackageService:
      - name: ListPackages
        comments: Returns the identifiers of all supported packages.
      - name: GetPackage
        comments: Returns the contents of a single package.
      - name: GetPackageStatus
        comments: Returns the status of a single package.
      - name: ListVettedPackages
        comments: |-
          Lists which participant node vetted what packages on which synchronizer.
          Can be called by any authenticated user.
  reassignment.proto:
    messages:
      AssignedEvent:
        message:
          comments: Records that a contract has been assigned, and it can be used
            on the target synchronizer.
          fieldComments:
            created_event: |-
              Required
              The offset of this event refers to the offset of the assignment,
              while the node_id is the index of within the batch.
            source: |-
              The ID of the source synchronizer.
              Must be a valid synchronizer id.
              Required
            reassignment_counter: |-
              Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
              with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
              equals zero.
              Required
            reassignment_id: |-
              The ID from the unassigned event.
              For correlation capabilities.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            target: |-
              The ID of the target synchronizer.
              Must be a valid synchronizer id.
              Required
            submitter: |-
              Party on whose behalf the assign command was executed.
              Empty if the assignment happened offline via the repair service.
              Must be a valid PartyIdString (as described in ``value.proto``).
              Optional
      Reassignment:
        message:
          comments: Complete view of an on-ledger reassignment.
          fieldComments:
            command_id: |-
              The ID of the command which resulted in this reassignment. Missing for everyone except the submitting party on the submitting participant.
              Must be a valid LedgerString (as described in ``value.proto``).
              Optional
            trace_context: |-
              Optional; ledger API trace context

              The trace context transported in this message corresponds to the trace context supplied
              by the client application in a HTTP2 header of the original command submission.
              We typically use a header to transfer this type of information. Here we use message
              body, because it is used in gRPC streams which do not support per message headers.
              This field will be populated with the trace context contained in the original submission.
              If that was not provided, a unique ledger-api-server generated trace context will be used
              instead.
            synchronizer_id: |-
              A valid synchronizer id.
              Identifies the synchronizer that synchronized this Reassignment.
              Required
            update_id: |-
              Assigned by the server. Useful for correlating logs.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            offset: |-
              The participant's offset. The details of this field are described in ``community/ledger-api/README.md``.
              Required, must be a valid absolute offset (positive integer).
            events: The collection of reassignment events. Required.
            workflow_id: |-
              The workflow ID used in reassignment command submission. Only set if the ``workflow_id`` for the command was set.
              Must be a valid LedgerString (as described in ``value.proto``).
              Optional
            record_time: |-
              The time at which the reassignment was recorded. The record time refers to the source/target
              synchronizer for an unassign/assign event respectively.
              Required
      ReassignmentEvent:
        message:
          comments: null
          fieldComments:
            unassigned: ''
            assigned: ''
      UnassignedEvent:
        message:
          comments: Records that a contract has been unassigned, and it becomes unusable
            on the source synchronizer
          fieldComments:
            node_id: |-
              The position of this event in the originating reassignment.
              Node IDs are not necessarily equal across participants,
              as these may see different projections/parts of reassignments.
              Required, must be valid node ID (non-negative integer)
            offset: |-
              The offset of origin.
              Offsets are managed by the participant nodes.
              Reassignments can thus NOT be assumed to have the same offsets on different participant nodes.
              Required, it is a valid absolute offset (positive integer)
            package_name: |-
              The package name of the contract.
              Required
            source: |-
              The ID of the source synchronizer
              Must be a valid synchronizer id
              Required
            reassignment_counter: |-
              Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
              with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
              equals zero.
              Required
            witness_parties: |-
              The parties that are notified of this event.
              Required
            assignment_exclusivity: |-
              Assignment exclusivity
              Before this time (measured on the target synchronizer), only the submitter of the unassignment can initiate the assignment
              Defined for reassigning participants.
              Optional
            reassignment_id: |-
              The ID of the unassignment. This needs to be used as an input for a assign ReassignmentCommand.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            target: |-
              The ID of the target synchronizer
              Must be a valid synchronizer id
              Required
            submitter: |-
              Party on whose behalf the unassign command was executed.
              Empty if the unassignment happened offline via the repair service.
              Must be a valid PartyIdString (as described in ``value.proto``).
              Optional
            template_id: |-
              The template of the reassigned contract.
              The identifier uses the package-id reference format.

              Required
            contract_id: |-
              The ID of the reassigned contract.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
    oneOfs:
      AssignedEvent: {}
      Reassignment: {}
      ReassignmentEvent:
        event:
          message:
            comments: null
            fieldComments:
              unassigned: ''
              assigned: ''
      UnassignedEvent: {}
    services: {}
  reassignment_commands.proto:
    messages:
      AssignCommand:
        message:
          comments: Assign a contract
          fieldComments:
            reassignment_id: |-
              The ID from the unassigned event to be completed by this assignment.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            source: |-
              The ID of the source synchronizer
              Must be a valid synchronizer id
              Required
            target: |-
              The ID of the target synchronizer
              Must be a valid synchronizer id
              Required
      ReassignmentCommand:
        message:
          comments: null
          fieldComments:
            unassign_command: ''
            assign_command: ''
      ReassignmentCommands:
        message:
          comments: null
          fieldComments:
            command_id: |-
              Uniquely identifies the command.
              The triple (user_id, submitter, command_id) constitutes the change ID for the intended ledger change.
              The change ID can be used for matching the intended ledger changes with all their completions.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            user_id: |-
              Uniquely identifies the participant user that issued the command.
              Must be a valid UserIdString (as described in ``value.proto``).
              Required unless authentication is used with a user token.
              In that case, the token's user-id will be used for the request's user_id.
            submitter: |-
              Party on whose behalf the command should be executed.
              If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
              to act on behalf of the given party.
              Must be a valid PartyIdString (as described in ``value.proto``).
              Required
            workflow_id: |-
              Identifier of the on-ledger workflow that this command is a part of.
              Must be a valid LedgerString (as described in ``value.proto``).
              Optional
            commands: Individual elements of this reassignment. Must be non-empty.
            submission_id: |-
              A unique identifier to distinguish completions for different submissions with the same change ID.
              Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
              with the same change ID.
              Must be a valid LedgerString (as described in ``value.proto``).

              If omitted, the participant or the committer may set a value of their choice.
              Optional
      UnassignCommand:
        message:
          comments: Unassign a contract
          fieldComments:
            contract_id: |-
              The ID of the contract the client wants to unassign.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            source: |-
              The ID of the source synchronizer
              Must be a valid synchronizer id
              Required
            target: |-
              The ID of the target synchronizer
              Must be a valid synchronizer id
              Required
    oneOfs:
      AssignCommand: {}
      ReassignmentCommand:
        command:
          message:
            comments: null
            fieldComments:
              unassign_command: ''
              assign_command: ''
      ReassignmentCommands: {}
      UnassignCommand: {}
    services: {}
  state_service.proto:
    messages:
      ActiveContract:
        message:
          comments: null
          fieldComments:
            created_event: |-
              Required
              The event as it appeared in the context of its last update (i.e. daml transaction or
              reassignment). In particular, the last offset, node_id pair is preserved.
              The last update is the most recent update created or assigned this contract on synchronizer_id synchronizer.
              The offset of the CreatedEvent might point to an already pruned update, therefore it cannot necessarily be used
              for lookups.
            synchronizer_id: |-
              A valid synchronizer id
              Required
            reassignment_counter: |-
              Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
              with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
              equals zero.
              This field will be the reassignment_counter of the latest observable activation event on this synchronizer, which is
              before the active_at_offset.
              Required
      GetActiveContractsRequest:
        message:
          comments: |-
            If the given offset is different than the ledger end, and there are (un)assignments in-flight at the given offset,
            the snapshot may fail with "FAILED_PRECONDITION/PARTICIPANT_PRUNED_DATA_ACCESSED".
            Note that it is ok to request acs snapshots for party migration with offsets other than ledger end, because party
            migration is not concerned with incomplete (un)assignments.
          fieldComments:
            active_at_offset: |-
              The offset at which the snapshot of the active contracts will be computed.
              Must be no greater than the current ledger end offset.
              Must be greater than or equal to the last pruning offset.
              Required, must be a valid absolute offset (positive integer) or ledger begin offset (zero).
              If zero, the empty set will be returned.
            event_format: |-
              Format of the contract_entries in the result. In case of CreatedEvent the presentation will be of
              TRANSACTION_SHAPE_ACS_DELTA.
              Optional for backwards compatibility, defaults to an EventFormat where:

              - filters_by_party is the filter.filters_by_party from this request
              - filters_for_any_party is the filter.filters_for_any_party from this request
              - verbose is the verbose field from this request
      GetActiveContractsResponse:
        message:
          comments: null
          fieldComments:
            workflow_id: |-
              The workflow ID used in command submission which corresponds to the contract_entry. Only set if
              the ``workflow_id`` for the command was set.
              Must be a valid LedgerString (as described in ``value.proto``).
              Optional
            active_contract: |-
              The contract is active on the assigned synchronizer, meaning: there was an activation event on the given synchronizer (
              created, assigned), which is not followed by a deactivation event (archived, unassigned) on the same
              synchronizer, until the active_at_offset.
              Since activeness is defined as a per synchronizer concept, it is possible, that a contract is active on one
              synchronizer, but already archived on another.
              There will be one such message for each synchronizer the contract is active on.
            incomplete_unassigned: |-
              Included iff the unassigned event was before or at the active_at_offset, but there was no corresponding
              assigned event before or at the active_at_offset.
            incomplete_assigned: |-
              Important: this message is not indicating that the contract is active on the target synchronizer!
              Included iff the assigned event was before or at the active_at_offset, but there was no corresponding
              unassigned event before or at the active_at_offset.
      GetConnectedSynchronizersRequest:
        message:
          comments: null
          fieldComments:
            party: |-
              The party of interest
              Must be a valid PartyIdString (as described in ``value.proto``).
              If empty, all synchronizers this node is connected to will be returned
              Optional
            participant_id: |-
              The id of a participant whose mapping of a party to connected synchronizers is requested.
              Must be a valid participant-id retrieved through a prior call to getParticipantId.
              Defaults to the participant id of the host participant.
              Optional
            identity_provider_id: |-
              The ID of the identity provider configured by ``Identity Provider Config``
              Optional, if not set, assume the user is managed by the default identity provider.
      GetConnectedSynchronizersResponse:
        message:
          comments: null
          fieldComments:
            connected_synchronizers: ''
      GetLatestPrunedOffsetsRequest:
        message:
          comments: null
          fieldComments: {}
      GetLatestPrunedOffsetsResponse:
        message:
          comments: null
          fieldComments:
            participant_pruned_up_to_inclusive: |-
              It will always be a non-negative integer.
              If positive, the absolute offset up to which the ledger has been pruned,
              disregarding the state of all divulged contracts pruning.
              If zero, the ledger has not been pruned yet.
            all_divulged_contracts_pruned_up_to_inclusive: |-
              It will always be a non-negative integer.
              If positive, the absolute offset up to which all divulged events have been pruned on the ledger.
              It can be at or before the ``participant_pruned_up_to_inclusive`` offset.
              For more details about all divulged events pruning,
              see ``PruneRequest.prune_all_divulged_contracts`` in ``participant_pruning_service.proto``.
              If zero, the divulged events have not been pruned yet.
      GetLedgerEndRequest:
        message:
          comments: null
          fieldComments: {}
      GetLedgerEndResponse:
        message:
          comments: null
          fieldComments:
            offset: |-
              It will always be a non-negative integer.
              If zero, the participant view of the ledger is empty.
              If positive, the absolute offset of the ledger as viewed by the participant.
      IncompleteAssigned:
        message:
          comments: null
          fieldComments:
            assigned_event: Required
      IncompleteUnassigned:
        message:
          comments: null
          fieldComments:
            created_event: |-
              Required
              The event as it appeared in the context of its last activation update (i.e. daml transaction or
              reassignment). In particular, the last activation offset, node_id pair is preserved.
              The last activation update is the most recent update created or assigned this contract on synchronizer_id synchronizer before
              the unassigned_event.
              The offset of the CreatedEvent might point to an already pruned update, therefore it cannot necessarily be used
              for lookups.
            unassigned_event: Required
    oneOfs:
      ActiveContract: {}
      GetActiveContractsRequest: {}
      GetActiveContractsResponse:
        contract_entry:
          message:
            comments: |-
              For a contract there could be multiple contract_entry-s in the entire snapshot. These together define
              the state of one contract in the snapshot.
              A contract_entry is included in the result, if and only if there is at least one stakeholder party of the contract
              that is hosted on the synchronizer at the time of the event and the party satisfies the
              ``TransactionFilter`` in the query.
            fieldComments:
              active_contract: |-
                The contract is active on the assigned synchronizer, meaning: there was an activation event on the given synchronizer (
                created, assigned), which is not followed by a deactivation event (archived, unassigned) on the same
                synchronizer, until the active_at_offset.
                Since activeness is defined as a per synchronizer concept, it is possible, that a contract is active on one
                synchronizer, but already archived on another.
                There will be one such message for each synchronizer the contract is active on.
              incomplete_unassigned: |-
                Included iff the unassigned event was before or at the active_at_offset, but there was no corresponding
                assigned event before or at the active_at_offset.
              incomplete_assigned: |-
                Important: this message is not indicating that the contract is active on the target synchronizer!
                Included iff the assigned event was before or at the active_at_offset, but there was no corresponding
                unassigned event before or at the active_at_offset.
      GetConnectedSynchronizersRequest: {}
      GetConnectedSynchronizersResponse: {}
      GetLatestPrunedOffsetsRequest: {}
      GetLatestPrunedOffsetsResponse: {}
      GetLedgerEndRequest: {}
      GetLedgerEndResponse: {}
      IncompleteAssigned: {}
      IncompleteUnassigned: {}
    services:
      StateService:
      - name: GetActiveContracts
        comments: |-
          Returns a stream of the snapshot of the active contracts and incomplete (un)assignments at a ledger offset.
          Once the stream of GetActiveContractsResponses completes,
          the client SHOULD begin streaming updates from the update service,
          starting at the GetActiveContractsRequest.active_at_offset specified in this request.
          Clients SHOULD NOT assume that the set of active contracts they receive reflects the state at the ledger end.
      - name: GetConnectedSynchronizers
        comments: Get the list of connected synchronizers at the time of the query.
      - name: GetLedgerEnd
        comments: |-
          Get the current ledger end.
          Subscriptions started with the returned offset will serve events after this RPC was called.
      - name: GetLatestPrunedOffsets
        comments: Get the latest successfully pruned ledger offsets
  testing/time_service.proto:
    messages:
      GetTimeRequest:
        message:
          comments: null
          fieldComments: {}
      GetTimeResponse:
        message:
          comments: null
          fieldComments:
            current_time: The current time according to the ledger server.
      SetTimeRequest:
        message:
          comments: null
          fieldComments:
            current_time: MUST precisely match the current time as it's known to the
              ledger server.
            new_time: |-
              The time the client wants to set on the ledger.
              MUST be a point int time after ``current_time``.
    oneOfs:
      GetTimeRequest: {}
      GetTimeResponse: {}
      SetTimeRequest: {}
    services:
      TimeService:
      - name: GetTime
        comments: Returns the current time according to the ledger server.
      - name: SetTime
        comments: Allows clients to change the ledger's clock in an atomic get-and-set
          operation.
  topology_transaction.proto:
    messages:
      ParticipantAuthorizationAdded:
        message:
          comments: null
          fieldComments:
            party_id: Required
            participant_id: Required
            participant_permission: Required
      ParticipantAuthorizationChanged:
        message:
          comments: null
          fieldComments:
            party_id: Required
            participant_id: Required
            participant_permission: Required
      ParticipantAuthorizationRevoked:
        message:
          comments: null
          fieldComments:
            party_id: Required
            participant_id: Required
      TopologyEvent:
        message:
          comments: null
          fieldComments:
            participant_authorization_changed: ''
            participant_authorization_revoked: ''
            participant_authorization_added: ''
      TopologyTransaction:
        message:
          comments: null
          fieldComments:
            trace_context: |-
              Optional; ledger API trace context

              The trace context transported in this message corresponds to the trace context supplied
              by the client application in a HTTP2 header of the original command submission.
              We typically use a header to transfer this type of information. Here we use message
              body, because it is used in gRPC streams which do not support per message headers.
              This field will be populated with the trace context contained in the original submission.
              If that was not provided, a unique ledger-api-server generated trace context will be used
              instead.
            synchronizer_id: |-
              A valid synchronizer id.
              Identifies the synchronizer that synchronized the topology transaction.
              Required
            update_id: |-
              Assigned by the server. Useful for correlating logs.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            offset: |-
              The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
              Required, it is a valid absolute offset (positive integer).
            record_time: |-
              The time at which the changes in the topology transaction become effective. There is a small delay between a
              topology transaction being sequenced and the changes it contains becoming effective. Topology transactions appear
              in order relative to a synchronizer based on their effective time rather than their sequencing time.
              Required
            events: |-
              A non-empty list of topology events.
              Required
    oneOfs:
      ParticipantAuthorizationAdded: {}
      ParticipantAuthorizationChanged: {}
      ParticipantAuthorizationRevoked: {}
      TopologyEvent:
        event:
          message:
            comments: null
            fieldComments:
              participant_authorization_changed: ''
              participant_authorization_revoked: ''
              participant_authorization_added: ''
      TopologyTransaction: {}
    services: {}
  trace_context.proto:
    messages:
      TraceContext:
        message:
          comments: null
          fieldComments:
            traceparent: https://www.w3.org/TR/trace-context/
            tracestate: ''
    oneOfs:
      TraceContext: {}
    services: {}
  transaction.proto:
    messages:
      Transaction:
        message:
          comments: Filtered view of an on-ledger transaction's create and archive
            events.
          fieldComments:
            command_id: |-
              The ID of the command which resulted in this transaction. Missing for everyone except the submitting party.
              Must be a valid LedgerString (as described in ``value.proto``).
              Optional
            external_transaction_hash: |-
              For transaction externally signed, contains the external transaction hash
              signed by the external party. Can be used to correlate an external submission with a committed transaction.
              Optional
            trace_context: |-
              Optional; ledger API trace context

              The trace context transported in this message corresponds to the trace context supplied
              by the client application in a HTTP2 header of the original command submission.
              We typically use a header to transfer this type of information. Here we use message
              body, because it is used in gRPC streams which do not support per message headers.
              This field will be populated with the trace context contained in the original submission.
              If that was not provided, a unique ledger-api-server generated trace context will be used
              instead.
            synchronizer_id: |-
              A valid synchronizer id.
              Identifies the synchronizer that synchronized the transaction.
              Required
            update_id: |-
              Assigned by the server. Useful for correlating logs.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            offset: |-
              The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
              Required, it is a valid absolute offset (positive integer).
            effective_at: |-
              Ledger effective time.
              Required
            events: |-
              The collection of events.
              Contains:

              - ``CreatedEvent`` or ``ArchivedEvent`` in case of ACS_DELTA transaction shape
              - ``CreatedEvent`` or ``ExercisedEvent`` in case of LEDGER_EFFECTS transaction shape

              Required
            workflow_id: |-
              The workflow ID used in command submission.
              Must be a valid LedgerString (as described in ``value.proto``).
              Optional
            record_time: |-
              The time at which the transaction was recorded. The record time refers to the synchronizer
              which synchronized the transaction.
              Required
    oneOfs:
      Transaction: {}
    services: {}
  transaction_filter.proto:
    messages:
      CumulativeFilter:
        message:
          comments: |-
            A filter that matches all contracts that are either an instance of one of
            the ``template_filters`` or that match one of the ``interface_filters``.
          fieldComments:
            wildcard_filter: |-
              A wildcard filter that matches all templates
              Optional
            interface_filter: |-
              Include an ``InterfaceView`` for every ``InterfaceFilter`` matching a contract.
              The ``InterfaceFilter`` instances MUST each use a unique ``interface_id``.
              Optional
            template_filter: |-
              A template for which the data will be included in the
              ``create_arguments`` of a matching ``CreatedEvent``.
              If a contract is simultaneously selected by a template filter and one or more interface filters,
              the corresponding ``include_created_event_blob`` are consolidated using an OR operation.
              Optional
      EventFormat:
        message:
          comments: |-
            A format for events which defines both which events should be included
            and what data should be computed and included for them.

            Note that some of the filtering behavior depends on the `TransactionShape`,
            which is expected to be specified alongside usages of `EventFormat`.
          fieldComments:
            filters_by_party: |-
              Each key must be a valid PartyIdString (as described in ``value.proto``).
              The interpretation of the filter depends on the transaction-shape being filtered:

              1. For **ledger-effects** create and exercise events are returned, for which the witnesses include at least one of
                 the listed parties and match the per-party filter.
              2. For **transaction and active-contract-set streams** create and archive events are returned for all contracts whose
                 stakeholders include at least one of the listed parties and match the per-party filter.

              Optional
            filters_for_any_party: |-
              Wildcard filters that apply to all the parties existing on the participant. The interpretation of the filters is the same
              with the per-party filter as described above.
              Optional
            verbose: |-
              If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
              In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
              Optional
      Filters:
        message:
          comments: The union of a set of template filters, interface filters, or
            a wildcard.
          fieldComments:
            cumulative: |-
              Every filter in the cumulative list expands the scope of the resulting stream. Each interface,
              template or wildcard filter means additional events that will match the query.
              The impact of include_interface_view and include_created_event_blob fields in the filters will
              also be accumulated.
              A template or an interface SHOULD NOT appear twice in the accumulative field.
              A wildcard filter SHOULD NOT be defined more than once in the accumulative field.
              Optional, if no ``CumulativeFilter`` defined, the default of a single ``WildcardFilter`` with
              include_created_event_blob unset is used.
      InterfaceFilter:
        message:
          comments: This filter matches contracts that implement a specific interface.
          fieldComments:
            interface_id: |-
              The interface that a matching contract must implement.
              The ``interface_id`` needs to be valid: corresponding interface should be defined in
              one of the available packages at the time of the query.
              Both package-name and package-id reference formats for the identifier are supported.
              Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.

              Required
            include_interface_view: |-
              Whether to include the interface view on the contract in the returned ``CreatedEvent``.
              Use this to access contract data in a uniform manner in your API client.
              Optional
            include_created_event_blob: |-
              Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
              Use this to access the contract create event payload in your API client
              for submitting it as a disclosed contract with future commands.
              Optional
      ParticipantAuthorizationTopologyFormat:
        message:
          comments: A format specifying which participant authorization topology transactions
            to include and how to render them.
          fieldComments:
            parties: |-
              List of parties for which the topology transactions should be sent.
              Empty means: for all parties.
      TemplateFilter:
        message:
          comments: This filter matches contracts of a specific template.
          fieldComments:
            template_id: |-
              A template for which the payload should be included in the response.
              The ``template_id`` needs to be valid: corresponding template should be defined in
              one of the available packages at the time of the query.
              Both package-name and package-id reference formats for the identifier are supported.
              Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.

              Required
            include_created_event_blob: |-
              Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
              Use this to access the contract event payload in your API client
              for submitting it as a disclosed contract with future commands.
              Optional
      TopologyFormat:
        message:
          comments: A format specifying which topology transactions to include and
            how to render them.
          fieldComments:
            include_participant_authorization_events: |-
              Include participant authorization topology events in streams.
              Optional, if unset no participant authorization topology events are emitted in the stream.
      TransactionFormat:
        message:
          comments: |-
            A format that specifies what events to include in Daml transactions
            and what data to compute and include for them.
          fieldComments:
            event_format: Required
            transaction_shape: |-
              What transaction shape to use for interpreting the filters of the event format.
              Required
      UpdateFormat:
        message:
          comments: A format specifying what updates to include and how to render
            them.
          fieldComments:
            include_transactions: |-
              Include Daml transactions in streams.
              Optional, if unset, no transactions are emitted in the stream.
            include_reassignments: |-
              Include (un)assignments in the stream.
              The events in the result take the shape TRANSACTION_SHAPE_ACS_DELTA.
              Optional, if unset, no (un)assignments are emitted in the stream.
            include_topology_events: |-
              Include topology events in streams.
              Optional, if unset no topology events are emitted in the stream.
      WildcardFilter:
        message:
          comments: This filter matches all templates.
          fieldComments:
            include_created_event_blob: |-
              Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
              Use this to access the contract create event payload in your API client
              for submitting it as a disclosed contract with future commands.
              Optional
    oneOfs:
      CumulativeFilter:
        identifier_filter:
          message:
            comments: null
            fieldComments:
              wildcard_filter: |-
                A wildcard filter that matches all templates
                Optional
              interface_filter: |-
                Include an ``InterfaceView`` for every ``InterfaceFilter`` matching a contract.
                The ``InterfaceFilter`` instances MUST each use a unique ``interface_id``.
                Optional
              template_filter: |-
                A template for which the data will be included in the
                ``create_arguments`` of a matching ``CreatedEvent``.
                If a contract is simultaneously selected by a template filter and one or more interface filters,
                the corresponding ``include_created_event_blob`` are consolidated using an OR operation.
                Optional
      EventFormat: {}
      Filters: {}
      InterfaceFilter: {}
      ParticipantAuthorizationTopologyFormat: {}
      TemplateFilter: {}
      TopologyFormat: {}
      TransactionFormat: {}
      UpdateFormat: {}
      WildcardFilter: {}
    services: {}
  update_service.proto:
    messages:
      GetUpdateByIdRequest:
        message:
          comments: null
          fieldComments:
            update_id: |-
              The ID of a particular update.
              Must be a valid LedgerString (as described in ``value.proto``).
              Required
            update_format: |-
              The format for the update.
              Required
      GetUpdateByOffsetRequest:
        message:
          comments: null
          fieldComments:
            offset: |-
              The offset of the update being looked up.
              Must be a valid absolute offset (positive integer).
              Required
            update_format: |-
              The format for the update.
              Required
      GetUpdateResponse:
        message:
          comments: null
          fieldComments:
            transaction: ''
            reassignment: ''
            topology_transaction: ''
      GetUpdatesRequest:
        message:
          comments: null
          fieldComments:
            begin_exclusive: |-
              Beginning of the requested ledger section (non-negative integer).
              The response will only contain transactions whose offset is strictly greater than this.
              If zero, the stream will start from the beginning of the ledger.
              If positive, the streaming will start after this absolute offset.
              If the ledger has been pruned, this parameter must be specified and be greater than the pruning offset.
            end_inclusive: |-
              End of the requested ledger section.
              The response will only contain transactions whose offset is less than or equal to this.
              Optional, if empty, the stream will not terminate.
              If specified, the stream will terminate after this absolute offset (positive integer) is reached.
            update_format: |-
              Must be unset for GetUpdateTrees request.
              Optional for backwards compatibility for GetUpdates request: defaults to an UpdateFormat where:

              - include_transactions.event_format.filters_by_party = the filter.filters_by_party on this request
              - include_transactions.event_format.filters_for_any_party = the filter.filters_for_any_party on this request
              - include_transactions.event_format.verbose = the same flag specified on this request
              - include_transactions.transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
              - include_reassignments.filter = the same filter specified on this request
              - include_reassignments.verbose = the same flag specified on this request
              - include_topology_events.include_participant_authorization_events.parties = all the parties specified in filter
      GetUpdatesResponse:
        message:
          comments: null
          fieldComments:
            transaction: ''
            reassignment: ''
            offset_checkpoint: ''
            topology_transaction: ''
    oneOfs:
      GetUpdateByIdRequest: {}
      GetUpdateByOffsetRequest: {}
      GetUpdateResponse:
        update:
          message:
            comments: The update that matches the filter in the request.
            fieldComments:
              transaction: ''
              reassignment: ''
              topology_transaction: ''
      GetUpdatesRequest: {}
      GetUpdatesResponse:
        update:
          message:
            comments: The update that matches the filter in the request.
            fieldComments:
              transaction: ''
              reassignment: ''
              offset_checkpoint: ''
              topology_transaction: ''
    services:
      UpdateService:
      - name: GetUpdates
        comments: |-
          Read the ledger's filtered update stream for the specified contents and filters.
          It returns the event types in accordance with the stream contents selected. Also the selection criteria
          for individual events depends on the transaction shape chosen.

          - ACS delta: a requesting party must be a stakeholder of an event for it to be included.
          - ledger effects: a requesting party must be a witness of an en event for it to be included.
      - name: GetUpdateByOffset
        comments: |-
          Lookup an update by its offset.
          If there is no update with this offset, or all the events are filtered, an UPDATE_NOT_FOUND error will be raised.
      - name: GetUpdateById
        comments: |-
          Lookup an update by its ID.
          If there is no update with this ID, or all the events are filtered, an UPDATE_NOT_FOUND error will be raised.
  version_service.proto:
    messages:
      FeaturesDescriptor:
        message:
          comments: null
          fieldComments:
            experimental: |-
              Features under development or features that are used
              for ledger implementation testing purposes only.

              Daml applications SHOULD not depend on these in production.
            package_feature: |-
              If set, then the Ledger API server supports package listing
              configurability. It is recommended that clients query this field to
              gracefully adjust their behavior to maximum package listing page size.
            offset_checkpoint: It contains the timeouts related to the periodic offset
              checkpoint emission
            party_management: |-
              If set, then the Ledger API server supports party management configurability.
              It is recommended that clients query this field to gracefully adjust their behavior to
              maximum party page size.
            user_management: |-
              If set, then the Ledger API server supports user management.
              It is recommended that clients query this field to gracefully adjust their behavior for
              ledgers that do not support user management.
      GetLedgerApiVersionRequest:
        message:
          comments: null
          fieldComments: {}
      GetLedgerApiVersionResponse:
        message:
          comments: null
          fieldComments:
            version: The version of the ledger API.
            features: |-
              The features supported by this Ledger API endpoint.

              Daml applications CAN use the feature descriptor on top of
              version constraints on the Ledger API version to determine
              whether a given Ledger API endpoint supports the features
              required to run the application.

              See the feature descriptions themselves for the relation between
              Ledger API versions and feature presence.
      OffsetCheckpointFeature:
        message:
          comments: null
          fieldComments:
            max_offset_checkpoint_emission_delay: The maximum delay to emmit a new
              OffsetCheckpoint if it exists
      PackageFeature:
        message:
          comments: null
          fieldComments:
            max_vetted_packages_page_size: |-
              The maximum number of vetted packages the server can return in a single
              response (page) when listing them.
      PartyManagementFeature:
        message:
          comments: null
          fieldComments:
            max_parties_page_size: The maximum number of parties the server can return
              in a single response (page).
      UserManagementFeature:
        message:
          comments: null
          fieldComments:
            supported: Whether the Ledger API server provides the user management
              service.
            max_rights_per_user: |-
              The maximum number of rights that can be assigned to a single user.
              Servers MUST support at least 100 rights per user.
              A value of 0 means that the server enforces no rights per user limit.
            max_users_page_size: |-
              The maximum number of users the server can return in a single response (page).
              Servers MUST support at least a 100 users per page.
              A value of 0 means that the server enforces no page size limit.
    oneOfs:
      FeaturesDescriptor: {}
      GetLedgerApiVersionRequest: {}
      GetLedgerApiVersionResponse: {}
      OffsetCheckpointFeature: {}
      PackageFeature: {}
      PartyManagementFeature: {}
      UserManagementFeature: {}
    services:
      VersionService:
      - name: GetLedgerApiVersion
        comments: Read the Ledger API version

// Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.digitalasset.daml.lf.testing.archive

import java.io.File
import com.digitalasset.daml.lf.archive.DamlLf2
import com.digitalasset.daml.lf.archive.{ArchivePayload, Dar, DarDecoder, DarReader, DecodeV2}
import com.digitalasset.daml.lf.data.Ref.DottedName
import com.digitalasset.daml.lf.data.Ref.ModuleName
import com.digitalasset.daml.lf.language.Ast
import com.digitalasset.daml.lf.language.LanguageVersion
import com.digitalasset.daml.lf.language.LanguageVersion.{v2_1, v2_2, v2_dev}
import org.scalatest.prop.TableDrivenPropertyChecks
import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpec

import scala.jdk.CollectionConverters._
import scala.language.implicitConversions

class DamlLfEncoderTest
    extends AnyWordSpec
    with Matchers
    with TableDrivenPropertyChecks {

  "dar generated by encoder" should {

    "be readable" in {

      val sharedModules = Set[DottedName](
        "UnitMod",
        "BoolMod",
        "Int64Mod",
        "TextMod",
        "DateMod",
        "TimestampMod",
        "ListMod",
        "PartyMod",
        "RecordMod",
        "VariantMod",
        "BuiltinMod",
        "TemplateMod",
        "OptionMod",
        "EnumMod",
        "NumericMod",
        "AnyMod",
        "SynonymMod",
        "GenMapMod",
        "ExceptionMod",
        "InterfaceMod",
        "InterfaceMod0",
        "TextMapMod",
        "LedgerTimeMod",
      )
      val modules_2_1 = sharedModules ++ Set[DottedName]("InterfaceUnsafeFromMod")
      val modules_2_2 = sharedModules
      val modules_2_dev = sharedModules ++ Set[DottedName](
        "BigNumericMod",
        "InterfaceExtMod",
        "TemplateWithKeyMod",
        "DA.Types", // stable package
      )

      val stableModules = Set[DottedName](
        "DA.Exception.ArithmeticError",
        "DA.Exception.AssertionFailed",
        "DA.Exception.GeneralError",
        "DA.Exception.PreconditionFailed",
        "DA.Internal.Erased",
        "DA.Internal.NatSyn",
        "DA.Internal.PromotedText",
        "DA.Types",
        "GHC.Prim",
        "GHC.Tuple",
        "GHC.Types",
        "DA.Action.State.Type",
        "DA.Date.Types",
        "DA.Internal.Any",
        "DA.Internal.Down",
        "DA.Internal.Fail.Types",
        "DA.Internal.Interface.AnyView.Types",
        "DA.Internal.Template",
        "DA.Logic.Types",
        "DA.Monoid.Types",
        "DA.NonEmpty.Types",
        "DA.Random.Types",
        "DA.Semigroup.Types",
        "DA.Set.Types",
        "DA.Stack.Types",
        "DA.Time.Types",
        "DA.Validation.Types",
      )

      val versions = Table(
        "versions" -> "modules",
        v2_1 -> modules_2_1,
        v2_2 -> modules_2_2,
        v2_dev -> modules_2_dev,
      )

      forEvery(versions) { (version, expectedModules) =>
        val darFile = new java.io.File(getClass.getClassLoader.getResource(s"test-${version.pretty}.dar").toURI)
        val dar = DarReader.readArchiveFromFile(darFile)

        dar shouldBe a[Right[_, _]]

        val findModules = dar.toOption.toList.flatMap(getNonEmptyModules).toSet

        (findModules diff expectedModules) diff stableModules shouldBe Set()
        (expectedModules diff findModules) diff stableModules shouldBe Set()

      }
    }

  }

  private def getNonEmptyModules(dar: Dar[ArchivePayload]): Seq[ModuleName] = {
    for {
      payload <- dar.all
      name <- payload match {
        case ArchivePayload.Lf2(_, pkg, _, _) => getNonEmptyModules(pkg)
        case _ => throw new RuntimeException(s"Unsupported language version: ${payload.version}")
      }
    } yield name
  }

  private def getNonEmptyModules(pkg: DamlLf2.Package): Seq[DottedName] = {
    val internedStrings = pkg.getInternedStringsList.asScala.toArray
    val dottedNames = pkg.getInternedDottedNamesList.asScala.map(
      _.getSegmentsInternedStrList.asScala.map(internedStrings(_))
    )
    for {
      segments <- pkg.getModulesList.asScala.toSeq.map {
        case mod
            if mod.getSynonymsCount != 0 ||
              mod.getDataTypesCount != 0 ||
              mod.getValuesCount != 0 ||
              mod.getTemplatesCount != 0 =>
          dottedNames(mod.getNameInternedDname)
      }
    } yield DottedName.assertFromSegments(segments)
  }

  "BuiltinMod" should {

    val builtinMod = ModuleName.assertFromString("BuiltinMod")

    "contains all builtins " in {
      forEvery(
        Table("version", LanguageVersion.allLfVersions.filter(LanguageVersion.v2_dev < _): _*)
      ) { version =>
        // Construct the file path dynamically using the helper and the version
        val darFile = new java.io.File(getClass.getClassLoader.getResource(s"test-${version.pretty}.dar").toURI)

        val Right(dar) = DarDecoder.readArchiveFromFile(darFile)

        val (_, mainPkg) = dar.main
        val builtinInModule = mainPkg
          .modules(builtinMod)
          .definitions
          .values
          .collect { case Ast.DValue(_, Ast.EBuiltinFun(builtin)) => builtin }
          .toSet
        val builtinsInVersion = DecodeV2.builtinFunctionInfos.collect {
          case DecodeV2.BuiltinFunctionInfo(_, builtin, minVersion, maxVersion, _, _)
            if minVersion <= version && maxVersion.forall(version < _) =>
            builtin
        }.toSet

        val missingBuiltins = builtinsInVersion -- builtinInModule
        assert(missingBuiltins.isEmpty, s", missing builtin(s) in BuiltinMod")
        val unexpectedBuiltins = builtinInModule -- builtinsInVersion
        assert(unexpectedBuiltins.isEmpty, s", unexpected builtin(s) in BuiltinMod")
      }
    }
  }

  private implicit def toDottedName(s: String): DottedName =
    DottedName.assertFromString(s)

  // Helper to get the directory from the system property
  def getDarDirectory: File = {
    val path = sys.props.get("daml.test.darDir")
      .getOrElse(throw new RuntimeException("System property 'daml.test.darDir' not set. Are you running from sbt with 'Test / fork := true'?"))
    new File(path)
  }

}

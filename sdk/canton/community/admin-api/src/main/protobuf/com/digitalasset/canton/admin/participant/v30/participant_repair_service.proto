// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package com.digitalasset.canton.admin.participant.v30;

import "com/digitalasset/canton/admin/participant/v30/acs_import.proto";
import "com/digitalasset/canton/admin/participant/v30/synchronizer_connectivity.proto";
import "com/digitalasset/canton/admin/sequencer/v30/sequencer_connection.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

/**
 * Perform participant repair operations, including exporting and importing ACS, purging
 * contracts, and migrating synchronizers. These operations directly act on the internal state of the participant
 * and should be used with caution.
 *
 * Note that ACS refers to Active Contract Set.
 */
service ParticipantRepairService {
  // Export the ACS for the given parties from the participant
  // DEPRECATED: Use ExportAcs in this proto file
  // TODO(#24610) - Remove, replaced with ExportAcs below
  rpc ExportAcsOld(ExportAcsOldRequest) returns (stream ExportAcsOldResponse) {
    option deprecated = true;
  }

  // Import an existing export into the participant
  // DEPRECATED: Use ImportAcs in this proto file
  // TODO(#24610) - Remove, replaced with ImportAcs below
  rpc ImportAcsOld(stream ImportAcsOldRequest) returns (ImportAcsOldResponse) {
    option deprecated = true;
  }

  // Export the ACS from the participant.
  rpc ExportAcs(ExportAcsRequest) returns (stream ExportAcsResponse);

  // Import an existing export into the participant
  rpc ImportAcs(stream ImportAcsRequest) returns (ImportAcsResponse);

  // Remove the given contracts from the participant
  rpc PurgeContracts(PurgeContractsRequest) returns (PurgeContractsResponse);

  // Change the assignation of contracts to the given synchronizer and decommission the source synchronizer
  rpc MigrateSynchronizer(MigrateSynchronizerRequest) returns (MigrateSynchronizerResponse);
  // Change the assignation of a bunch of contracts
  rpc ChangeAssignation(ChangeAssignationRequest) returns (ChangeAssignationResponse);

  // Purge deactivated synchronizer
  rpc PurgeDeactivatedSynchronizer(PurgeDeactivatedSynchronizerRequest) returns (PurgeDeactivatedSynchronizerResponse);

  // Ignore events that the participant is unable to process
  rpc IgnoreEvents(IgnoreEventsRequest) returns (IgnoreEventsResponse);

  // Remove the ignored status from sequenced events
  // This command has no effect on ordinary (i.e., not ignored) events and on events that do not exist.
  rpc UnignoreEvents(UnignoreEventsRequest) returns (UnignoreEventsResponse);

  // Rollback the unassignment of a contract: the contract will be re-assigned back to the source synchronizer
  rpc RollbackUnassignment(RollbackUnassignmentRequest) returns (RollbackUnassignmentResponse);

  rpc RepairCommitmentsUsingAcs(RepairCommitmentsUsingAcsRequest) returns (RepairCommitmentsUsingAcsResponse);

  /**
     Perform a logical synchronizer upgrade
     This endpoint should ONLY be used when the following two conditions are met:
     - The participant node missed the upgrade on the old synchronizer, and
     - The old synchronizer has been decommissioned in the meantime.

     After the upgrade has been done, other repair operations might need to be done.
     This includes manually repairing the ACS to account for missed activity on both the old and new synchronizer.
  */
  rpc PerformSynchronizerUpgrade(PerformSynchronizerUpgradeRequest) returns (PerformSynchronizerUpgradeResponse);
}

message PurgeContractsRequest {
  // Alias of the synchronizer to which the contracts are currently assigned
  // Required
  string synchronizer_alias = 1;

  // Contracts to be purged
  // Required
  repeated string contract_ids = 2;

  // If true, will ignore already purged contract; if false, will return an error if a contract is already purged
  // Useful re-run the same request in case of failure in an idempotent fashion
  // Recommended value is `true`
  bool ignore_already_purged = 3;
}

message PurgeContractsResponse {}

message ChangeAssignationRequest {
  message Contract {
    string id = 1;

    // By default, reassignment counter will be increased by 1
    // This can be overridden by a non-empty value.
    optional int64 reassignment_counter_override = 2;
  }

  // Alias of the synchronizer to which the contracts are currently assigned
  // Required
  string source_synchronizer_alias = 1;
  // New assignation
  // Required
  string target_synchronizer_alias = 2;

  // Whether to skip inactive contracts. Default: true.
  bool skip_inactive = 3;

  repeated Contract contracts = 4;
}

message ChangeAssignationResponse {}

message MigrateSynchronizerRequest {
  // Alias of the synchronizer to which the contracts are currently assigned
  // Required
  string source_synchronizer_alias = 1;
  // Configuration to connect to the synchronizer on which the contracts will be assigned as a result of the migration
  // Required
  SynchronizerConnectionConfig target_synchronizer_connection_config = 2;
  // Whether to force the migration in spite of risking a potential ledger fork
  // Recommended value is `false`
  bool force = 3;
}

message MigrateSynchronizerResponse {}

message ExportAcsOldRequest {
  option deprecated = true;

  // The parties for which the ACS should be exported.
  // If empty, the ACS of all parties will be exported.
  // Optional
  repeated string parties = 1;

  // The IDs of the synchronizers to filter the contracts by
  // Optional, if set the contracts will be filtered by the exact match of the ID of the synchronizer to which it's assigned
  string filter_synchronizer_id = 2; // optional; exact match if set

  // The timestamp at which the ACS should be valid. If provided, it will be checked that the ACS is
  // available at the given timestamp (i.e. the timestamp is considered clean and the ACS has not been
  // pruned).
  // Optional, if missing the latest clean timestamp will be used
  google.protobuf.Timestamp timestamp = 3;

  // Mapping from one synchronizer id and protocol version. If provided, the contracts currently assigned to the synchronizer
  // ID in the key will be assigned to the synchronizer id and protocol version in the value. This is not a proper synchronizer
  // migration of contracts and it's supposed to be used only in exceptional cases.
  // Optional, if not provided the contracts will be exported with the same synchronizer id as they are currently assigned
  reserved 4; // was map<string, TargetSynchronizer> contract_synchronizer_renames

  // If true, do not check whether the provided timestamp is clean (see `timestamp` field).
  // NOT FOR PRODUCTION USE.
  // For this option to yield a consistent snapshot, you need to wait at least
  // confirmationResponseTimeout + mediatorReactionTimeout after the last submitted request.
  // Recommended value is `false`
  bool force = 5;

  // true if the parties will be offboarded after the replication (party migration)
  // Recommended value is `false`
  bool parties_offboarding = 6;
}

message ExportAcsOldResponse {
  option deprecated = true;

  // The raw binary of the ACS snapshot to be imported
  // This is meant to be streamed and every message should be a chunk of the snapshot
  // Required
  bytes chunk = 1;
}

message ImportAcsOldRequest {
  option deprecated = true;

  // The raw binary of the ACS snapshot to be imported
  // Required
  bytes acs_snapshot = 1;
  // The synchronizer id prefix to be used for the imported contracts
  // Optional, if not provided the service will generate a prefix
  string workflow_id_prefix = 2;

  // If false, the service will fail if any contract ID suffix doesn't match the scheme
  // associated to the synchronizer where the contract is being assigned as a result of the import.
  // If true, any contract ID suffix will be recomputed to match the scheme associated to the synchronizer.
  // Recommended value is `false`
  reserved 3; // was allow_contract_id_suffix_recomputation, default behavior is false
}

message ImportAcsOldResponse {
  option deprecated = true;

  reserved 1; // was map<string, string> contract_id_mapping
}

message ExportAcsTargetSynchronizer {
  // The identifier of the synchronizer to which contracts should be assigned upon exporting the
  // Active Contract Set (ACS).
  // Required.
  string target_synchronizer_id = 1;
}

message ExportAcsRequest {
  // The identifiers of the parties for which the Active Contract Set (ACS) will be exported.
  // This field must contain at least one party ID.
  // Required
  repeated string party_ids = 1;

  // The identifier of the synchronizer to filter contracts.
  // Optional. If provided, only contracts assigned to a synchronizer with this exact ID will be included
  // in the exported ACS. If not set (empty string), all contracts for the specified parties will be included.
  string synchronizer_id = 2; // Optional; filters by exact synchronizer ID if set

  // The ledger offset at which the ACS snapshot should be taken. This determines the point in the
  // ledger history from which the active contracts will be retrieved.
  // Required
  int64 ledger_offset = 3;

  // A mapping to modify the synchronizer assignment of contracts in the exported ACS.
  // Note: This mapping is not a proper contract reassignment. That is no actual reassignment happens, and thus
  // the reassignment counter is not increased.
  // Optional. If not provided (empty map), the contracts in the exported ACS will retain their
  // original synchronizer assignments.
  map<string, ExportAcsTargetSynchronizer> contract_synchronizer_renames = 4;

  // A list of party IDs to exclude from the export.
  // Any contract that has one or more of these parties as a stakeholder will be omitted from the ACS snapshot.
  // Optional
  repeated string excluded_stakeholder_ids = 5;
}

message ExportAcsResponse {
  // A chunk of the Active Contract Set (ACS) snapshot. This response is streamed, with each
  // message containing a portion of the complete ACS data.
  // The raw binary data within each chunk consists of Ledger API active contract messages, specifically wrapped
  // in `v30.active_contract.ActiveContract` messages. However, a single chunk does not necessarily contain
  // exactly one complete message.
  // This field will be populated in each streamed response.
  // Required
  bytes chunk = 1;
}

message ImportAcsRequest {
  // The raw binary of the ACS snapshot to be imported
  // The binary contents does not align on individual active contracts! It may contain bytes that are part of
  // an active contract, or include several active contracts - depending on how much data fits into the
  // configured gRPC message size.
  // Required
  bytes acs_snapshot = 1;

  // Custom prefix for the workflow ID to easily identify all transactions generated by this import.
  // Optional. If left empty, the service will generate a prefix such as `import-<random_UUID>`.
  string workflow_id_prefix = 2;

  // How imported contracts should be validated upon import
  //
  // NOTE: The representative package IDs assigned to imported contracts must ensure proper type-checking for those contracts.
  // Importing contracts representative_package_id's that do not type-check may cause unexpected behavior,
  // including INTERNAL errors on Ledger API read queries or incorrect Daml value representations.
  // If unsure, perform the ACS import with ContractImportMode set to CONTRACT_IMPORT_MODE_VALIDATION to ensure
  // that the assigned representative package IDs correctly validate the imported contracts.
  //
  // Required
  ContractImportMode contract_import_mode = 3;

  // A list of party IDs to exclude from the import.
  // Any contract that has one or more of these parties as a stakeholder will be omitted during the import.
  // Optional
  repeated string excluded_stakeholder_ids = 4;

  // The representative package ID override rules to be applied during import.
  //
  // Optional
  RepresentativePackageIdOverride representative_package_id_override = 5;
}

message ImportAcsResponse {
  reserved 1; // was map<string, string> contract_id_mappings = 1;
}

message PurgeDeactivatedSynchronizerRequest {
  // Alias of the deactivated synchronizer to purge data from
  string synchronizer_alias = 1;
}

message PurgeDeactivatedSynchronizerResponse {}

message IgnoreEventsRequest {
  string physical_synchronizer_id = 1;
  // sequencer counter of the first event to ignore
  int64 from_inclusive = 2;
  // sequencer counter of the last event to ignore
  int64 to_inclusive = 3;
  // allow to proceed even if some clean events have sequencer counter greater or equal than `from_inclusive`
  bool force = 4;
}

message IgnoreEventsResponse {}

message UnignoreEventsRequest {
  string physical_synchronizer_id = 1;
  // sequencer counter of the first event to unignore
  int64 from_inclusive = 2;
  // sequencer counter of the last event to unignore
  int64 to_inclusive = 3;
  // allow to proceed even if some clean events have sequencer counter greater or equal than `from_inclusive`
  bool force = 4;
}

message UnignoreEventsResponse {}

message RollbackUnassignmentRequest {
  // The ID of the unassignment.
  // Must be a valid LedgerString (as described in ``value.proto``).
  // Required
  string reassignment_id = 1;

  // The ID of the source synchronizer
  // Must be a valid synchronizer id
  // Required
  string source_synchronizer_id = 2;

  // The ID of the target synchronizer
  // Must be a valid synchronizer id
  // Required
  string target_synchronizer_id = 3;
}

message RollbackUnassignmentResponse {}

message RepairCommitmentsUsingAcsRequest {
  // The IDs of the synchronizers where to reinitialize commitments from ACS
  // If empty, we reinitialize commitments for all synchronizers
  repeated string synchronizer_ids = 1;

  // Reinitialize commitments only for the given counter-participant
  // If empty, we reinitialize commitments for all counter-participants
  repeated string counter_participant_ids = 2;

  // Reinitialize commitments only for the stakeholder groups containing the given parties
  // If empty, we reinitialize commitments for all stakeholder groups
  repeated string party_ids = 3;

  // The timeout to wait for command to return success
  // The success status can also be queried later using the `CommitmentsService`
  google.protobuf.Duration timeout_seconds = 4;
}

message RepairCommitmentsUsingAcsResponse {
  repeated RepairCommitmentsStatus statuses = 1;
}

message RepairCommitmentsStatus {
  string synchronizer_id = 1;
  oneof status {
    string error_message = 2;
    google.protobuf.Timestamp completed_repair_timestamp = 3;
  }
}

message PerformSynchronizerUpgradeRequest {
  message Successor {
    string physical_synchronizer_id = 1;

    // Value should be provided by synchronizer owners
    google.protobuf.Timestamp announced_upgrade_time = 2;

    SynchronizerConnectionConfig config = 3;

    com.digitalasset.canton.admin.sequencer.v30.SequencerConnectionValidation sequencer_connection_validation = 4;
  }

  string physical_synchronizer_id = 1;
  Successor successor = 2;
}

message PerformSynchronizerUpgradeResponse {}

// Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package com.digitalasset.canton.admin.participant.v30;

import "com/digitalasset/canton/admin/participant/v30/acs_import.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "scalapb/scalapb.proto";

/**
 * The PartyManagementService allows modifying party hosting on participants.
 *
 * Note that ACS refers to Active Contract Set.
 *
 * Important: The online and offline party replication endpoints serve distinct workflows,
 * and must not be combined.
 */
service PartyManagementService {
  // Online party replication endpoint.
  //
  // Initiate adding a party already hosted on one or more source participants to this
  // target participant in the specified synchronizer.
  // Performs some checks synchronously and then starts the party addition asynchronously.
  //
  // Depends on the party authorizing the PartyToParticipant topology proposal at the
  // specified topology_serial prior or concurrently to this endpoint. On the other hand,
  // this target participant authorizes the topology proposal as part of this endpoint in
  // a specific, intermediate step, and therefore the target participant signature must not
  // already be in place prior to the call.
  //
  // Returns a 'request_id' that is stable across each retry with the same request parameters.
  rpc AddPartyAsync(AddPartyAsyncRequest) returns (AddPartyAsyncResponse);

  // Online party replication endpoint.
  //
  // Add a party already hosted on one or more source participants to this target participant
  // in the specified synchronizer along with the party's Active Contract Set (ACS) streamed
  // in the request.
  // Uploads the ACS synchronously and then performs the party addition asynchronously.
  //
  // Returns a 'request_id' that is stable across each retry with the same request parameters.
  rpc AddPartyWithAcsAsync(stream AddPartyWithAcsAsyncRequest) returns (AddPartyWithAcsAsyncResponse);

  // Online party replication endpoint.
  //
  // Status endpoint that given an add_party_request_id returns status information about progress,
  // completion, or errors of a previous call to AddPartyAsync on the source or target
  // participant, or a previous call to AddPartyWithAcs on the target participant.
  //
  // Note that the status reflects the state as perceived by this participant and does not
  // imply the state of other participants. The status on the target participant is more
  // authoritative as the target participant drives the process of adding the party. For example
  // when the target participant status indicates "completed", the party has been added
  // successfully.
  rpc GetAddPartyStatus(GetAddPartyStatusRequest) returns (GetAddPartyStatusResponse);

  // Online and offline party replication ACS export.
  //
  // Exports the ACS of a single party from a source participant, so that the party can be
  // replicated onto a target participant.
  //
  // This endpoint works in conjunction with the AddPartyWithAcs and ImportPartyAcs endpoints.
  rpc ExportPartyAcs(ExportPartyAcsRequest) returns (stream ExportPartyAcsResponse);

  // Offline party replication focused ACS import.
  //
  // Imports the party's ACS into the target participant.
  //
  // This endpoint works in conjunction with ExportPartyAcs endpoint.
  rpc ImportPartyAcs(stream ImportPartyAcsRequest) returns (ImportPartyAcsResponse);

  // Offline party replication focused ACS import.
  //
  // Imports the party's ACS into the target participant.
  //
  // This endpoint works in conjunction with ExportPartyAcs endpoint.
  rpc ImportPartyAcsV2(stream ImportPartyAcsV2Request) returns (ImportPartyAcsV2Response);

  // For a given timestamp, find the highest ledger offset among all events that have record time <= timestamp.
  //
  // Returns a ledger offset, or an error otherwise. Depending on the error cause, a retry may make sense.
  // Retryable errors are defined as: OUT_OF_RANGE/INVALID_TIMESTAMP_PARTY_MANAGEMENT_ERROR.
  // Further, a returned offset is guaranteed to be "clean", meaning all events have been processed fully and
  // published to the Ledger API DB until the requested timestamp.
  rpc GetHighestOffsetByTimestamp(GetHighestOffsetByTimestampRequest) returns (GetHighestOffsetByTimestampResponse);

  // Offline party replication endpoint.
  //
  // Instructs the participant to unilaterally clear the 'onboarding' flag for a
  // given party on its party-to-participant topology mapping.
  //
  // The RPC first attempts to clear the flag immediately. If this is not yet safe
  // (e.g., due to potential in-flight transactions), it schedules an idempotent
  // background task to propose the clearance at the appropriate, safe time.
  //
  // This RPC is idempotent and designed to be polled.
  //
  // Response status:
  // - onboarded = true: The flag is successfully cleared or was already clear.
  // - onboarded = false: The flag is not yet cleared. A background task is scheduled
  //   (or was already pending).
  //
  // Prerequisites:
  // - An 'onboarding=true' mapping must exist for the party on this participant.
  // - The participant must be connected to the requested synchronizer.
  rpc ClearPartyOnboardingFlag(ClearPartyOnboardingFlagRequest) returns (ClearPartyOnboardingFlagResponse);
}

message AddPartyAsyncRequest {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  // Arguments common among AddPartyAsync and AddPartyWithAcs requests.
  // Required
  AddPartyArguments arguments = 1;
}

message AddPartyArguments {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  // The party to replicate
  // Required
  string party_id = 1;
  // The synchronizer in which to replicate the party
  // Required
  string synchronizer_id = 2;
  // A source participant already hosting the party
  // Required
  string source_participant_uid = 3;
  // The topology serial number of the PartyToParticipant topology transaction used to
  // add the party to this target participant.
  // Required
  uint32 topology_serial = 4;
  // The permission level of the party on the target participant.
  // Required
  ParticipantPermission participant_permission = 5;
}

message AddPartyAsyncResponse {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  // The identifier used to uniquely track the add party request.
  string add_party_request_id = 1;
}

message AddPartyWithAcsAsyncRequest {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  // The raw binary of the ACS snapshot to be imported
  // The binary content does not align on individual active contracts! It may contain bytes that are part of
  // an active contract, or include several active contracts - depending on how much data fits into the
  // configured gRPC message size.
  // Required
  bytes acs_snapshot = 1;

  // The add party arguments used for request validation and initialization.
  // Required for the first message of the stream, should be empty for subsequent messages.
  AddPartyArguments arguments = 2;
}

message AddPartyWithAcsAsyncResponse {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  // The identifier used to uniquely track the add party request.
  string add_party_request_id = 1;
}

message GetAddPartyStatusRequest {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  // The add party request ID returned by AddPartyAsync
  // Required
  string add_party_request_id = 1;
}

message GetAddPartyStatusResponse {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  PartyReplicationStatus status = 1;
}

// The PartyReplicationStatus describes the various pieces of state of a party replication.
message PartyReplicationStatus {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  // Static parameters that do not change throughout a single party replication operation.
  message ReplicationParameters {
    string request_id = 1;
    string party_id = 2;
    string synchronizer_id = 3;
    string source_participant_uid = 4;
    string target_participant_uid = 5;
    uint32 topology_serial = 6;
  }

  // Agreement among participants to replicate the ACS via sequencer channel.
  message SequencerChannelAgreement {
    // Sequencer hosting the channel for ACS replication.
    string sequencer_uid = 1;
  }

  // Authorization by party owners and target participant to onboard the party.
  message PartyReplicationAuthorization {
    // The timestamp at which the party onboarding authorization becomes effective
    // and the ACS snapshot for replication is based on.
    // required
    google.protobuf.Timestamp onboarding_at = 1;

    // Whether the party is fully onboarded to the target participant.
    // A value of true means:
    // - The party's ACS has been completely replicated to the target participant, and
    // - the party participates in Daml transactions according to its target participant hosting permission.
    // required
    bool is_onboarding_flag_cleared = 2;
  }

  // Progress of ACS replication.
  message AcsReplicationProgress {
    // Non negative number of ACS contracts sent by the source or persisted by the target participant.
    // required
    uint32 processed_contract_count = 1;
    // Whether replication has been fully processed the ACS.
    // required
    bool fully_processed_acs = 2;
  }

  // Progress of ACS indexing the Ledger Api.
  message AcsIndexingProgress {}

  // Error message when disconnected or operator intervention needed.
  message PartyReplicationError {
    // Error message.
    // required
    string error_message = 2;
  }

  // Static party replication parameters.
  // required
  ReplicationParameters parameters = 1;
  // Sequencer channel agreement.
  // optional, set if there is an agreement to replicate the ACS via sequencer channel.
  SequencerChannelAgreement agreement = 2;
  // Topology authorization.
  // optional, set once the party onboarding has been authorized via topology.
  PartyReplicationAuthorization authorization = 3;
  // ACS replication progress.
  // optional, set once the ACS replication has started.
  AcsReplicationProgress replication = 4;
  // Indexing progress.
  // optional, set once indexing of the ACS has started.
  AcsIndexingProgress indexing = 5;
  // Whether the party has been successfully replicated to the target participant,
  // i.e. whether party replication has succeeded and is done.
  // required
  bool has_completed = 6;
  // Error details.
  // optional, set when there is a transient or terminal error.
  PartyReplicationError error_message = 7;
}

// Enum indicating the permission level of the party on the target participant.
// Refer to topology.proto:`ParticipantPermission` for definitions.
enum ParticipantPermission {
  PARTICIPANT_PERMISSION_UNSPECIFIED = 0;

  PARTICIPANT_PERMISSION_SUBMISSION = 1;

  PARTICIPANT_PERMISSION_CONFIRMATION = 2;

  PARTICIPANT_PERMISSION_OBSERVATION = 3;
}

// Exports the ACS for a given party to facilitate its replication from a source to a target participant.
//
// This request uses the party's most recent activation on the target participant to determine the precise
// historical state of the ACS to export from the source participant.
//
// "Activation" on the target participant means the new hosting arrangement has been authorized by both
// the party itself and the target participant via party-to-participant topology transactions.
//
// This request will fail if the party has not yet been activated on the target participant.
message ExportPartyAcsRequest {
  // The identifier of the party being replicated. This party must already be active on the target participant
  // for the ACS export to succeed.
  // Required
  string party_id = 1;

  // The identifier of the synchronizer managing the contract to be exported. This scopes the ACS export to only
  // contracts assigned to this synchronizer.
  // Required
  string synchronizer_id = 2;

  // The unique identifier of the target participant where the party will be replicated.
  // Required
  string target_participant_uid = 3;

  // The exclusive ledger offset used as starting point to find the party's most recent activation on the target
  // participant.
  // Required
  int64 begin_offset_exclusive = 4;

  // The maximum duration the service will wait to find the topology transaction that activates the party on
  // the target participant.
  // If not set, the service will use a default timeout.
  // Optional
  google.protobuf.Duration wait_for_activation_timeout = 5;
}

message ExportPartyAcsResponse {
  // A chunk of the ACS snapshot. This response is streamed, with each message containing a portion of the
  // complete ACS data. The raw binary data within each chunk consists of Ledger API active contract messages,
  // specifically wrapped in `v30.active_contract.ActiveContract` messages. However, a single chunk does not
  // necessarily contain exactly one complete message.
  // This field will be populated in each streamed response.
  // Required
  bytes chunk = 1;
}

message ImportPartyAcsRequest {
  // The raw binary of the ACS snapshot to be imported
  // The binary content does not align on individual active contracts! It may contain bytes that are part of
  // an active contract, or include several active contracts - depending on how much data fits into the
  // configured gRPC message size.
  // Required
  bytes acs_snapshot = 1;

  // Custom prefix for the workflow ID to easily identify all transactions generated by this import.
  // Optional. If left empty, the service will generate a prefix such as `import-<random_UUID>`.
  string workflow_id_prefix = 2;

  // How imported contracts should be validated upon import.
  //
  // NOTE: The representative package IDs assigned to imported contracts must ensure proper type-checking for those contracts.
  // Importing contracts representative_package_id's that do not type-check may cause unexpected behavior,
  // including INTERNAL errors on Ledger API read queries or incorrect Daml value representations.
  // If unsure, perform the ACS import with ContractImportMode set to CONTRACT_IMPORT_MODE_VALIDATION to ensure
  // that the assigned representative package IDs correctly validate the imported contracts.
  //
  // Required
  ContractImportMode contract_import_mode = 3;

  // The representative package ID override rules to be applied during import.
  //
  // Optional
  RepresentativePackageIdOverride representative_package_id_override = 4;
}

message ImportPartyAcsResponse {}

message ImportPartyAcsV2Request {
  // The raw binary of the ACS snapshot to be imported
  // The binary content does not align on individual active contracts! It may contain bytes that are part of
  // an active contract, or include several active contracts - depending on how much data fits into the
  // configured gRPC message size.
  // Required
  bytes acs_snapshot = 1;

  // The identifier of the synchronizer managing the contract to be imported. If a contract has a different synchronizer, import will fail.
  // Required for the first message of the stream, should be empty for subsequent messages.
  optional string synchronizer_id = 2;

  // Custom prefix for the workflow ID to easily identify all transactions generated by this import.
  // Optional. If left empty, the service will generate a prefix such as `import-<random_UUID>`.
  // Might be defined only for the first message of the stream.
  optional string workflow_id_prefix = 3;

  // How imported contracts should be validated upon import.
  //
  // NOTE: The representative package IDs assigned to imported contracts must ensure proper type-checking for those contracts.
  // Importing contracts representative_package_id's that do not type-check may cause unexpected behavior,
  // including INTERNAL errors on Ledger API read queries or incorrect Daml value representations.
  // If unsure, perform the ACS import with ContractImportMode set to CONTRACT_IMPORT_MODE_VALIDATION to ensure
  // that the assigned representative package IDs correctly validate the imported contracts.
  //
  // Required for the first message of the stream, should be empty for subsequent messages.
  optional ContractImportMode contract_import_mode = 4;

  // The representative package ID override rules to be applied during import.
  //
  // Optional. Can be non-empty only on the first message of the stream.
  optional RepresentativePackageIdOverride representative_package_id_override = 5;
}

message ImportPartyAcsV2Response {}

// Requests the highest ledger offset among all events belonging to the synchronizer (`synchronizer_id`)
// that have a record time before or at the given `timestamp`.
//
// This endpoint features a `force` message field. This is intended for disaster recovery scenarios only.
message GetHighestOffsetByTimestampRequest {
  // The identifier of the synchronizer.
  // Required
  string synchronizer_id = 1;

  // The requested timestamp for which a ledger offset should be found.
  // Required
  google.protobuf.Timestamp timestamp = 2;

  // If true, return the highest known ledger offset with a record time before or at the specified `timestamp`
  // even if higher offsets with a record time before or at `timestamp` can be created in the future.
  // Required, defaults to false.
  bool force = 3;
}

message GetHighestOffsetByTimestampResponse {
  // The highest ledger offset among events that have their record time before or at the requested timestamp.
  // An error when no such offset (yet) exists.
  // Required
  int64 ledger_offset = 1;
}

// Request to clear the 'onboarding' flag for a party.
//
// The participant uses the `begin_offset_exclusive` and `wait_for_activation_timeout` to find the
// effective timestamp of the topology transaction that set the `onboarding = true` flag.
//
// This effective timestamp serves as the "lower bound" for calculating the "latest decision deadline"
// which determines the earliest safe time to clear the flag.
message ClearPartyOnboardingFlagRequest {
  // The identifier of the party whose onboarding flag is being cleared. This party must
  // already be active on the target participant.
  // Required
  string party_id = 1;

  // The identifier of the synchronizer.
  // Required
  string synchronizer_id = 2;

  // The exclusive ledger offset used as a starting point to find the party's most
  // recent activation on the target participant.
  // Required
  int64 begin_offset_exclusive = 3;

  // The maximum duration the service will wait to find the topology transaction
  // that activates the party.
  // If not set, the service will use a default timeout.
  // Optional
  google.protobuf.Duration wait_for_activation_timeout = 4;
}

//  Responds with the current status of the onboarding flag:
//
//  - Cleared: (true, None) – The flag is successfully cleared.
//
//  - Pending: (false, Some(timestamp)) – The flag is still set. The timestamp indicates
//             the earliest safe time to clear the flag.
//             Calling the service (repeatedly) after that specific time will eventually confirm
//             that the onboarding flag has been cleared (that is `onboarded = true`).
//
//             The onboarding flag remains for two reasons:
//             1. The safe time to clear the flag has not yet been reached.
//             2. The clearing transaction was proposed, but it has not yet become effective.
message ClearPartyOnboardingFlagResponse {
  // Indicates the current party onboarding status.
  // Required
  bool onboarded = 1;

  // The earliest time for the safe clearance of the onboarding flag.
  //
  // This field is only present when `onboarded` is `false`. It represents the
  // computed "latest decision deadline", which is the maximum of all `validUntil + decisionTimeout`
  // from the synchronizer's parameter history, ensuring all past in-flight transactions are finalized.
  optional google.protobuf.Timestamp earliest_retry_timestamp = 2;
}

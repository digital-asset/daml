// Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.digitalasset.transcode.conformance.generator

import com.digitalasset.transcode.conformance.{RoundtripId, TestCase}
import com.digitalasset.transcode.schema.*

import java.time.format.TextStyle
import java.time.{LocalDate, LocalDateTime, ZoneOffset}
import java.util.Locale
import scala.collection.mutable

object DamlRoundtrip:
  private type Defs = mutable.Map[Identifier, (Seq[Identifier], String)]

  def generate[TC <: TestCase](testCases: TC): Map[os.RelPath, String] =
    given defs: Defs = mutable.Map.empty

    val (refImports, refs) = testCases.cases.map((_, d, _) => toDamlRef(d)).unzip
    val vals = testCases.cases.map((name, d, dv) => name -> toDamlValue(d, dv)(using Map.empty))

    val importStatements = refImports.flatten
      .filterNot(_ == RoundtripId)
      .map(id => s"import qualified ${id.moduleName}")
      .distinct
      .sorted
      .mkString("\n")
    val choiceDefs =
      refs
        .zip(vals)
        .map { case (tpe, (testName, value)) => (testName, tpe, value) }
        .map((testName, tpe, value) => s"""
    nonconsuming choice $testName: $tpe with payload: $tpe controller party
      do
        assert (payload == $value)
        return payload
""").mkString
    val failingChoices =
      testCases.failing
        .map((testName, _, d, _) => s"""
    nonconsuming choice $testName: () with payload: ${toDamlRef(d)._2} controller party
      do
        return ()
""").mkString

    val RoundtripTemplate = (os.rel / RoundtripId.moduleName) ->
      s"""module ${RoundtripId.moduleName} where

-- This file is generated by GenerateDamlTestDefinition in transcode-test-conformance
-- To update it, add some definitions in com.digitalasset.transcode.conformance.data.All and run
-- sbt "transcode-test-conformance / run"

$importStatements
import qualified DA.Time
import qualified DA.Date

template ${RoundtripId.entityName}
  with
    party: Party
  where
    signatory party
$choiceDefs
$failingChoices

"""

    val types = defs.toSeq
      .filterNot((id, _) => id == RoundtripId)
      .groupMapReduce(_._1.moduleName)(x => (x._2._1, Seq(x._2._2)))((a, b) =>
        (a._1 ++ b._1) -> (a._2 ++ b._2)
      )
      .toList
      .map { case (moduleName, (imports, defs)) =>
        val importStatements = imports
          .filter(_.moduleName != moduleName)
          .map(id => s"import qualified ${id.moduleName}")
          .distinct
          .sorted
          .mkString("\n")
        moduleName.split('.').foldLeft(os.rel)(_ / _) -> s"""
module $moduleName where
$importStatements
${defs.map(_.replace(s"$moduleName.", "")).mkString("\n")}
"""
      }
    (types :+ RoundtripTemplate).toMap.map((p, t) => addExt(p, "daml") -> t)

  private def addExt(path: os.RelPath, ext: String): os.RelPath =
    val prefix = path.segments.dropRight(1)
    val suffix = path.segments.lastOption.map(_ + s".$ext").getOrElse("")
    os.RelPath(prefix :+ suffix, 0)

  def toDef(id: Identifier, descriptor: Descriptor.Adt, params: Seq[TypeVarName])(using
      defs: Defs
  ): Unit =
    if !defs.contains(id) then
      val _ = defs.put(id, (Seq.empty, "")) // stop cycles in case of recursion
      descriptor match
        case Descriptor.Record(fields) =>
          val (imports, refs) = fields.map((_, t) => toDamlRef(t)).unzip
          val fieldDefs = fields.zip(refs).map { case ((n, t), ref) => s"$n: $ref" }.mkString(", ")
          val content = s"""
data ${id.entityName} ${params.mkString(" ")} = ${id.entityName} with $fieldDefs
  deriving (Eq, Show, Ord)"""
          val _ = defs.put(id, (imports.flatten, content))
        case Descriptor.Variant(cases) =>
          val (imports, caseDefs) = cases
            .map((n, d) =>
              d match
                case Descriptor.Record.Embedded(_, fields) =>
                  val (imports, ref) = fields.map((_, t) => toDamlRef(t)).unzip
                  (
                    imports.flatten,
                    s"$n with ${fields.map(_._1).zip(ref).map((n, r) => s"$n: $r").mkString(", ")}",
                  )
                case Descriptor.Unit =>
                  (Seq.empty, n)
                case other =>
                  val (imports, ref) = toDamlRef(other)
                  (imports, s"$n $ref")
            )
            .unzip
          val content = s"""
data ${id.entityName} ${params.mkString(" ")}
    = ${caseDefs.mkString("\n    | ")}
  deriving (Eq, Show, Ord)"""
          val _ = defs.put(id, (imports.flatten, content))

        case Descriptor.Enumeration(cases) =>
          val content = s"""
data ${id.entityName} = ${cases.mkString(" | ")}
  deriving (Eq, Show, Ord)"""
          val _ = defs.put(id, (Seq.empty, content))

  def toDamlValue(descriptor: Descriptor, dv: DynamicValue)(using
      vars: Map[TypeVarName, Descriptor]
  ): String =
    descriptor match
      case Descriptor.Constructor.Applied(id, varMap, body) =>
        given Map[TypeVarName, Descriptor] = varMap.map {
          case (name, Descriptor.Variable(varName)) => name -> vars(varName)
          case other => other
        }.toMap
        body match
          case Descriptor.Record(fields) =>
            s"${id.moduleName}.${id.entityName} with " + fields
              .zip(dv.recordIteratorPadded(fields.size))
              .map { case ((fname, tpe), v) => s"$fname=(${toDamlValue(tpe, v)})" }
              .mkString(",")
          case Descriptor.Variant(cases) =>
            val (caseIx, caseValue) = dv.variant
            val (caseName, caseDescriptor) = cases(caseIx)
            s"${id.moduleName}.$caseName" + (caseDescriptor match
              case Descriptor.Record.Embedded(_, fields) =>
                " with " + fields
                  .zip(caseValue.recordIteratorPadded(fields.size))
                  .map { case ((fname, tpe), v) => s"$fname=(${toDamlValue(tpe, v)})" }
                  .mkString(",")
              case Descriptor.Unit => ""
              case other => s"(${toDamlValue(other, caseValue)})"
            )
          case Descriptor.Enumeration(cases) => s"${id.moduleName}.${cases(dv.enumeration)}"

      case Descriptor.Variable(name) => toDamlValue(vars(name), dv)

      case Descriptor.List(value) =>
        s"[${dv.list.iterator.map(dv => toDamlValue(value, dv)).mkString(",")}]"
      case Descriptor.Optional(d) =>
        dv.optional match
          case Some(dv) => s"Some (${toDamlValue(d, dv)})"
          case None => "None"
      case Descriptor.TextMap(v) =>
        s"DA.TextMap.fromList [${dv.textMap.iterator
            .map((dk, dv) => s"(${toDamlValue(Descriptor.text, DynamicValue.Text(dk))}, (${toDamlValue(v, dv)}))")
            .mkString(", ")}]"
      case Descriptor.GenMap(k, v) =>
        s"DA.Map.fromList [${dv.genMap.iterator
            .map((dk, dv) => s"((${toDamlValue(k, dk)}), (${toDamlValue(v, dv)}))")
            .mkString(", ")}]"
      case Descriptor.Unit => "()"
      case Descriptor.Bool => if dv.bool then "True" else "False"
      case Descriptor.Text =>
        s""""${dv.text
            .map(c => if c.isLetterOrDigit || c.isSpaceChar then c.toString else s"\\${c.toInt}\\&")
            .mkString}""""
      case Descriptor.Int64 => dv.int64.toString
      case Descriptor.Numeric(scale) => BigDecimal(dv.numeric).setScale(scale).toString()
      case Descriptor.Timestamp =>
        val time = LocalDateTime
          .ofEpochSecond(dv.timestamp / 1_000_000, 0, ZoneOffset.UTC)
          .plusNanos((dv.timestamp % 1_000_000) * 1_000)
        val month = time.getMonth.getDisplayName(TextStyle.SHORT, Locale.US)
        val dateStr = s"DA.Date.date (${time.getYear}) DA.Date.$month ${time.getDayOfMonth}"
        val microseconds = time.getNano / 1_000
        val base = s"DA.Time.time ($dateStr) ${time.getHour} ${time.getMinute} ${time.getSecond}"
        if microseconds == 0
        then base
        else s"DA.Time.addRelTime ($base) (DA.Time.microseconds $microseconds)"
      case Descriptor.Date =>
        val date = LocalDate.ofEpochDay(dv.date)
        val month = date.getMonth.getDisplayName(TextStyle.SHORT, Locale.US)
        s"DA.Date.date (${date.getYear}) DA.Date.$month ${date.getDayOfMonth}"
      case Descriptor.Party => "payload" // sentinel, not implemented yet
      case Descriptor.ContractId(value) => "payload" // sentinel, not implemented yet

  def toDamlRef(d: Descriptor)(using Defs): (Seq[Identifier], String) = d match
    case Descriptor.List(value) =>
      val (imports, ref) = toDamlRef(value)
      (imports, s"[$ref]")
    case Descriptor.Optional(value) =>
      val (imports, ref) = toDamlRef(value)
      (imports, s"Optional ($ref)")
    case Descriptor.TextMap(value) =>
      val (valueImports, valueRef) = toDamlRef(value)
      (valueImports ++ Seq(toId("DA.TextMap.TextMap")), s"DA.TextMap.TextMap ($valueRef)")
    case Descriptor.GenMap(key, value) =>
      val (keyImports, keyRef) = toDamlRef(key)
      val (valueImports, valueRef) = toDamlRef(value)
      (keyImports ++ valueImports ++ Seq(toId("DA.Map.Map")), s"DA.Map.Map ($keyRef) ($valueRef)")

    case Descriptor.Unit => (Seq.empty, "()")
    case Descriptor.Bool => (Seq.empty, "Bool")
    case Descriptor.Text => (Seq.empty, "Text")
    case Descriptor.Int64 => (Seq.empty, "Int")
    case Descriptor.Numeric(scale) => (Seq.empty, s"Numeric $scale")
    case Descriptor.Timestamp => (Seq.empty, "Time")
    case Descriptor.Date => (Seq.empty, "Date")
    case Descriptor.Party => (Seq.empty, "Party")
    case Descriptor.ContractId(value) =>
      val (imports, ref) = toDamlRef(value)
      (imports, s"ContractId $ref")
    case Descriptor.Variable(name) => (Seq.empty, name)
    case Descriptor.Constructor.Applied(id, varMap, body) =>
      toDef(id, body, varMap.map(_._1))
      val (imports, refs) = varMap.map(_._2).map(toDamlRef(_)).unzip
      (
        id +: imports.flatten,
        s"${id.moduleName}.${id.entityName} ${refs.map(x => s"($x)").mkString(" ")}",
      )

  private def toId(fqn: String) = Identifier(
    PackageId("0"),
    PackageName(""),
    PackageVersion.Unknown,
    ModuleName(fqn.split('.').dropRight(1).mkString(".")),
    EntityName(fqn.split('.').last),
  )

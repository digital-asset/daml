// Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package com.digitalasset.canton.participant.protocol.v30;

import "com/digitalasset/canton/admin/participant/v30/active_contract.proto";
import "com/digitalasset/canton/protocol/v30/topology.proto";
import "google/protobuf/timestamp.proto";
import "scalapb/scalapb.proto";

/**
 * Party replication protocol message sent by the target participant to the source participant.
 */
message PartyReplicationTargetParticipantMessage {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  // The Initialize instruction must be the first message to the source participant
  // and must never be sent as the second or later message.
  message Initialize {
    option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";
    // The ACS contract ordinal (0-based) to send as part of the first SendAcsUpTo instruction.
    uint32 initial_contract_ordinal_inclusive = 1;
  }

  // SendAcsUpTo instructs the source participant to send ordered ACS contracts up to a specified
  // maximum ordinal.
  // This instruction lets the target participant flow-control the rate of ACS ingestion.
  message SendAcsUpTo {
    option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";
    // ACS contract ordinal (0-based) deterministic on the source participant. This serves as a
    // watermark specifying up to which contract ordinal inclusively the source participant is expected
    // to send ACS contracts.
    // Required
    uint32 max_contract_ordinal_inclusive = 1;
  }

  oneof instruction {
    Initialize initialize = 1;
    SendAcsUpTo send_acs_up_to = 2;
  }
}

/**
 * Party replication protocol message sent by the source participant to the target participant.
 */
message PartyReplicationSourceParticipantMessage {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  // Batch of ACS contracts previously requested by the target participant.
  message AcsBatch {
    option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

    // The portion of the ACS in the batch expressed as nonempty list
    // Required
    repeated com.digitalasset.canton.admin.participant.v30.ActiveContract contracts = 1;
  }

  message EndOfAcs {
    option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";
  }

  oneof data_or_status {
    AcsBatch acs_batch = 1;
    EndOfAcs end_of_acs = 2;
  }
}

// The PartyReplicationStatus describes the various pieces of state of a party replication.
message PartyReplicationStatus {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  // Static parameters that do not change throughout a single party replication operation.
  message ReplicationParameters {
    string request_id = 1;
    string party_id = 2;
    string synchronizer_id = 3;
    string source_participant_uid = 4;
    string target_participant_uid = 5;
    uint32 topology_serial = 6;
    com.digitalasset.canton.protocol.v30.Enums.ParticipantPermission participant_permission = 7;
  }

  // Agreement among participants to replicate the ACS via sequencer channel.
  message SequencerChannelAgreement {
    // Daml admin workflow party replication contract id.
    // required
    string contract_id = 1;

    // Sequencer hosting the channel for ACS replication.
    string sequencer_uid = 2;
  }

  // Authorization by party owners and target participant to onboard the party.
  message PartyReplicationAuthorization {
    // The timestamp at which the party onboarding authorization becomes effective
    // and the ACS snapshot for replication is based on.
    // required
    google.protobuf.Timestamp onboarding_at = 1;

    // Whether the party is fully onboarded to the target participant.
    // A value of true means:
    // - The party's ACS has been completely replicated to the target participant, and
    // - the party participates in Daml transactions according to its target participant hosting permission.
    // required
    bool is_onboarding_flag_cleared = 2;
  }

  // Progress of ACS replication.
  message AcsReplicationProgress {
    // Non negative number of ACS contracts sent by the source or persisted by the target participant.
    // required
    uint32 processed_contract_count = 1;
    // The next counter to use for persistence on the target participant
    // required, not used and always -1 on the source participant
    uint64 next_persistence_counter = 2;
    // Whether replication has been fully processed the ACS.
    // required
    bool fully_processed_acs = 3;
  }

  // Progress of ACS indexing the Ledger Api.
  message AcsIndexingProgress {
    // Non negative number of ACS contracts indexed.
    // required
    uint32 indexed_contract_count = 1;
    // The next counter to use for indexing.
    // required
    uint64 next_indexing_counter = 2;
  }

  // Error message when disconnected or operator intervention needed.
  message PartyReplicationError {
    enum ErrorType {
      ERROR_TYPE_UNSPECIFIED = 0;
      // Adding the party has failed and operator intervention may be needed.
      ERROR_TYPE_FAILED = 2;
      // Adding the party is encountering connectivity issues and is expected
      // to proceed once reconnected.
      ERROR_TYPE_DISCONNECTED = 3;
    }

    // Error code indicating whether add party is proceeding or stuck.
    // required
    ErrorType error_type = 1;

    // Error message.
    // required
    string error_message = 2;
  }

  // Static party replication parameters.
  // required
  ReplicationParameters parameters = 1;
  // Sequencer channel agreement.
  // optional, set if there is an agreement to replicate the ACS via sequencer channel.
  SequencerChannelAgreement agreement = 2;
  // Topology authorization.
  // optional, set once the party onboarding has been authorized via topology.
  PartyReplicationAuthorization authorization = 3;
  // ACS replication progress.
  // optional, set once the ACS replication has started.
  AcsReplicationProgress replication = 4;
  // Indexing progress.
  // optional, set once indexing of the ACS has started.
  AcsIndexingProgress indexing = 5;
  // Whether the party has been successfully replicated to the target participant,
  // i.e. whether party replication has succeeded and is done.
  // required
  bool has_completed = 6;
  // Error details.
  // optional, set when there is a transient or terminal error.
  PartyReplicationError error_message = 7;
}

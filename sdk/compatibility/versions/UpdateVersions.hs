-- Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Main (main) where

import Control.Concurrent.Async
import Control.Lens (view)
import Control.Monad
import Crypto.Hash (digestFromByteString, hashlazy, Digest, SHA256)
import Data.ByteArray.Encoding (Base(Base16), convertFromBase, convertToBase)
import Data.ByteString (ByteString)
import qualified Data.ByteString.Lazy as BSL
import Data.Either (fromRight, rights)
import Data.Either.Extra (eitherToMaybe)
import Data.List
import Data.List.Extra (firstJust)
import Data.Map (Map)
import Data.Maybe (fromJust, fromMaybe, mapMaybe)
import qualified Data.Map.Strict as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.SemVer (Version)
import qualified Data.SemVer as SemVer
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import Network.HTTP.Client (responseTimeout, responseTimeoutMicro)
import Network.HTTP.Simple
import Options.Applicative
import System.FilePath (dropExtension)
import System.IO.Extra
import qualified System.Process

minimumVersion :: Version
minimumVersion =  fromRight (error "Invalid version") $ SemVer.fromText "3.0.0"

headVersion :: Version
headVersion = SemVer.initial

-- We include this here so buildifier does not modify this file.
copyrightHeader :: [T.Text]
copyrightHeader =
    [ "# Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved."
    , "# SPDX-License-Identifier: Apache-2.0"
    ]

renderVersionsFile :: Map Version (Version, Checksums) -> T.Text
renderVersionsFile versions =
    T.unlines $ concat
        [ copyrightHeader
        , [ "# This file is autogenerated and should not be modified manually."
          , "# Update versions/UpdateVersions.hs instead."
          ]
        , [ "sdk_versions = [" ]
        , map renderTodoVersion (Map.keys versions <> [headVersion])
        , [ "]"]
        , [ "platform_versions = [" ]
        , map renderTodoVersion (Map.keys versions <> [headVersion])
        , [ "]" ]
        , [ "stable_versions = [" ]
        , map renderTodoVersion (Map.keys stableVersions <> [headVersion])
        , [ "]" ]
        , [ "latest_stable_version = \"" <> SemVer.toText latestVersion <> "\"" ]
        , [ "version_sha256s = {"]
        , concatMap renderChecksums (Map.toList $ snd <$> versions)
        , [ "}" ]
        , [ "internal_sdk_versions = {" ]
        , map renderInternalVersions (Map.toList $ fst <$> versions)
        , [ "}" ]
        ]
  where
    renderChecksums (ver, Checksums{..}) = concat
      [ [ "    \"" <> SemVer.toText ver <> "\": {"
        , "        \"linux\": " <> renderDigest linuxHash <> ","
        , "        \"macos\": " <> renderDigest macosHash <> ","
        , "        \"windows\": " <> renderDigest windowsHash <> ","
        , "        \"daml_types\": " <> renderDigest damlTypesHash <> ","
        , "        \"daml_ledger\": " <> renderDigest damlLedgerHash <> ","
        ]
      , [ "    }," ]
      ]
    renderDigest digest = T.pack $ show (convertToBase Base16 digest :: ByteString)
    renderTodoVersion ver = "    \"" <> SemVer.toText ver <> "\","
    stableVersions = Map.filterWithKey (const . null . view SemVer.release) versions
    firstVersion = SemVer.version 3 3 0 [fromJust $ SemVer.textual "snapshot", SemVer.numeric 20250930, SemVer.numeric 0] []
    latestVersion = if Map.null versions then firstVersion else fst $ Map.findMax versions
    renderInternalVersions (releaseVer, sdkVer) = "    \"" <> SemVer.toText releaseVer <> "\": \"" <> SemVer.toText sdkVer <> "\","

data Opts = Opts
  { outputFile :: FilePath
  } deriving Show

data Checksums = Checksums
  { linuxHash :: Digest SHA256
  , macosHash :: Digest SHA256
  , windowsHash :: Digest SHA256
  , damlTypesHash :: Digest SHA256
  , damlLedgerHash :: Digest SHA256
  -- ^ Nothing for older versions
  }

semverUnsafeFromText :: T.Text -> Version
semverUnsafeFromText = either error id . SemVer.fromText

-- 3.3 artifacts were missing sha for macos for a while, keep a backup in code
-- Map from version to list of (hash, artifact path)
fallbackShas :: Map Version [(T.Text, T.Text)]
fallbackShas = Map.fromList
  [ ( semverUnsafeFromText "3.3.0-snapshot.20250930.0"
    , [("dd1b798a688123cfbc95fb2b6a7e1799c98aa6754924fde154c05140ea0818fb", "./daml-sdk-3.3.0-snapshot.20250926.13852.1.v4f3223e3-macos-x86_64.tar.gz")])
  ]

-- Returns checksums and derived sdk version from release version
getChecksums :: Version -> IO (Version, Checksums)
getChecksums releaseVer = do
    putStrLn ("Requesting hashes for " <> SemVer.toString releaseVer)
    req <- parseRequestThrow sha256Url
    linesNoFallback <- map T.words . T.lines . T.decodeUtf8 . BSL.toStrict . getResponseBody <$> httpLbs req
    let lines = linesNoFallback ++ maybe [] (fmap $ \(x, y) -> [x, y]) (Map.lookup releaseVer fallbackShas)
        damlVer =
          if not $ null $ view SemVer.release releaseVer
            -- snapshots have different daml ver to release ver, need daml ver to find artifacts
            -- use the test evidence sha to find the version, easiest parsing
            then
              fromMaybe
                (error $ "Couldn't find daml version for " ++ SemVer.toString releaseVer)
                (firstJust (fmap semverUnsafeFromText . T.stripPrefix "./test-evidence-" . T.pack . dropExtension . T.unpack . (!! 1)) lines)
            else releaseVer

    Just [linuxHash, macosHash, windowsHash] <- pure $
        forM [sdkFilePath damlVer "linux-x86_64", sdkFilePath damlVer "macos-x86_64", sdkFilePath damlVer "windows-x86_64"] $ \path -> do
            -- This is fairly hacky but given that we only run this script
            -- offline that seems fine for now.
            (base16Hash : _) <- find (\line -> path == line !! 1) lines
            byteHash <- (eitherToMaybe . convertFromBase Base16 . T.encodeUtf8) base16Hash
            digestFromByteString @SHA256 @ByteString byteHash
    [ damlTypesHash, damlLedgerHash] <-
        forConcurrently
            [ tsLib damlVer "types"
            , tsLib damlVer "ledger"
            ] getHash
    pure (damlVer, Checksums {..})
  where sdkFilePath damlVer platform = T.pack $
            "./daml-sdk-" <> SemVer.toString damlVer <> "-" <> platform <> ".tar.gz"
        sha256Url =
            "https://github.com/digital-asset/daml/releases/download/v" <>
            SemVer.toString releaseVer <> "/sha256sums"
        tsLib damlVer name =
            "https://registry.npmjs.org/@daml/" <> name <>
            "/-/" <> name <> "-" <> SemVer.toString damlVer <> ".tgz"
        getHash url = do
          req <- parseRequestThrow url
          bs <- httpLbs req { responseTimeout = responseTimeoutMicro (60 * 10 ^ (6 :: Int) ) }
          let !hash = hashlazy (getResponseBody bs)
          pure hash

optsParser :: Parser Opts
optsParser = Opts
  <$> strOption (short 'o' <> help "Path to output file")

getMinor :: Version -> String
getMinor v = show (view SemVer.major v) <> "." <> show (view SemVer.minor v)

getVersionsFromTags :: IO (Set Version)
getVersionsFromTags = do
    tags <- lines <$> System.Process.readProcess "git" ["tag"] ""
    let versions = Set.fromList $ rights $ mapMaybe (fmap (SemVer.fromText . T.pack) . stripPrefix "v") tags
        versionFilter ver = null (view SemVer.release ver) || Set.member (getMinor ver) snapshotReleases
    return $ latestPatchVersions $ Set.filter versionFilter versions

-- | Given a set of versions filter it to those that are the latest patch release in a given
-- major.minor series.
latestPatchVersions :: Set Version -> Set Version
latestPatchVersions allVersions =
    Set.filter (\version -> all (f version) allVersions) allVersions
  where
    f this that = toMajorMinor this /= toMajorMinor that || toPatchRelease this >= toPatchRelease that
    toMajorMinor v = (view SemVer.major v, view SemVer.minor v)
    toPatchRelease v = (view SemVer.patch v, view SemVer.release v)

snapshotReleases :: Set String
snapshotReleases = Set.fromList ["3.3"]

main :: IO ()
main = do
    Opts{..} <- execParser (info optsParser fullDesc)
    stableVers <- getVersionsFromTags
    let filterVersions = Set.filter (>= minimumVersion) stableVers
    versionsWithChecksums <-
      Map.fromList <$> mapM (\ver -> (ver,) <$> getChecksums ver) (Set.toList filterVersions)

    writeFileUTF8 outputFile (T.unpack $ renderVersionsFile versionsWithChecksums)

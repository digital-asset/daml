# Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

import json
import sys
import re

### NOTE: THIS FILE HAS BEEN GENERATED BY GEMINI AND AS OF NOW DOES ITS JOB. IT
### MAY WELL DO THINGS SUBOPTIMALLY. IF REQUIREMENTS CHANGE, IT IS RECOMMENDED
### TO REPLACE THE FILE VERSUS TRYING TO UNDERSTAND AND ALTER WHAT THE SCRIPT IS
### DOING.

# --- Generators

def generate_haskell_list(name, docstring, version_strings, lookup_map):
    """Generates a Haskell list definition."""
    refs = [lookup_map[v] for v in version_strings]
    return [
        f"-- | {docstring}",
        f"{name} :: [Version]",
        f"{name} = [{', '.join(refs)}]\n",
    ]

def generate_haskell_singleton(name, docstring, version_string, lookup_map):
    """Generates a Haskell singleton definition (alias)."""
    ref = lookup_map[version_string]
    return [
        f"-- | {docstring}",
        f"{name} :: Version",
        f"{name} = {ref}\n",
    ]

def main(input_json_path, output_hs_path):
    with open(input_json_path, 'r') as f:
        data = json.load(f)

    output = [
        """-- | This file is generated by
-- //compiler/daml-lf-ast:generated_haskell_features_src based on
-- //compiler/daml-lf/language/daml-lf.bzl. DO NOT EDIT.

module DA.Daml.LF.Ast.Version.GeneratedVersions where

import DA.Daml.LF.Ast.Version.VersionType
"""
    ]

    version_lookup = {}
    generated_vars = set()

    raw_versions = data.get("explicitVersions", [])

    # --- Pre-pass: Analyze Staging Versions ---
    # We need to find the maximum revision (e.g. rc3) to use in the constructor
    # for the single staging variable.
    staging_revisions = set()
    max_staging_rev = 0

    for v in raw_versions:
        match = re.match(r"^2\.\d+-rc(\d+)$", v)
        if match:
            rev = int(match.group(1))
            staging_revisions.add(rev)
            if rev > max_staging_rev:
                max_staging_rev = rev

    # --- Sort for Deterministic Output ---
    def sort_key(v):
        if v == "2.dev": return (2, 999999)
        # Handle 2.12 vs 2.12-rc1
        parts = re.split(r'[.-]', v)
        major = int(parts[0])
        minor = int(parts[1]) if parts[1].isdigit() else 0
        return (major, minor)

    raw_versions.sort(key=sort_key)

    for v_str in raw_versions:
        var_name = ""
        constructor = ""

        if v_str == "2.dev":
            var_name = "version2_dev"
            constructor = "PointDev"

        elif "-rc" in v_str:
            match = re.match(r"^2\.(\d+)-rc(\d+)$", v_str)
            if match:
                minor = match.group(1)
                var_name = f"version2_{minor}"
                constructor = f"PointStaging {max_staging_rev}"

        else:
            match = re.match(r"^2\.(\d+)$", v_str)
            if match:
                minor = match.group(1)
                var_name = f"version2_{minor}"
                constructor = f"PointStable {minor}"

        version_lookup[v_str] = var_name

        if "-rc" in v_str:
             base = v_str.split("-rc")[0]
             version_lookup[base] = var_name

        if var_name not in generated_vars:
            clean_ver = v_str.split("-rc")[0]
            output.append(f"-- | Daml-LF version {clean_ver}")
            output.append(f"{var_name} :: Version")
            output.append(f"{var_name} = Version V2 ({constructor})\n")
            generated_vars.add(var_name)

    # --- Accepted Revisions List ---
    sorted_revisions = sorted(list(staging_revisions))
    sorted_revisions_str = ", ".join(map(str, sorted_revisions))

    output.append("-- | The acceptedStagingRevisions.")
    output.append("acceptedStagingRevisions :: [Int]")
    output.append(f"acceptedStagingRevisions = [{sorted_revisions_str}]\n")

    # --- Lists ---
    version_lists = data.get("versionLists", {})
    for list_name in sorted(version_lists.keys()):
        v_list = version_lists[list_name]
        docstring = f"The {list_name}."
        output.extend(generate_haskell_list(list_name, docstring, v_list, version_lookup))

    # --- Aliases ---
    named_versions = data.get("namedVersions", {})
    for alias_name in sorted(named_versions.keys()):
        v_str = named_versions[alias_name]
        docstring = f"The {alias_name}."
        output.extend(generate_haskell_singleton(alias_name, docstring, v_str, version_lookup))

    with open(output_hs_path, 'w') as f:
        f.write("\n".join(output))

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <input.json> <output.hs>", file=sys.stderr)
        sys.exit(1)
    main(sys.argv[1], sys.argv[2])


# Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

#!/usr/bin/env python3

import json
import sys
import re

### NOTE: THIS FILE HAS BEEN GENERATED BY GEMINI AND AS OF NOW DOES ITS JOB. IT
### MAY WELL DO THINGS SUBOPTIMALLY. IF REQUIREMENTS CHANGE, IT IS RECOMMENDED
### TO REPLACE THE FILE VERSUS TRYING TO UNDERSTAND AND ALTER WHAT THE SCRIPT IS
### DOING.

# --- Generators

def generate_haskell_list(name, docstring, version_strings, lookup_map):
    """Generates a Haskell list definition with deduplication."""
    # 1. Resolve all strings to their Haskell variable names
    # e.g. ["2.3-rc1", "2.3-rc2"] -> ["version2_3", "version2_3"]
    raw_refs = [lookup_map[v] for v in version_strings]

    # 2. Deduplicate while preserving order
    unique_refs = []
    seen = set()
    for ref in raw_refs:
        if ref not in seen:
            unique_refs.append(ref)
            seen.add(ref)

    return [
        f"-- | {docstring}",
        f"{name} :: [Version]",
        f"{name} = [{', '.join(unique_refs)}]\n",
    ]

def generate_haskell_singleton(name, docstring, version_string, lookup_map):
    """Generates a Haskell singleton definition (alias)."""
    ref = lookup_map[version_string]
    return [
        f"-- | {docstring}",
        f"{name} :: Version",
        f"{name} = {ref}\n",
    ]

def main(input_json_path, output_hs_path):
    with open(input_json_path, 'r') as f:
        data = json.load(f)

    output = [
        """-- | This file is generated by
-- //compiler/daml-lf-ast:generated_haskell_features_src based on
-- //daml-lf/daml-lf-versions.json. DO NOT EDIT.

module DA.Daml.LF.Ast.Version.GeneratedVersions where

import DA.Daml.LF.Ast.Version.VersionType
"""
    ]

    version_lookup = {}
    generated_vars = set()
    staging_revisions = set()

    raw_versions = data.get("explicitVersions", [])

    def sort_key(v):
        if v == "2.dev": return (2, 999999) # Dev is largest
        # Split 2.12-rc1 into [2, 12, rc1]
        parts = re.split(r'[.-]', v)
        major = int(parts[0])
        minor = int(parts[1]) if parts[1].isdigit() else 0
        return (major, minor)

    raw_versions.sort(key=sort_key)

    for v_str in raw_versions:
        var_name = ""
        constructor = ""
        base_v = "" # To be used for comments and lookup keys

        if v_str == "2.dev":
            var_name = "version2_dev"
            constructor = "PointDev"
            base_v = "2.dev"

        elif "-rc" in v_str:
            # Staging: 2.3-rc1
            match = re.search(r"2\.(\d+)-rc(\d+)", v_str)
            if match:
                minor = match.group(1)
                rev = int(match.group(2))

                staging_revisions.add(rev)

                var_name = f"version2_{minor}"
                base_v = f"2.{minor}"

                constructor = f"PointStaging {minor}"

        else:
            # Stable: 2.1
            match = re.search(r"2\.(\d+)", v_str)
            if match:
                minor = match.group(1)
                var_name = f"version2_{minor}"
                base_v = f"2.{minor}"
                constructor = f"PointStable {minor}"

        # Map "2.3-rc1" -> "version2_3"
        version_lookup[v_str] = var_name

        # Also map the base "2.3" -> "version2_3"
        # This ensures if json has ["2.3"] (short form) it still works
        if base_v:
            version_lookup[base_v] = var_name

        if var_name not in generated_vars:
            output.append(f"-- | Daml-LF version {base_v}")
            output.append(f"{var_name} :: Version")
            output.append(f"{var_name} = Version V2 ({constructor})\n")
            generated_vars.add(var_name)

    sorted_revisions = sorted(list(staging_revisions))
    sorted_revisions_str = ", ".join(map(str, sorted_revisions))

    output.append("-- | The acceptedStagingRevisions.")
    output.append("acceptedStagingRevisions :: [Int]")
    output.append(f"acceptedStagingRevisions = [{sorted_revisions_str}]\n")

    version_lists = data.get("versionLists", {})
    for list_name in sorted(version_lists.keys()):
        v_list = version_lists[list_name]
        docstring = f"The {list_name}."
        output.extend(generate_haskell_list(list_name, docstring, v_list, version_lookup))

    named_versions = data.get("namedVersions", {})
    for alias_name in sorted(named_versions.keys()):
        v_str = named_versions[alias_name]
        docstring = f"The {alias_name}."
        output.extend(generate_haskell_singleton(alias_name, docstring, v_str, version_lookup))

    with open(output_hs_path, 'w') as f:
        f.write("\n".join(output))

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <input.json> <output.hs>", file=sys.stderr)
        sys.exit(1)
    main(sys.argv[1], sys.argv[2])

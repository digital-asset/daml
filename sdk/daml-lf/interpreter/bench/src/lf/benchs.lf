// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

metadata ( 'bench' : '1.0.0' )

module Bench {

   val fib : Int64 -> Int64 = \(n: Int64) ->
     case (LESS @Int64 n 2) of
       True -> n
     | False -> ADD_INT64 (Bench:fib (SUB_INT64 n 1)) (Bench:fib (SUB_INT64 n 2)) ;

   val benchFib : Unit -> Int64 = \(_: Unit) -> Bench:fib 30;

   val fibTail: Int64 -> Int64 -> Int64 -> Int64 = \(n: Int64) -> \(a: Int64) -> \(b: Int64) ->
     case (EQUAL @Int64 n 0) of
       True -> a
     | False -> case (EQUAL @Int64 n 1) of
         True -> b
       | False -> Bench:fibTail (SUB_INT64 n 1) b (ADD_INT64 a b) ;

   val benchFibTail : Unit -> Int64 = \(_: Unit) -> Bench:fibTail 30 0 1;

   val longList: List Int64 = Bench:mkList 10000;

   val sumFoldlBuiltin: List Int64 -> Int64 = \(xs: List Int64) ->
     FOLDL @Int64 @Int64 ADD_INT64 0 xs;

   val benchSumFoldlBuiltin : Unit -> Int64 =
     \(_: Unit) -> Bench:sumFoldlBuiltin Bench:longList;

   val sumFoldrBuitlin: List Int64 -> Int64 = \(xs: List Int64) ->
     FOLDR @Int64 @Int64 ADD_INT64 0 xs;

   val bnechSumFoldrBuiltin : Unit -> Int64 =
     \(_: Unit) -> Bench:sumFoldrBuitlin Bench:longList;

   val foldl: forall (a: *) (b: *). (a -> b -> a) -> a -> List b -> a = /\ (a: *) (b: *).
     \(f: a -> b -> a) (acc: a) (xs: List b) ->
       case xs of
         Nil -> acc
       | Cons x xs -> Bench:foldl @a @b f (f acc x) xs;

   val foldr: forall (a: *) (b: *). (b -> a -> a) -> a -> List b -> a = /\ (a: *) (b: *).
     \(f: b -> a -> a) (acc: a) (xs: List b) ->
       case xs of
         Nil -> acc
       | Cons x xs -> f x (Bench:foldr @a @b f acc xs);

   val sumFoldLCustom: List Int64 -> Int64 = \(xs: List Int64) ->
     Bench:foldl @Int64 @Int64 ADD_INT64 0 xs;

   val benchSumFoldlCustom : Unit -> Int64 =
     \(_: Unit) -> Bench:sumFoldLCustom Bench:longList;

   val sumFoldRCustom: List Int64 -> Int64 = \(xs: List Int64) ->
     Bench:foldr @Int64 @Int64 ADD_INT64 0 xs;

   val benchSumFoldrCustom : Unit -> Int64 =
     \(_: Unit) -> Bench:sumFoldRCustom Bench:longList;

   val mkList: Int64 -> List Int64 = \(i: Int64) ->
     case (LESS @Int64 0 i) of
       True -> Cons @Int64 [i] (Bench:mkList (SUB_INT64 i 1))
     | False -> Nil @Int64 ;

   val benchMkList : Unit -> List Int64 =
     \(_: Unit) -> Bench:mkList 10000;

   val mkListTail: Int64 -> List Int64 -> List Int64 = \(i: Int64) -> \(acc: List Int64) ->
    case (LESS @Int64 0 i) of
       True -> Bench:mkListTail (SUB_INT64 i 1) (Cons @Int64 [i] acc)
     | False -> acc ;

   val benchMkListTail : Unit -> List Int64 =
     \(_: Unit) -> Bench:mkListTail 10000 (Nil @Int64);

   val append: forall (a: *). List a -> List a -> List a = /\ (a: *).
     \(xs: List a) (ys: List a) ->
       case xs of
         Nil -> ys
       | Cons x xs -> Cons @a [x] (Bench:append @a xs ys) ;

   val filter: forall (a: *). (a -> Bool) -> List a -> List a = /\ (a: *).
     \(p: a -> Bool) (xs: List a) ->
        case xs of
          Nil -> Nil @a
        | Cons x xs ->
            case p x of
              True -> Cons @a [x] (Bench:filter @a p xs)
            | False -> Bench:filter @a p xs ;

   val quicksort: forall (a: *). List a -> List a = /\ (a: *).
      \(xs: List a) ->
        case xs of
            Nil -> Nil @a
        | Cons pivot xs ->
            let smallerSorted: List a = Bench:quicksort @a (Bench:filter @a (GREATER @a pivot) xs) in
            let biggerSorted: List a = Bench:quicksort @a (Bench:filter @a (LESS @a pivot) xs) in
            Bench:append @a (Bench:append @a smallerSorted (Cons @a [pivot] (Nil @a))) biggerSorted ;

   val benchQuicksort : Unit -> List Int64 =
     \(_: Unit) -> Bench:quicksort @Int64 (Bench:longList);

}
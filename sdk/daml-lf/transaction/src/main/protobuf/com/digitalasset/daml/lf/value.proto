// Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

// Please refer to the value spec (in daml-foundations/daml-lf/spec/value.rst)
// which describes the semantics of Daml-LF values in more detail.
//
// [one-line] version summary
// * 14 -- initial version
// * 15 -- no change w.r.t. 14
// * dev -- special staging area for the next version to be released
syntax = "proto3";

package com.digitalasset.daml.lf.value;

option java_package = "com.digitalasset.daml.lf.value";

import "google/protobuf/empty.proto";

message VersionedValue {
    string version = 1;
    bytes value = 2;
}

// Each component of the module name and the name have additional
// lexical restrictions besides non-emptiness -- see the value.rst
// spec for more info.
message Identifier {
  string package_id = 1; // non-empty
  repeated string module_name = 2; // at least length 1
  repeated string name = 3; // at least length 1
}

// The universe of serializable Daml-LF values.
// architecture-handbook-entry-begin: Value
message Value {
  oneof sum {
    // This value is used for example for choices that don't take any arguments.
    google.protobuf.Empty unit = 1;

    // True or false.
    bool bool = 2;

    sint64 int64 = 3;

    // Days since the unix epoch. Can go backwards. Limited from
    // 0001-01-01 to 9999-12-31, also to be compatible with
    // https://www.ietf.org/rfc/rfc3339.txt
    int32 date = 4;

    // Microseconds since the UNIX epoch. Can go backwards. Fixed
    // since the vast majority of values will be greater than
    // 2^28, since currently the number of microseconds since the
    // epoch is greater than that. Range: 0001-01-01T00:00:00Z to
    // 9999-12-31T23:59:59.999999Z, so that we can convert to/from
    // https://www.ietf.org/rfc/rfc3339.txt
    sfixed64 timestamp = 5;

    // A Numeric, that is a decimal value with precision 38 (at most 38 significant digits) and a
    // scale between 0 and 37 (significant digits on the right of the decimal point).
    // The field has to match the regex
    //   [+-]?\d{1,38}(.\d{0,37})?
    // and should be representable by a Numeric without loss of precision.
    string numeric = 6;

    // An agent operating on the ledger.
    // Must be a valid PartyIdString.
    string party = 7;

    // A string.
    string text = 8;

    // Identifier of an on-ledger contract. Commands which reference an unknown or already archived contract ID will fail.
    // Must encode a valid LedgerString.
    bytes contract_id = 9;

    // The Optional type, None or Some
    Optional optional = 10;

    // Represents a homogeneous list of values.
    List list = 11;

    // The generic Map type
    Map map = 12;

    // The TextMap type
    TextMap text_map = 1001;  // *Available in versions >= 2.dev

    Record record = 13;

    Variant variant = 14;

    Enum enum = 15;
  }

  message Record {
    repeated Field fields = 1;

    message Field {
        Value value = 1;
    }
  }


  message Variant {
    string constructor = 1;
    Value value = 2;
  }

  message Enum {
    string value = 1;
  }

// A homogenous collection of values.
  message List {
  // The elements must all be of the same concrete value type.
    repeated Value elements = 1;
  }

// Corresponds to Java's Optional type, Scala's Option, and Haskell's Maybe.
// The reason why we need to wrap this in an additional ``message`` is that we
// need to be able to encode the ``None`` case in the ``Value`` oneof.
  message Optional {
    Value value = 1; // optional
  }

  message TextMap {
    message Entry {
      string key = 1;
      Value value = 2;
    }

    repeated Entry entries = 1;
  }

  message Map {
    message Entry {
      Value key = 1;
      Value value = 2;
    }

    repeated Entry entries = 1;
  }
}


-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE CPP #-}

module Universal where

import qualified DA.Map as M
import DA.Exception (ActionThrow(throw))

data Kind = Consuming | NonConsuming
  deriving (Eq, Show)

data TxAction
    = Create
        { contractId : Int
        , signatories : [Party]
        , observers : [Party]
        }
    | Exercise
        { kind : Kind
        , contractId : Int
        , controllers : [Party]
        , choiceObservers : [Party]
        , subTransaction : Transaction
        }
#ifdef DAML_CONTRACT_KEYS
    | CreateWithKey
        { contractId : Int
        , keyId : Int
        , maintainers: [Party]
        , signatories : [Party]
        , observers : [Party]
        }
    | ExerciseByKey
        { kind : Kind
        , keyId: Int
        , maintainers: [Party]
        , controllers : [Party]
        , choiceObservers : [Party]
        , subTransaction : Transaction
        }
    | LookupByKey
        { keyId: Int
        , maintainers: [Party]
        -- The expected result is not necessary but we assert it as a sanity check.
        , expectedResult : Optional Int
        }
    | FetchByKey
        { keyId: Int
        , maintainers: [Party]
        -- The expected result is not necessary but we assert it as a sanity check.
        , expectedContractId : Int
        }
#endif
    | CreateAndExercise
        { kind : Kind
        , contractId : Int
        , signatories : [Party]
        , observers : [Party]
        , controllers : [Party]
        , choiceObservers : [Party]
        , subTransaction : Transaction
        }
    | Fetch
        { contractId : Int
        }
    | Rollback
        { subTransaction : Transaction
        }
  deriving (Eq, Show)

type Transaction = [TxAction]

data LCommands = LCommands
    { lActAs : [Party]
    , lActions : [TxAction]
    }

type Ledger = [LCommands]

data SomeContractId
  = UniversalContractId (ContractId Universal)
#ifdef DAML_CONTRACT_KEYS
  | UniversalWithKeyContractId (ContractId UniversalWithKey)
#endif
  deriving (Show, Eq)

type Env = M.Map Int SomeContractId

template Universal
  with
    signatories : [Party]
    observers : [Party]
#if PACKAGE_VERSION >= 2
    v2Field: Optional ()
#endif
#if PACKAGE_VERSION >= 3
    v3Field: Optional ()
#endif
  where
    signatory signatories
    observer observers

    nonconsuming choice NonConsumingChoice: Env
      with
        env: Env
        controllers: [Party]
        choiceObservers: [Party]
        subTransaction: Transaction
      observer choiceObservers
      controller controllers
      do
        interpretTransaction env subTransaction

    choice ConsumingChoice: Env
      with
        env: Env
        controllers: [Party]
        choiceObservers: [Party]
        subTransaction: Transaction
      observer choiceObservers
      controller controllers
      do
        interpretTransaction env subTransaction

#ifdef DAML_CONTRACT_KEYS

template UniversalWithKey
  with
    signatories : [Party]
    observers : [Party]
    keyId: Int
    maintainers: [Party]
  where
    signatory signatories
    observer observers
    key (keyId, maintainers) : (Int, [Party])
    maintainer key._2

    nonconsuming choice KNonConsumingChoice: Env
      with
        env: Env
        controllers: [Party]
        choiceObservers: [Party]
        subTransaction: Transaction
      observer choiceObservers
      controller controllers
      do
        interpretTransaction env subTransaction

    choice KConsumingChoice: Env
      with
        env: Env
        controllers: [Party]
        choiceObservers: [Party]
        subTransaction: Transaction
      observer choiceObservers
      controller controllers
      do
        interpretTransaction env subTransaction

#endif

exception RollbackException
  with
  where
    message "rollback"


(!) : (Ord k, Show k) => M.Map k v -> k -> v
m ! k = 
  case M.lookup k m of
    Some v -> v
    None -> error (show k <> " not found")

interpretTxAction : Env -> TxAction -> Update Env
interpretTxAction env action = 
  case action of
    (Create contractId signatories observers) -> do
       let v2Field = None
       let v3Field = None
       actualContractId <- create Universal {..}
       return (M.insert contractId (UniversalContractId actualContractId) env)
#ifdef DAML_CONTRACT_KEYS
    (CreateWithKey contractId keyId maintainers signatories observers) -> do
       actualContractId <- create UniversalWithKey {..}
       return (M.insert contractId (UniversalWithKeyContractId actualContractId) env)
#endif
    (Exercise kind contractId controllers choiceObservers subTransaction) ->
      case kind of
        Consuming ->
          case env ! contractId of
            UniversalContractId cid -> exercise cid ConsumingChoice {..}
#ifdef DAML_CONTRACT_KEYS
            UniversalWithKeyContractId cid -> exercise cid KConsumingChoice {..}
#endif
        NonConsuming ->
          case env ! contractId of
            UniversalContractId cid -> exercise cid NonConsumingChoice {..}
#ifdef DAML_CONTRACT_KEYS
            UniversalWithKeyContractId cid -> exercise cid KNonConsumingChoice {..}
#endif
#ifdef DAML_CONTRACT_KEYS
    (ExerciseByKey kind keyId maintainers controllers choiceObservers subTransaction) ->
      case kind of
        Consuming -> exerciseByKey @UniversalWithKey (keyId, maintainers) KConsumingChoice {..}
        NonConsuming -> exerciseByKey @UniversalWithKey (keyId, maintainers) KNonConsumingChoice {..}
#endif
    (CreateAndExercise kind contractId signatories observers controllers choiceObservers subTransaction) -> do
      error "unexpected non-toplevel CreateAndExercise node"
    (Fetch contractId) -> do
      case env ! contractId of
        UniversalContractId cid -> do
          fetch cid
          return env
#ifdef DAML_CONTRACT_KEYS
        UniversalWithKeyContractId cid -> do
          fetch cid
          return env
#endif
#ifdef DAML_CONTRACT_KEYS
    (LookupByKey keyId maintainers expectedResult) -> do
      result <- lookupByKey @UniversalWithKey (keyId, maintainers)
      assert (fmap UniversalWithKeyContractId result == fmap (env !) expectedResult)
      return env
    (FetchByKey keyId maintainers expectedContractId) -> do
      (result, _) <- fetchByKey @UniversalWithKey (keyId, maintainers)
      assert (UniversalWithKeyContractId result == env ! expectedContractId)
      return env
#endif
    (Rollback subTransaction) -> do
      try do
        interpretTransaction env subTransaction
        throw RollbackException
      catch
        RollbackException ->
          return env

interpretTransaction : Env -> Transaction -> Update Env
interpretTransaction env tx = 
  case tx of
    [] -> return env
    (a::as) -> do
      env' <- interpretTxAction env a
      interpretTransaction env' as


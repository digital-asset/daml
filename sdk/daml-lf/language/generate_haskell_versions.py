#!/usr/bin/env python3
# Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

import json
import sys

# --- Helpers for RAW_ALL definitions

def to_haskell_var(v):
    """Converts a version dict to a Haskell variable definition name, e.g., version2_1."""
    return "version{}_{}".format(v["major"], v["minor"]).replace('.', '_')

def to_haskell_major(major_str):
    """Converts a major version string to a Haskell MajorVersion constructor."""
    if major_str == "2":
        return "V2"
    raise ValueError("Unsupported Major Version: {}".format(major_str))

def to_haskell_minor(v):
    """Converts a version dict to a Haskell MinorVersion constructor."""
    status = v["status"]
    minor = v["minor"]
    if status == "stable":
        return f"PointStable {int(minor)}"
    elif status == "staging":
        return f"PointStaging {int(minor)}"
    elif status == "dev":
        return "PointDev"
    raise ValueError(f"Unsupported Status: {status}")

# --- Generic generators

def to_haskell_ref(version_string):
    """Converts a version string to a Haskell variable reference, e.g., "2.1" -> version2_1."""
    return "version" + version_string.replace('.', '_')

def generate_haskell_list(name, docstring, version_strings):
    """Generates a Haskell list definition."""
    refs = [to_haskell_ref(v) for v in version_strings]
    return [
        f"-- | {docstring}",
        f"{name} :: [Version]",
        f"{name} = [{', '.join(refs)}]\n",
    ]

def generate_haskell_singleton(name, docstring, version_string):
    """Generates a Haskell singleton definition."""
    ref = to_haskell_ref(version_string)
    return [
        f"-- | {docstring}",
        f"{name} :: Version",
        f"{name} = {ref}\n",
    ]

def main(input_json_path, output_hs_path):
    with open(input_json_path, 'r') as f:
        data = json.load(f)

    output = [
        """-- Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | This file is generated by //daml-lf/language:generate_haskell_versions. DO NOT EDIT.
-- ... (rest of the header comment)

module DA.Daml.LF.Ast.Version.GeneratedVersions where

import DA.Daml.LF.Ast.Version.VersionType
"""
    ]

    # 1. Handle the special case for raw definitions.
    if "RAW_ALL" in data:
        for v in data["RAW_ALL"]:
            var_name = to_haskell_var(v)
            major = to_haskell_major(v["major"])
            minor = to_haskell_minor(v)
            output.append(f"-- | Daml-LF version {v['major']}.{v['minor']}")
            output.append(f"{var_name} :: Version")
            output.append(f"{var_name} = Version {major} ({minor})\n")

    # 2. Loop over all other items. The key is now used directly as the variable name.
    for key, value in data.items():
        if key == "RAW_ALL":
            continue

        docstring = f"The {key}."

        if isinstance(value, list):
            output.extend(generate_haskell_list(key, docstring, value))
        elif isinstance(value, str):
            output.extend(generate_haskell_singleton(key, docstring, value))

    with open(output_hs_path, 'w') as f:
        f.write("\n".join(output))

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <input.json> <output.hs>", file=sys.stderr)
        sys.exit(1)
    main(sys.argv[1], sys.argv[2])

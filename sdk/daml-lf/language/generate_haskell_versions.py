#!/usr/bin/env python3
# Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

import json
import sys

# --- Helpers for raw version definitions

def to_haskell_var(v):
    """Converts a version dict to a Haskell variable definition name, e.g., version2_1."""
    # We format directly from major/minor fields, e.g., {"major": "2", "minor": "dev"} -> "version2_dev"
    return "version{}_{}".format(v["major"], v["minor"])

def to_haskell_major(major_str):
    """Converts a major version string to a Haskell MajorVersion constructor."""
    if major_str == "2":
        return "V2"
    raise ValueError("Unsupported Major Version: {}".format(major_str))

def to_haskell_minor(v):
    """Converts a version dict to a Haskell MinorVersion constructor."""
    status = v["status"]
    minor = v["minor"]
    if status == "stable":
        return f"PointStable {int(minor)}"
    elif status == "staging":
        return f"PointStaging {int(minor)}"
    elif status == "dev":
        return "PointDev"
    raise ValueError(f"Unsupported Status: {status}")

# --- Generic generators

def generate_haskell_list(name, docstring, version_dicts):
    """Generates a Haskell list definition from raw version dicts."""
    refs = [to_haskell_var(v) for v in version_dicts]
    return [
        f"-- | {docstring}",
        f"{name} :: [Version]",
        f"{name} = [{', '.join(refs)}]\n",
    ]

def generate_haskell_singleton(name, docstring, version_dict):
    """Generates a Haskell singleton definition from a raw version dict."""
    ref = to_haskell_var(version_dict)
    return [
        f"-- | {docstring}",
        f"{name} :: Version",
        f"{name} = {ref}\n",
    ]

def main(input_json_path, output_hs_path):
    with open(input_json_path, 'r') as f:
        data = json.load(f)

    output = [
        """-- | This file is generated by
-- //compiler/daml-lf-ast:generated_haskell_features_src based on
-- //compiler/daml-lf/language/daml-lf.bzl. DO NOT EDIT.

module DA.Daml.LF.Ast.Version.GeneratedVersions where

import DA.Daml.LF.Ast.Version.VersionType
"""
    ]

    # 1. Handle the definitions from `allLfVersions`. This list contains
    # the full struct-like dicts.
    if "allLfVersions" in data:
        for v in data["allLfVersions"]:
            var_name = to_haskell_var(v)
            major = to_haskell_major(v["major"])
            minor = to_haskell_minor(v)
            output.append(f"-- | Daml-LF version {v['major']}.{v['minor']}")
            output.append(f"{var_name} :: Version")
            output.append(f"{var_name} = Version {major} ({minor})\n")

    # 2. Loop over all other items, which are (lists of) raw version dicts.
    # The key is used directly as the variable name.
    for key, value in data.items():
        docstring = f"The {key}."

        if isinstance(value, list):
            # This is for lists like stableLfVersions
            output.extend(generate_haskell_list(key, docstring, value))
        elif isinstance(value, dict):
            # This is for singletons like defaultLfVersion
            output.extend(generate_haskell_singleton(key, docstring, value))

    with open(output_hs_path, 'w') as f:
        f.write("\n".join(output))

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <input.json> <output.hs>", file=sys.stderr)
        sys.exit(1)
    main(sys.argv[1], sys.argv[2])

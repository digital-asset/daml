#!/usr/bin/env python3
# Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

import json
import sys

def to_haskell_var(v):
    """Converts a version dict to a Haskell variable definition name, e.g., version2_1."""
    return "version{}_{}".format(v["major"], v["minor"]).replace('.', '_')

def to_haskell_ref(version_string):
    """Converts a version string to a Haskell variable reference, e.g., "2.1" -> version2_1."""
    return "version" + version_string.replace('.', '_')

def to_haskell_major(major_str):
    """Converts a major version string to a Haskell MajorVersion constructor."""
    if major_str == "2":
        return "V2"
    raise ValueError("Unsupported Major Version: {}".format(major_str))

def to_haskell_minor(v):
    """Converts a version dict to a Haskell MinorVersion constructor."""
    status = v["status"]
    minor = v["minor"]
    if status == "stable":
        return "PointStable {}".format(int(minor))
    elif status == "staging":
        return "PointStaging {}".format(int(minor))
    elif status == "dev":
        return "PointDev"
    raise ValueError("Unsupported Status: {}".format(status))

def generate_haskell_list(name, docstring, version_strings):
    """Generates a Haskell list definition, e.g., allStableVersions."""
    refs = [to_haskell_ref(v) for v in version_strings]
    return [
        f"-- | {docstring}",
        f"{name} :: [Version]",
        f"{name} = [{', '.join(refs)}]\n",
    ]

def generate_haskell_singleton(name, docstring, version_string):
    """Generates a Haskell singleton definition, e.g., defaultVersion."""
    ref = to_haskell_ref(version_string)
    return [
        f"-- | {docstring}",
        f"{name} :: Version",
        f"{name} = {ref}\n",
    ]

def main(input_json_path, output_hs_path):
    with open(input_json_path, 'r') as f:
        data = json.load(f)

    # Start generating the Haskell file content
    output = []
    output.append(
        """-- Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | This file is generated by //daml-lf/language:generate_haskell_versions. DO NOT EDIT.

-- | In general, please do not import this file directly, but instead import
-- DA.Daml.LF.Ast.Version. This module exports versions directly (e.g.
-- version2_2), DA.Daml.LF.Ast.Version only exports variable versions (e.g.
-- latestStableVersion)

module DA.Daml.LF.Ast.Version.GeneratedVersions where

import DA.Daml.LF.Ast.Version.VersionType
"""
    )

    # 1. Generate individual version raw definitions from the "raw_all" list
    for v in data["RAW_ALL"]:
        var_name = to_haskell_var(v)
        major_constructor = to_haskell_major(v["major"])
        minor_constructor = to_haskell_minor(v)

        output.append(f"-- | Daml-LF version {v['major']}.{v['minor']}")
        output.append(f"{var_name} :: Version")
        output.append(f"{var_name} = Version {major_constructor} ({minor_constructor})\n")

    # 2. Generate lists and single variables by calling the new helper functions
    output.extend(generate_haskell_list(
        name="allLfVersions",
        docstring="A list of all versions.",
        version_strings=data["ALL"],
    ))
    output.extend(generate_haskell_list(
        name="stableLfVersions",
        docstring="A list of all stable versions.",
        version_strings=data["STABLE"],
    ))
    output.extend(generate_haskell_singleton(
        name="latestStableVersion",
        docstring="The latest stable Daml-LF version.",
        version_string=data["LATEST_STABLE"],
    ))
    output.extend(generate_haskell_singleton(
        name="defaultVersion",
        docstring="The Daml-LF version used by default.",
        version_string=data["DEFAULT"],
    ))
    output.extend(generate_haskell_singleton(
        name="devVersion",
        docstring="The staging Daml-LF version.",
        version_string=data["DEV"],
    ))
    output.extend(generate_haskell_singleton(
        name="stagingVersion",
        docstring="The staging Daml-LF version.",
        version_string=data["STAGING"],
    ))

    with open(output_hs_path, 'w') as f:
        f.write("\n".join(output))

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: {} <input.json> <output.hs>".format(sys.argv[0]), file=sys.stderr)
        sys.exit(1)
    main(sys.argv[1], sys.argv[2])

#!/usr/bin/env python3
# Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

import json
import sys

def to_haskell_var_ref(v_struct):
    """Converts a version struct to a Haskell variable reference, e.g., version2_1."""
    return "version{}_{}".format(v_struct["major"], v_struct["minor"]).replace('.', '_')

def to_haskell_range(req):
    """
    Converts a version_req dictionary into a Haskell Range that references
    the pre-defined version variables.
    """
    has_low = "low" in req and req["low"] is not None
    has_high = "high" in req and req["high"] is not None

    if has_low and has_high:
        low_ref = to_haskell_var_ref(req["low"])
        high_ref = to_haskell_var_ref(req["high"])
        return f"Inclusive {low_ref} {high_ref}"
    elif has_low:
        low_ref = to_haskell_var_ref(req["low"])
        return f"From {low_ref}"
    elif has_high:
        high_ref = to_haskell_var_ref(req["high"])
        return f"Until {high_ref}"
    else:
        return "Empty"

def main(input_json_path, output_hs_path):
    with open(input_json_path, 'r') as f:
        features_data = json.load(f)

    output = [
        """-- | This file is generated by
-- //compiler/daml-lf-ast:generated_haskell_versions_src based on
-- //compiler/daml-lf/language/daml-lf.bzl. DO NOT EDIT.

{-# LANGUAGE OverloadedStrings #-}
module DA.Daml.LF.Ast.Version.GeneratedFeatures
  ( module DA.Daml.LF.Ast.Version.GeneratedFeatures
  ) where

import DA.Daml.LF.Ast.Version.VersionType
import DA.Daml.LF.Ast.Range
import DA.Daml.LF.Ast.Version.GeneratedVersions
"""
    ]

    for feature in features_data:
        var_name = feature["name"]
        name_pretty = feature["name_pretty"]
        cpp_flag = feature["cpp_flag"]
        version_req_hs = to_haskell_range(feature["version_req"])

        output.extend([
            f"{var_name} :: Feature",
            f"{var_name} = Feature",
            f"    {{ featureName = \"{name_pretty}\"",
            f"    , featureVersionReq = {version_req_hs}",
            f"    , featureCppFlag = \"{cpp_flag}\"",
            f"    }}\n",
        ])

    all_feature_names = [f["name"] for f in features_data]
    output.extend([
        "allFeatures :: [Feature]",
        "allFeatures = [{}]\n".format(", ".join(all_feature_names)),
    ])

    with open(output_hs_path, 'w') as f:
        f.write("\n".join(output))

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <input.json> <output.hs>", file=sys.stderr)
        sys.exit(1)
    main(sys.argv[1], sys.argv[2])

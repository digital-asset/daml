% Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
% SPDX-License-Identifier: Apache-2.0

\documentclass{article}

\usepackage[margin=2.5cm]{geometry}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsthm}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{cleveref}

\newtheorem{lemma}{Lemma}
\crefformat{lemma}{Lem.~#2#1#3}
\newtheorem{theorem}{Theorem}
\crefformat{theorem}{Thm.~#2#1#3}
\newtheorem{definition}[lemma]{Definition}
\crefformat{definition}{Def.~#2#1#3}
\newtheorem{claim}[lemma]{Claim}
\crefformat{claim}{Claim~#2#1#3}
\newtheorem{corollary}[lemma]{Corollary}
\crefformat{corollary}{Cor.~#2#1#3}
\newtheorem*{res}{Final result}

\newtheorem*{term}{Terminology}

\newcommand{\textfun}[1]{\textup{#1}}
\newcommand{\textcode}[1]{\texttt{#1}}
\newcommand{\bolddef}[1]{\textbf{\ensuremath{\mathbf{#1}}}}
\newcommand{\negat}[1]{\neg\,#1}

\newcommand{\fdown}[2]{\ensuremath{f_{down}(#1, #2)}}
\newcommand{\fup}[2]{\ensuremath{f_{up}(#1, #2)}}
\newcommand{\fone}[2]{\ensuremath{f_{1}(#1, #2)}}
\newcommand{\ftwo}[2]{\ensuremath{f_{2}(#1, #2)}}
\newcommand{\fcoll}[2]{\ensuremath{f_{collect}(#1, #2)}}

\newcommand{\emptyList}{\ensuremath{[\ ]}}
\newcommand{\concat}{{{\ ++\ }}}

% NODES %
\newcommand{\fetchNode}[2]{\textfun{Fetch} \ #1\ #2}
\newcommand{\lookupNode}[2]{\textfun{Lookup}\ #1\ #2}
\newcommand{\createNode}[2]{\textfun{Create}\ #1\ #2}
\newcommand{\exNode}[2]{\textfun{Exercise}\ #1\ #2}


%TREES
\newcommand{\nilNode}{\textfun{Endpoint}}
\newcommand{\contentNode}[2]{\textfun{ContentNode}\ #1\ #2}
\newcommand{\artNode}[2]{\textfun{ArticulationNode}\ #1\ #2}

\newcommand{\longtraverse}[4]{\textfun{traverse}\ #1\ #2\ #3 \ #4}
\newcommand{\traverse}[2]{\textfun{traverse}\ #1\ #2}
\newcommand{\longscan}[4]{\textfun{scan}\ #1\ #2\ #3 \ #4}
\newcommand{\scan}[2]{\textfun{scan}\ #1\ #2}
\newcommand{\collect}[1]{\textfun{collect}\ #1}
\newcommand{\collectTr}[1]{\textfun{collectTrace}\ #1}


\newcommand{\up}{\uparrow}
\newcommand{\down}{\downarrow}

\newcommand{\hNode}[2]{\textfun{handleNode}\ #1\ #2}
\newcommand{\beginRb}[1]{\textfun{beginRollback}\ #1}
\newcommand{\enRb}[1]{\textfun{endRollback}\ #1}
\newcommand{\defined}[1]{\textfun{defined}\ #1}
\newcommand{\get}[1]{\textfun{get}\ #1}
\newcommand{\mapping}[1]{\textfun{mapping}\ #1}
\newcommand{\size}[1]{\textfun{size}\ #1}

\newcommand{\fst}[1]{\textfun{proj}_1\ #1}
\newcommand{\snd}[1]{\textfun{proj}_2\ #1}
\newcommand{\trd}[1]{\textfun{proj}_3\ #1}

\newcommand{\keyAct}[1]{\textfun{KeyActive}\ #1}
\newcommand{\keyInact}{\textfun{KeyInactive}}
\newcommand{\state}{\textfun{State}}
\newcommand{\appfst}[2]{\textfun{app}_{#1} #2 = 1}
\newcommand{\actkey}[2]{\textfun{act}_{#1}\ #2}
\newcommand{\emptyState}[1]{\varepsilon_{#1}}




\title{\huge Proof of \texttt{advance} in the UCK State Machine}
\date{}
\author{}

\begin{document}

\maketitle


\begin{term}\ 
    \begin{itemize}
        \item A \textbf{well-defined state} is an instance of the type $\state$ or $\textfun{Right[KeyInputError, \state]}$
        \item A \textbf{state} is an instance of the type $\textfun{Either[KeyInputError, \state]}$
        \item A \textbf{node} is an instance of the type $\textfun{Node}$ or $\textfun{(Node, NodeId)}$.
    \end{itemize}
    When multiple interpretations are possible, the context will always make clear which one we are referring to.
    In particular, depending on the situation, $\beginRb{s}$ and $\enRb{s}$ will return either a $\state$ or a $\textfun{Right[KeyInputError, \state]}$.
\end{term}

\begin{definition}
    Let $s$ be a state, \bolddef{\defined{s}} is true if $s$ is a well-defined state.
    When this is the case, \bolddef{\get{s}} yields the $\textfun{State}$ instance out of the option.
\end{definition}

\begin{definition}
    Let $t := (v_1, v_2, v_3)$ a triple. The projections of the triple are $\bolddef{\fst{t}} := v_1$, $\bolddef{\snd{t}} := v_2$ and $\bolddef{\trd{t}} := v_3$.
\end{definition}
















%TREES

\section*{Trees}

\begin{definition}[\textcode{Tree}]
    A tree of nodes is a data structure defined inductively as either:
    \begin{itemize}
        \item $\nilNode$
        \item $\contentNode{sub}{n}$, where $sub$ is a tree and $n$ a node.
        \item $\artNode{l}{r}$, where $l$ and $r$ are both trees.
    \end{itemize}
\end{definition}

Although this is not the most intuitive definition, it has the advantage of being able to represent forests 
without running into measure decreaseness problems. In fact one can see content nodes as being trees and articulation nodes as forests.


\begin{definition}[\textcode{Tree.size}]
    \label{size_def}
    Let $tr$ be a tree of nodes, \bolddef{\size{tr}} is defined inductively as:
    \begin{itemize}
        \item $\size{\nilNode} := 0$
        \item $\size{(\contentNode{sub}{n})} := (\size{sub}) + 1$
        \item $\size{(\artNode{l}{r})} := (\size{l}) + (\size{r})$
    \end{itemize}
\end{definition}

\begin{definition}[\textcode{Tree.traverse}]
    \label{traverse_def}
    Let $tr$ be a tree of nodes and $init$ a value, \bolddef{\longtraverse{tr}{init}{f_1}{f_2}} is defined inductively as:
    \begin{itemize}
        \item $\longtraverse{\nilNode}{init}{f_1}{f_2} := init$
        \item $\longtraverse{(\contentNode{sub}{n})}{init}{f_1}{f_2} := \ftwo{\longtraverse{sub}{\fone{init}{n}}{f_1}{f_2}}{n}$
        \item $\longtraverse{(\artNode{l}{r})}{init}{f_1}{f_2} := \longtraverse{r}{(\longtraverse{l}{init}{f_1}{f_2})}{f_1}{f_2}$
    \end{itemize}
\end{definition}

\begin{definition}[\textcode{Tree.scan}]
    \label{scan_def}
    Let $tr$ be a tree of nodes and $init$ a value, \bolddef{\longscan{tr}{init}{f_1}{f_2}} is defined inductively as:
    \begin{itemize}
        \item $\longscan{\nilNode}{init}{f_1}{f_2} := \emptyList$
        \item $\longscan{(\contentNode{sub}{n})}{init}{f_1}{f_2} :=$
        \[ [(init, n,\,\down)] \concat \longscan{sub}{f_1(init, n)}{f_1}{f_2} \concat [(\longtraverse{sub}{f_1(init, n)}{f_1}{f_2}, n,\,\up)]\]
        \item $\longscan{(\artNode{l}{r})}{init}{f_1}{f_2} :=$
        \[\longscan{l}{init}{f_1}{f_2} \concat \longscan{r}{(\longtraverse{l}{init}{f_1}{f_2})}{f_1}{f_2}\]
    \end{itemize}
\end{definition}

\begin{claim}[postcondition of \textcode{Tree.size}]
    \label{size_pos}
    Let $tr$ be a tree of nodes, 
    \[\size{tr} \geq 0 \] 
\end{claim}
\begin{proof}
    Straight induction on $tr$.
\end{proof}

\begin{claim}[postcondition of \textcode{Tree.scan}]
    \label{scan_size}
    For any tree of nodes $tr$, value $init$ and functions $f_1, f_2$
    \[\size{(\longscan{tr}{init}{f_1}{f_2})} = 2 \cdot \size{tr}\]
\end{claim}

\begin{proof}
    Straight induction on tr.
\end{proof}

\begin{lemma}[\textcode{scanIndexing}]
    \label{scan_indexing}
    For any tree of nodes $tr$, value $init$ and functions $f_1, f_2$

    If $tr = \contentNode{sub}{n}$:
     \[(\longscan{tr}{init}{f_1}{f_2})[i] = 
        \begin{cases}
            (init, n,\,\down) & \text{if $i = 0$}\\
            (\longtraverse{sub}{\fone{init}{n}}{f_1}{f_2}, n,\,\up) & \text{if $i = 2 \cdot \size{tr} - 1$}\\
            (\longscan{sub}{\fone{init}{n}}{f_1}{f_2})[i - 1] & \text{otherwise}
        \end{cases}\]

    If $tr = \artNode{l}{r}$:
     \[(\longscan{tr}{init}{f_1}{f_2})[i] = 
        \begin{cases}
            (\longscan{l}{init}{f_1}{f_2})[i] & \text{if $i < 2\cdot \size{l}$}\\
            (\longscan{r}{(\longtraverse{l}{init}{f_1}{f_2})}{f_1}{f_2})[i - 2 \cdot \size{l}] & \text{otherwise}
        \end{cases}\]
        
\end{lemma}

\begin{proof}
    Application of union indexing property in lists
\end{proof}

\begin{lemma}[\textcode{scanIndexingState}]
    \label{scan_indexing_state}
    Let $tr$ be a tree of nodes $tr$, $init$ a value, $f_1, f_2$ two functions and $i < 2 \cdot \size{tr}$ a non-negative integer. Let $l := \longscan{tr}{init}{f_1}{f_2}$:
    \begin{align}
    \fst{(l[i])} =& \begin{cases}
        init & \text{if $i = 0$}\\
        f_1(\fst{(l[i - 1])}, \snd{(l[i - 1])}) & \text{if $\trd{(l[i - 1])} = \, \down$} \\
        f_2(\fst{(l[i - 1])}, \snd{(l[i - 1])}) & \text{if $\trd{(l[i - 1])} = \, \up$}
    \end{cases}\\
    \intertext{\hskip 25em and}
    \longtraverse{tr}{init}{f_1}{f_2} =& 
        \begin{cases}
        init &\text{if $\size{tr} = 0$} \\
        f_2(\fst{(l[2 \cdot \size{tr} - 1])}, \snd{(l[2 \cdot \size{tr} - 1])}) &\text{otherwise}
        \end{cases}
    \end{align}
\end{lemma}

\begin{proof}
Induction on tr:

\begin{itemize}
    \item If $tr = \nilNode$, then $\size{tr} = 0$.
    \item If $tr = \contentNode{sub}{n}$:
    
    \begin{itemize}
        \item If $i = 0$ then by \cref{scan_indexing} $l[i] = (init, n, \down)$.
        \item If $i = 2\, \cdot \, \size{tr} \, - \, 1$, then by \cref{scan_indexing} $l[i] = (\longtraverse{sub}{\fone{init}{n}}{f_1}{f_2}, n, \up)$.
        
              Let $l_{sub} := \longscan{sub}{\fone{init}{n}}{f_1}{f_2}$.

              If $\size{sub} = 0$, then $i = 1$:
              \begin{align*}
                \longtraverse{sub}{\fone{init}{n}}{f_1}{f_2} =& \fone{init}{n} & \text{by IH} \\
                                                            =& \fone{\fst{(l[0])}}{\snd{(l[0])}} & \text{by \cref{scan_indexing}} \\
                                                            =& \fone{\fst{(l[i - 1])}}{\snd{(l[i - 1])}}
              \end{align*}
              Moreover we know that $\trd{(l[0])} = \down$

                Otherwise:


              \begin{align*}
                &\longtraverse{sub}{\fone{init}{n}}{f_1}{f_2} \\
                =& \ftwo{\fst{(l_{sub}[2 \cdot \size{sub} - 1])}}{\snd{(l_{sub}[2 \cdot \size{sub} - 1])}} \\
                                                =& \ftwo{\fst{(l_{sub}[2 \cdot \size{tr} - 3])}}{\snd{(l_{sub}[2 \cdot \size{tr} - 3])}} & \text{unfolding \cref{size_def}} \\
                                                =& \ftwo{\fst{(l[2 \cdot \size{tr} - 2])}}{\snd{(l[2 \cdot \size{tr} - 2])}} & \text{by \cref{scan_indexing}} \\
                                                =& \ftwo{\fst{(l[i - 1])}}{\snd{(l[i - 1])}}
                                            \end{align*}

    \item Else apply induction hypothesis with $sub$, $\fone{init}{n}$ and $i - 1$. Use \cref{scan_indexing} when $i > 1$.
    \item To prove (2) we know by \cref{size_def} that $\size{tr} > 0$. The result is then immediate from \cref{scan_indexing}. 
    \end{itemize}
    \item If $tr = \artNode{le}{ri}$:
    \begin{itemize}
        \item If $i < 2 \cdot \size{le}$, apply induction hypothesis with $le$, $init$ and $i$, and \cref{scan_indexing}.
        \item If $i = 2 \cdot \size{le}$:
        
        Let $l_{le} := (\longscan{le}{init}{f_1}{f_2})$ and  $l_{ri} := (\longscan{ri}{(\longtraverse{le}{init}{f_1}{f_2})}{f_1}{f_2})$

            \begin{align*}
                \fst{(l_{ri}[0])} &= \longtraverse{le}{init}{f_1}{f_2}\: &\text{by IH on $ri$}\\
                \fst{(l_{ri}[i - 2 \cdot \size{le}])} &= \longtraverse{le}{init}{f_1}{f_2} \\
                \fst{(l[i])} &= \longtraverse{le}{init}{f_1}{f_2} &\text{by \cref{scan_indexing}} \\
                 &= \ftwo{\fst{(l_{le}[2 \cdot \size{le} - 1])}}{\snd{(l_{le}[2 \cdot \size{le} - 1])}} &\text{by IH on $le$} \\
                 &= \ftwo{\fst{(l_{le}[i - 1])}}{\snd{(l_{le}[i - 1])}}
            \end{align*}
        \item Else apply induction hypothesis with $ri$, $\longtraverse{le}{init}{f_1}{f_2}$ and $i - 2 \cdot \size{le}$ and \cref*{scan_indexing}.
        \item If $\size{tr} = 0$ then by \cref{size_pos} and unfolding \cref{size_def}, $\size{le} = 0$ and $\size{ri} = 0$.
                \begin{align*}
                    \longtraverse{tr}{init}{f_1}{f_2} &= \longtraverse{ri}{(\longtraverse{le}{init}{f_1}{f_2})}{f_1}{f_2} &\text{unfolding \cref{traverse_def}} \\
                    &= \longtraverse{le}{init}{f_1}{f_2} & \text{by IH on $ri$} \\
                    &= init & \text{by IH on $l$}
                \end{align*}

            
            Else if $\size{ri} = 0$:
            \begin{align*}
                \longtraverse{tr}{init}{f_1}{f_2}
                =\ & \longtraverse{ri}{(\longtraverse{le}{init}{f_1}{f_2})}{f_1}{f_2} &\text{unfolding \cref{traverse_def}} \\
                =\ & \longtraverse{le}{init}{f_1}{f_2} & \text{by IH on $ri$} \\
                =\ &  f_2(\fst{(l_{le}[2 \cdot \size{le} - 1])}, \snd{(l_{le}[2 \cdot \size{le} - 1])}) & \text{by IH on $le$} \\
                =\ &  f_2(\fst{(l[2 \cdot \size{le} - 1])}, \snd{(l[2 \cdot \size{le} - 1])}) & \text{by \cref{scan_indexing}} \\
                =\ &  f_2(\fst{(l[2 \cdot \size{tr} - 1])}, \snd{(l[2 \cdot \size{tr} - 1])}) & \text{by \cref{size_def}}
            \end{align*}

            When $\size{ri} > 0$:
            \begin{align*}
                &\longtraverse{tr}{init}{f_1}{f_2} \\
                =\ & \longtraverse{ri}{(\longtraverse{le}{init}{f_1}{f_2})}{f_1}{f_2} &\text{unfolding \cref{traverse_def}} \\
                =\ &  f_2(\fst{(l_{ri}[2 \cdot \size{ri} - 1])}, \snd{(l_{ri}[2 \cdot \size{ri} - 1])}) & \text{by IH on $ri$} \\
                =\ &  f_2(\fst{(l[2 \cdot \size{ri} + 2 \cdot \size{le} - 1])}, \snd{(l[2 \cdot \size{ri} + 2 \cdot \size{le} - 1])}) & \text{by \cref{scan_indexing}} \\
                =\ &  f_2(\fst{(l[2 \cdot \size{tr} - 1])}, \snd{(l[2 \cdot \size{tr} - 1])}) & \text{by \cref{size_def}}
            \end{align*}
    \end{itemize}
\end{itemize}

\end{proof}

\begin{claim}[\textcode{scanIndexingNode}]
    \label{scan_indexing_node}
    For any tree of nodes $tr$, values $init_1,\, init_2$, functions $f^1_1, f^1_2, f^2_1, f^2_2$ and non-negative integer $i < 2\, \cdot\, \size{tr}$.
    \[ \snd{((\longscan{tr}{init_1}{f^1_1}{f^1_2})[i])} = \snd{((\longscan{tr}{init_2}{f^2_1}{f^2_2})[i])}\]
    \[\text{and}\]
    \[ \trd{((\longscan{tr}{init_1}{f^1_1}{f^1_2})[i])} = \trd{((\longscan{tr}{init_2}{f^2_1}{f^2_2})[i])}\]
\end{claim}

\begin{proof}
    Induction on tr using \cref{scan_indexing}.
\end{proof}

We now define the two functions we will be applying during a tree traversal.

\begin{definition}[\textcode{traverseInFun}, \textcode{traverseOutFun}]
    Let $s$ be a state and $n$ be a node, 
    \[\fdown{s}{n} : = 
    \begin{cases} 
        \hNode{(\get{s})}{n}& \text{if $n$ is an Action node and $\defined{s}$} \\
        \beginRb{(\get{s})} & \text{if $n$ is a Rollback node and $\defined{s}$} \\
        s& \text{otherwise}
    \end{cases} \]
    \[\fup{s}{n} : = 
    \begin{cases} 
        \enRb{(\get{s})} & \text{if $n$ is a Rollback node and $\defined{s}$} \\
        s& \text{otherwise}
    \end{cases} \]
\end{definition}

In the rest of the document, unless stated otherwise, init will be a state and $\traverse{tr}{init}$ and $\scan{tr}{init}$ will be referring to as respectively
$\longtraverse{tr}{init}{f_{down}}{f_{up}}$ and $\longscan{tr}{init}{f_{down}}{f_{up}}$

\begin{claim}[\textcode{traverseTransactionProp}]
    For any tree of nodes tr, state init, if $\defined{(\traverse{tr}{init})}$ then
    \label{traverse_prop}
        \[\defined{init} \land (\get{(\traverse{tr}{init})}).rollbackStack = (\get{init}).rollbackStack \  \land\]
        \[(\get{(\traverse{tr}{init})}).globalKeys = (\get{init}).globalKeys\]
\end{claim}

\begin{proof}
    Straight induction on tr. 
\end{proof}

\begin{claim}[\textcode{scanTransactionProp}]
    \label{defined_prop}
    Let $tr$ be a tree of nodes, $init$ a state, $0 \leq i \leq j < 2 \cdot\, \size{tr} $ two integers and let $l:= \scan{tr}{init}$.
    \[\defined (\fst{(l[j])}) \implies\, \defined (\fst{(l[i])})\]
\end{claim}

\begin{proof}
    By induction on $j$: the base case is immediate and \cref{scan_indexing_state}
     combined with the induction hypothesis concludes the proof.
\end{proof}

\begin{corollary}[\textcode{scanTransactionProp}]
    \label{defined_traverse_prop}
    Let $tr$ be a tree of nodes, $init$ a state, $0 \leq i < 2 \cdot\, \size{tr} $ an integer and let $l:= \scan{tr}{init}$.
    \[\defined (\traverse{tr}{init}) \implies\, \defined (\fst{(l[i])})\]
\end{corollary}

\begin{proof}
    By \cref{scan_indexing_state} and \cref{defined_prop} setting $j = 2 \cdot\, \size{tr} - 1$.
\end{proof}

\begin{lemma}
    \label{defined_alt_def}
    Let $tr$ be a tree of nodes, $init$ a state and $l := \scan{tr}{init}$ then 
    \[\defined{(\traverse{tr}{init})} \iff 
    \begin{cases}
        \defined{init} \\
        \forall\, 0 \leq i < 2 \cdot\, \size{tr} - 1, \, \defined{(\fst{(l[i])})} \implies \defined{(\fst{(l[i + 1])})} \,
    \end{cases}\]
        
\end{lemma}

\begin{proof}
    Let's first note that by \cref{scan_indexing_state}, $\fst{(l[0])} = init$.

    If $\defined{(\traverse{tr}{init})}$ then by \cref{defined_traverse_prop}, $\defined{\fst{(l[i])}}$ for all $0 \leq i < 2 \cdot\, \size{tr}$.
    
    If the right statement is true, then $\defined{(\fst{(l[2 \cdot \, \size{tr} - 1])})}$ and therefore by \cref{scan_indexing_state} we have $\defined{(\traverse{tr}{init})}$.
\end{proof}


\begin{claim}[\textcode{findBeginRollback}]
    \label{find_two_begin_rb}
    Let tr be a tree of nodes, $init_1, init_2$ be states and let $l_1 := \scan{tr}{init_1}$, $l_2 := \scan{tr}{init_2}$.
    If there exists a non-negative integer $i < 2 \cdot (\size{tr})$, well-defined states $s^1_i$, $s^2_i$ and a Rollback node $n$ such that 
    $l_1[i] = (s^1_i, n, \up)$ and $l_2[i] = (s^2_i, n, \up)$, then there is an integer $j$, well-defined states $s^1_j, s^2_j$ and a tree $sub$ such that 
    \[0 \leq j < i \qquad l_1[j] = (s^1_j, n, \down) \qquad  l_2[j] = (s^2_j, n, \down) \qquad \size{sub} < \size{tr}\]
    \[s^1_i = \traverse{sub}{(\beginRb{(\get{s^1_j})})} \qquad s^2_i = \traverse{sub}{(\beginRb{(\get{s^2_j})})}\]
\end{claim}

\begin{proof}
    Induction on $tr$:
    \begin{itemize}
        \item If $tr = \nilNode$, then $\size{tr} = 0$ which means the precondition is never met.
        \item If $tr = \contentNode{str}{c}$:
        
        \begin{itemize}
            \item If $c \neq n$ then by \cref{scan_indexing}, $ 0 < i < 2 \cdot (\size{tr}) - 1$, $l_1[i] = (\scan{str}{\fdown{init_1}{n}})[i - 1]$ and 
            $l_2[i] = (\scan{str}{\fdown{init_2}{n}})[i - 1]$.
        By induction hypothesis there is an integer $j$, well-defined state $s^1_j$, $s^2_j$ and a tree $sub$ such that:
        \[(\scan{str}{\fdown{init_1}{n}})[j] = (s^1_j, n, \down) \qquad (\scan{str}{\fdown{init_2}{n}})[j] = (s^2_j, n, \down)\]
        \[s^1_i = \traverse{sub}{(\beginRb{(\get{s^1_j})})} \qquad s^2_i = \traverse{sub}{(\beginRb{(\get{s^2_j})})}\]
        \[0 \leq j < i - 1 \qquad \size{sub} < \size{tr} \qquad \]

        Since $l_1[j + 1] = (\scan{str}{\fdown{init_1}{n}})[j]$ and $l_2[j + 1] = (\scan{str}{\fdown{init_2}{n}})[j]$, $j + 1$, $sub$, $s^1_j$ and $s^2_j$ satisfy the above conditions.

        \item If $c = n$, then  $i =  2\cdot (\size{tr}) - 1$ is valid and therefore $j = 0$, $s^1_j = init_1$, $s^2_j = init_2$ and $sub = str$.
        \end{itemize}
        \item If $tr = \artNode{left}{right}$:
        \begin{itemize}
            \item If $i < 2 \cdot \size{left}$, then by \cref{scan_indexing}, $l_1[i] = (\scan{left}{init_1})[i]$ and $l_2[i] = (\scan{left}{init_2})[i]$.
            By induction hypothesis, there are $j$, well-defined $s^1_j$, $s^2_j$ and $sub$ such that.
            \[(\scan{left}{init_1})[j] = (s^1_j, n, \down) \qquad\, (\scan{left}{init_2})[j] = (s^2_j, n, \down)\]
            \[s^1_i = \traverse{sub}{(\beginRb{(\get{s^1_j})})} \qquad s^2_i = \traverse{sub}{(\beginRb{(\get{s^2_j})})}\]
            \[0 \leq j < i \qquad \size{sub} < \size{left}\]
            Since $l_1[j] = (\scan{left}{init_1})[j]$ and $l_2[j] = (\scan{left}{init_2})[j]$, $j$, $s^1_j$, $s^2_j$ and $sub$ satisfy the claim.
            \item If $i \geq 2 \cdot \size{left}$, then by \cref{scan_indexing}, $l_1[i] = (\scan{right}{(\traverse{left}{init_1})})[i - 2 \cdot \size{left}]$ and $l_2[i] = (\scan{right}{(\traverse{left}{init_2})})[i - 2 \cdot \size{left}]$.
            By induction hypothesis, there are $j$, well-defined $s^1_j$, $s^2_j$ and $sub$ such that.
            \[(\scan{right}{(\traverse{left}{init_1})})[j] = (s^1_j, n, \down) \qquad (\scan{right}{(\traverse{left}{init_2})})[j] = (s^2_j, n, \down)\]
            \[s^1_i = \traverse{sub}{(\beginRb{(\get{s^1_j})})} \qquad s^2_i = \traverse{sub}{(\beginRb{(\get{s^2_j})})}\]
            \[ 0 \leq\, j < i - 2\cdot \size{left} \qquad \size{sub} < \size{right}\]

            Since $l_1[j + 2 \cdot\, \size{left}] = (\scan{right}{(\traverse{left}{init_1})})[j] $ and $l_2[j + 2 \cdot \size{left}] = (\scan{right}{(\traverse{left}{init_2})})[j]$, $j + 2 \cdot \size{left}$, $s^1_j$, $s^2_j$ and $sub$ satisfy the claim.
        \end{itemize}
    \end{itemize}
\end{proof}

\begin{corollary}[\textcode{findBeginRollback}]
    \label{find_begin_rb}
    Let tr be a tree of nodes, $init$ a states and let $l := \scan{tr}{init}$.
    If there exists a non-negative integer $i < 2 \cdot (\size{tr})$, a well-defined states $s_i$ and a rollback node $n$ such that 
    $l[i] = (s_i, n, \up)$, then there is an integer $j$, a well-defined states $s_j,$ and a tree $sub$ such that 
    \[0 \leq j < i \qquad l[j] = (s_j, n, \down) \qquad s_i = \traverse{sub}{(\beginRb{s_j})} \qquad \size{sub} < \size{tr}\]
\end{corollary}

\begin{proof}
    By \cref{find_two_begin_rb} with $init_1 = init_2$.
\end{proof}









\newpage


\section*{Active Keys Lemmas}

\begin{definition}[\textcode{State.activeKeys.get}]
    Let $s$ be a well-defined state and $k$ a key, \bolddef{\actkey{k}{s}} is the value associated to key in the active keys of the state 
    (i.e. we first look at the local keys, then the global ones filtering the consumed contracts).
\end{definition}

\begin{definition}[\textcode{nodeActionKeyMapping}]
    Let $n$ be a node, \bolddef{\mapping{n}} is defined as:
    \begin{itemize}
        \item \mapping{(\createNode{id}{k})} := \keyInact
        \item \mapping{(\fetchNode{id}{k})} := \keyAct{id}
        \item \mapping{(\lookupNode{result}{k})} := result
        \item \mapping{(\exNode{id}{k})} := \keyAct{id}
    \end{itemize}
\end{definition}

\begin{lemma}[\textcode{handleNodeUndefined}]
    \label{defined_def}
    For any well-defined state s and Action node n, 
    \[\defined{(\hNode{s}{n})} \iff {\actkey{n.k}{s} = \mapping{n}}\]
\end{lemma}


\begin{corollary}[\textcode{handleSameNodeActiveKeys}]
    \label{same_key_hnode}
    For any well-defined states $s_1$, $s_2$ and Action node n, if $\defined{(\hNode{s_ 1}{n})}$ and $\defined{(\hNode{s_ 2}{n})}$ 
    \[\actkey{n.k}{s_1} = \actkey{n.k}{s_2}\]
\end{corollary}

\begin{proof}
    Direct consequence of \cref{defined_def}.
\end{proof}

\begin{lemma}[\textcode{handleNodeDifferentStatesActiveKeysGet}]
    \label{same_key_after_hnode}
    For any well-defined states $s_1$, $s_2$ and Action node n, if $\defined{(\hNode{s_ 1}{n})}$ and $\defined{(\hNode{s_ 2}{n})}$ 
    \[\actkey{n.k}{(\get{(\hNode{s_1}{n})})} = \actkey{n.k}{(\get{(\hNode{s_2}{n})})}\]
\end{lemma}


\begin{lemma}[\textcode{handleNodeActiveKeysGet}]
    \label{actkey_handle_node}
    For any well-defined state $s$, Action node $n$, key $k_2$, if $n$ has no key or $k_2 \neq n.k$ and if $\defined{(\hNode{s}{n})}$,
    \[\actkey{k_2}{(\get{(\hNode{s}{n})})} = \actkey{k_2}{s}\]
\end{lemma}

\begin{lemma}[\textcode{beginRollbackActiveKeysGet}]
    \label{act_begin_rb}
    For any well-defined state s, node n, key $k$,
    \[\actkey{k}{(\beginRb{s})} = \actkey{k}{s}\]
\end{lemma}


\begin{lemma}[\textcode{activeKeysGetRollbackScope}]
    \label{skip_rb}
    For any well-defined state s, node n, key $k$, function $g: \state \rightarrow \state $ and:
    \begin{itemize}
        \item $g(\beginRb{s}).rollbackStack = (\beginRb{s}).rollbackStack$
        \item $g(\beginRb{s}).globalKeys = (\beginRb{s}).globalKeys$
    \end{itemize}

    We have:
    \[\actkey{k}{(\enRb{g(\beginRb{s})})} = \actkey{k}{s}\]
    
\end{lemma}






\newpage




\section*{The real deal}


\begin{definition}[\textcode{appearsAtIndex}, \textcode{doesNotAppearBefore}, \textcode{firstAppears}]
    \label{appear_def}
    Let tr be a tree of nodes, init a value, $k$ a key, $f_1, f_2$ two functions, $i < 2 \cdot \size{tr}$ a non-negative integer and let $l := \longscan{tr}{init}{f_1}{f_2}$. 

    We say that $k$ does not appear before $i$ if for all $0 \leq j < i,\  (\snd{l[j]}).k \neq k$ or $\trd{l[j]} =\, \up$

    We say that $i$ is the first appearance of $k$ in $l$ if $(\snd{l[i]}).k = k$, $\trd{l[i]} = \ \down$ and $k$ does not appear before $i$.
\end{definition}


\begin{claim}[\textcode{doesNotAppearBeforeSame}, \textcode{firstAppearsSame}]
    \label{appear_same}
    Let tr be a tree of nodes, $init, init_2$ a state, $f^1_1, f^1_2, f^2_1, f^2_2$ functions, $k$ a key, $i$ a non-negative integer smaller than $2 \cdot \size{tr}$,
     $l_1 := \longscan{tr}{init_1}{f^1_1}{f^1_2}$ and $l_2 := \longscan{tr}{init_2}{f^2_1}{f^2_2}$. 
     \begin{center}
        $k$ does not appear before $i$ in $l_1$ $\iff$ $k$ does not appear before $i$ in $l_2$
     \end{center}  
     and in particular
     \begin{center}
        $i$ is the first appearance of $k$ in $l_1$ $\iff$ $i$ is the first appearance of $k$ in $l_2$
     \end{center}  
\end{claim}

\begin{proof}
    Consequence of \cref{scan_indexing_node}.
\end{proof}

\begin{claim}[\textcode{findFirstAppears}]
    \label{find_first_appear}
    Let tr be a tree of nodes, $init$ a state, $k$ a key, $0 \leq i_1 < i_2 < 2\cdot \size{tr}$ twos integers and
    let $l := \scan{tr}{init}$. If $k$ appears before $i_2$ in $l$ but does not before $i_1$, then there exists an integer 
    $i_1 \leq j < i_2$ such that $j$ is the first appearance of $k$ in $l$.
\end{claim}

\begin{proof}
    Immediate from \cref{appear_def}.
\end{proof}

\begin{claim}[\textcode{doesNotAppearBeforeSameActiveKeysGet}]
    \label{actkey_not_appear}
    Let tr be a tree of nodes, init a state, $k$ a key, $0 \leq j < i < 2\cdot\, \size{tr}$ two integers and let $l := \scan{tr}{init}$. 
    If $k$ does not appear before $i$ in $l$ and $\defined{(\fst{(l[i])})}$ (and  $\defined{(\fst{(l[j])})}$ by \cref{defined_prop}) then 
    \[\actkey{k}{(\get{(\fst{(l[i])})})} = \actkey{k}{(\get{(\fst{(l[j])})})}\]
\end{claim}

\begin{proof}
    By induction on $i$.

    If $i = 0$ then the precondition is never met.

    Else let $(s_{i -1}, n_{i - 1}, dir_{i - 1}) := l[i - 1]$ and $s_i := \fst{(l[i])}$. By \cref{defined_prop} $\defined{s_{i - 1}}$.

    By \cref{scan_indexing_state} we either have:
    \begin{itemize}
        \item $s_i = \fdown{s_{i - 1}}{n_{i - 1}}$ and $dir_{i - 1} =\, \down$.
        
            If $n_{i - 1}$ is an Action node, since $k$ does not appear before $i$, $k \neq n_{i - 1}.k$, then:
        \begin{align*}
            \actkey{k}{(\get{s_i})} &= \actkey{k}{(\get{(\hNode{(\get{s_{i - 1}})}{n_{i - 1}})})} \\
             &= \actkey{k}{(\get{s_{i - 1}})} &\text{from \cref{actkey_handle_node}} \\
             &= \actkey{k}{(\get{(\fst{(l[j])})})} &\text{for all $j < i - 1$ by IH}
        \end{align*}

        If $n_{i - 1}$ is a Rollback node then
        \begin{align*}
            \actkey{k}{(\get{s_i})} &= \actkey{k}{(\beginRb{(\get{s_{i - 1}})})}\\
            &= \actkey{k}{(\get{s_{i - 1}})} &\text{by \cref{act_begin_rb}} \\
            &= \actkey{k}{(\get{(\fst{(l[j])})})} &\text{for all $j < i - 1$ by IH } 
        \end{align*}

        \item $s_i = \fup{s_{i - 1}}{n_{i - 1}}$ and $dir_{i - 1} =\, \up$.
        
        If $n_{i - 1}$ is an Action node then
        \begin{align*}
            \actkey{k}{(\get{s_i})} &= \actkey{k}{(\get{s_{i - 1}})} \\
            &=\actkey{k}{(\get{(\fst{(l[j])})})} &\text{\qquad  \qquad for all $j < i - 1$ by IH } 
        \end{align*}

        If $n_{i - 1}$ is a Rollback node then
        \[\actkey{k}{(\get{s_i})} = \actkey{k}{(\enRb{(\get{s_{i - 1}})})} \]
        By \cref{find_begin_rb} there exists an integer $0 \leq j' < i - 1$, a well-defined state $s_{j'} = \fst{(l[j'])}$ and a tree $sub$ such that $s_{i - 1} = \traverse{sub}{(\beginRb{(\get{s_{j'}})})}$. Therefore
        \begin{align*}
            \actkey{k}{(\get{s_i})} &= \actkey{k}{(\enRb{(\get{(\traverse{sub}{(\beginRb{(\get{s_j'})})})})})} \\
            &= \actkey{k}{(\get{s_{j'}})} \text{\hskip 14.5em by \cref{skip_rb}} \\
            &= \actkey{k}{(\get{(\fst{(l[j'])})})}
        \end{align*}
        In addition, by the induction hypothesis
        \begin{align*}
        \actkey{k}{(\get{s_{i - 1}})} &= \actkey{k}{(\get{(\fst{(l[j])})})} \text{\hskip 6em for all $j < i - 1$} \\
        &= \actkey{k}{(\get{(\fst{(l[j'])})})} \\
        &= \actkey{k}{(\get{s_i})}
        \end{align*}
    \end{itemize} 
    
\end{proof}

\begin{corollary}[\textcode{firstAppearsSameActiveKeysGet}]
    \label{actkey_first_appear}
    Let tr be a tree of nodes, init a state, $k$ a key, $0 \leq j < i < 2\cdot \size{tr}$ two integers and let $l := \scan{tr}{init}$. 
    If $i$ is the first appearance of $k$ in $l$ and $\defined{(\fst{(l[i])})}$ (and  $\defined{(\fst{(l[j])})}$ by \cref{defined_prop}), then 
    \[\actkey{k}{(\get{(\fst{(l[i])})})} = \actkey{k}{(\get{(\fst{(l[j])})})}\]
\end{corollary}
\begin{proof}
    Direct consequence of \cref{actkey_not_appear}.
\end{proof}

\begin{corollary}[\textcode{firstAppearsHandleNodeUndefined}]
    \label{defined_first_appear}
    Let tr be a tree of nodes, init a state, $0 \leq i < 2\cdot \size{tr}$ an integer, let $l := \scan{tr}{init}$ and $(s, n, dir) := l[i]$. 
    If $n$ is an Action node with a well-defined key, $i$ is the first appearance of $n.k$ in $l$ and $\defined{s}$, then 
    \[\actkey{n.k}{(\get{init})} = \actkey{n.k}{(\get{s})}\]
    \[\text{and in particular}\] 
    \[\defined{(\hNode{(\get{s})}{n})} \iff \actkey{n.k}{(\get{init})} = \mapping{n}\]
\end{corollary}
\begin{proof}
    The first statement is a direct consequence of \cref{actkey_first_appear}. Applying \cref{defined_def} gives us the second statement.
\end{proof}

\begin{claim}[\textcode{appearsBeforeSameActiveKeysGet}]
    \label{actkey_after_appear}
    Let tr be a tree of nodes, $init_1$, $init_2$ two state, $k$ a key, $0 \leq i < 2\cdot \size{tr}$ an integer, 
    let $l_1 := \scan{tr}{init_1}$, $l_2 := \scan{tr}{init_2}$, $s^1_i := \fst{(l_1[i])}$ and $s^2_i := \fst{(l_2[i])}$. 
    If $k$ appears before $i$ in $l_1$ and $l_2$, $\defined{s^1_i}$ and $\defined{s^2_i}$, then 
    \[\actkey{k}{(\get{s^1_i})} = \actkey{k}{(\get{s^2_i})}\]
\end{claim}
\begin{proof}
    By strong induction on i:

    If $i = 0$ then the precondition is never met.

    Else let $(s^1_{i -1}, n^1_{i - 1}, dir^1_{i - 1}) := l_1[i - 1]$, $(s^2_{i -1}, n^2_{i - 1}, dir^2_{i - 1}) := l_2[i - 1]$.
    By \cref{scan_indexing_node}, $n_{i - 1} := n^1_{i - 1} = n^2_{i - 1}$ and $dir_{i - 1} := dir^1_{i - 1} = dir^2_{i - 1}$.

    By \cref{scan_indexing_state} we either have:
    \begin{itemize}
        \item $s^1_i = \fdown{s^1_{i - 1}}{n_{i - 1}}$, $s^2_i = \fdown{s^2_{i - 1}}{n_{i - 1}}$ and $dir_{i - 1} =\, \down$ 
        
            If $n_{i - 1}$ is an Action node then:
            \begin{itemize}
                \item If $n_{i - 1}.k = k$:
                \begin{align*}
                    \actkey{n_{i - 1}.k}{(\get{s^1_i})} &= \actkey{n_{i - 1}.k}{(\get{(\hNode{(\get{s^1_{i - 1}})}{n_{i - 1}})})} \\
                     &= \actkey{n_{i - 1}.k}{(\get{(\hNode{(\get{s^2_{i - 1}})}{n_{i - 1}})})} & \text{by \cref{same_key_after_hnode}}\\
                     &= \actkey{n_{i - 1}.k}{(\get{s^2_{i}})} \\
                \end{align*}
                \item Otherwise, k appears before $i - 1$ in $l_1$ and $l_2$:
                \begin{align*}
                    \actkey{k}{(\get{s^1_i})} &= \actkey{k}{(\get{(\hNode{(\get{s^1_{i - 1}})}{n_{i - 1}})})} \\
                    &= \actkey{k}{(\get{s^1_{i - 1}})} &\text{by \cref{actkey_handle_node}} \\
                    &= \actkey{k}{(\get{s^2_{i - 1}})} &\text{by IH} \\
                    &= \actkey{k}{(\get{(\hNode{(\get{s^2_{i - 1}})}{n_{i - 1}})})} &\text{by \cref{actkey_handle_node}} \\
                    &= \actkey{k}{(\get{s^2_i})}
                \end{align*}
            \end{itemize}

        If $n_{i - 1}$ is a Rollback node then
        \begin{align*}
            \actkey{k}{(\get{s^1_i})} &= \actkey{k}{(\beginRb{(\get{s^1_{i - 1}})})}\\
            &= \actkey{k}{(\get{s^1_{i - 1}})} &\text{by \cref{act_begin_rb}} \\
            &= \actkey{k}{(\get{s^2_{i - 1}})} &\text{by IH} \\
            &= \actkey{k}{(\beginRb{(\get{s^2_{i - 1}})})} &\text{by \cref{act_begin_rb}}\\
            &= \actkey{k}{(\get{s^2_i})}
        \end{align*}

        \item $s^1_i = \fup{s^1_{i - 1}}{n_{i - 1}}$, $s^2_i = \fup{s^2_{i - 1}}{n_{i - 1}}$ and $dir_{i - 1} =\, \up$
        
        If $n_{i - 1}$ is an Action node then
        \begin{align*}
            \actkey{k}{(\get{s^1_i})} &= \actkey{k}{(\get{s^1_{i - 1}})} \\
            &= \actkey{k}{(\get{s^2_{i - 1}})} &\text{by IH}\\
            &=\actkey{k}{(\get{s^2_i})}
        \end{align*}

        If $n_{i - 1}$ is a Rollback node then
        \[\actkey{k}{(\get{s^1_i})} = \actkey{k}{(\enRb{(\get{s^1_{i - 1}})})} \]
        By \cref{find_two_begin_rb} there exists an integer $0 \leq j < i - 1$ , well-defined states $s^1_{j}$, $s^2_{j}$ and tree $sub$ such that $s^1_{i - 1} = \traverse{sub}{(\beginRb{(\get{s^1_{j}})})}$, 
        $s^2_{i - 1} = \traverse{sub}{(\beginRb{(\get{s^2_{j}})})}$, $l_1[j] = (s^1_j, n_{i - 1}, \down)$, $l_2[j] = (s^2_j, n_{i - 1}, \down)$. Therefore
        \begin{align*}
            \actkey{k}{(\get{s^1_i})} &= \actkey{k}{(\enRb{(\get{(\traverse{sub}{(\beginRb{(\get{s^1_{j}})})})})})} \\
            &= \actkey{k}{(\get{s^1_{j}})} &\text{by \cref{skip_rb}} \\
        \intertext{If $k$ appears before $j$ in $l_1$ (and $l_2$ by \cref{appear_same}) then we can use the induction hypothesis and go backward.}
            &= \actkey{k}{(\get{s^2_{j}})} &\text{by IH} \\
            &= \actkey{k}{(\enRb{(\get{(\traverse{sub}{(\beginRb{(\get{s^2_{j}})})})})})} &\text{by \cref{skip_rb}}\\
            &= \actkey{k}{(\get{s^2_i})}
        \end{align*}

        If $k$ does not appear before $j$ in $l_1$ and $l_2$, we can use \cref{find_first_appear} to obtain the index $j \leq j' < i$ such that $j'$ is the
        first appearance of $k$ in $l_1$ and $l_2$. 

        Since $j' < i$ , by \cref{defined_prop}, $\defined{(\fst{(l_1[j'])})}$, $\defined{(\fst{(l_2[j'])})}$, $\defined{(\fst{(l_1[j' + 1])})}$ and  $\defined{(\fst{(l_2[j' + 1])})}$.
        By \cref{scan_indexing_state}, $\fst{(l_1[j' + 1])} = \hNode{(\get{(\fst{(l_1[j'])})})}{(\snd{(l_1[j'])})}$ and $(\snd{(l_1[j'])}).k = k$.
        Similarly, $\fst{(l_2[j' + 1])} = \hNode{(\get{(\fst{(l_2[j'])})})}{(\snd{(l_2[j'])})}$ and $(\snd{(l_2[j'])}).k = k$.
        Therefore:
        \begin{align*}
            \actkey{k}{s^1_{j}} &= \actkey{k}{(\get{(\fst{(l_1[j'])})})} &\text{by \cref{actkey_first_appear}} \\
            &= \actkey{k}{(\get{(\fst{(l_2[j'])})})} &\text{by \cref{same_key_hnode}} \\
            &= \actkey{k}{(\get{s^2_{j}})} &\text{by \cref{actkey_first_appear}} \\
            &= \actkey{k}{(\enRb{(\get{(\traverse{sub}{(\beginRb{(\get{s^2_j})})})})})} &\text{by \cref{act_begin_rb}} \\
            &= \actkey{k}{(\get{s^2_i})}
        \end{align*}
        
    \end{itemize} 

\end{proof}

\begin{corollary}[\textcode{appearsBeforeSameUndefined}]
    \label{same_defined_appear}
    Let tr be a tree of nodes, $init_1, init_2$ states, $0 \leq i < 2\cdot \size{tr} - 1$ an integer, let $l_1 := \scan{tr}{init_1}$, $l_2 := \scan{tr}{init_2}$, $(s^1, n^1, dir^1) := l_1[i]$ and $(s^2, n^2, dir^2) := l_2[i]$. 
    By \cref{scan_indexing_node}, $n := n^1 = n^2$. If $n$ is an Action node, $n.k$ appears before $i$ in $l_1$ and $l_2$, $\defined{s^1}$ and $\defined{s^2}$, then 
    \[\defined{(\fst{(l_1[i + 1])})} \iff \defined{(\fst{(l_2[i + 1])})}\]
\end{corollary}

\begin{proof}
    Consequence of \cref{actkey_after_appear} and \cref{defined_def}.
\end{proof}

\newpage

\section*{Empty state traversal}

\begin{definition}[\textcode{collect}]
    Let $tr$ be a tree of nodes. 
    We respectively define the mapping \bolddef{\collect{tr}} as $\longtraverse{tr}{\emptyList}{f_{collect}}{id}$ and \bolddef{\collectTr{tr}} as
    $\longscan{tr}{\emptyList}{f_{collect}}{id}$, where
    \[\fcoll{m}{n} = 
        \begin{cases} 
            m + (n.k \to \mapping{n}) &\text{if $n$ is an Action node with a well-defined key and $n.k \notin m$} \\
            m &\text{otherwise}
         \end{cases} \] 
\end{definition}

\begin{definition}[\textcode{emptyState}]
    We define the empty state $\emptyState{tr}$ as the state whose rollback stack, locally created contracts set, consumed contracts set and local keys map are empty, 
    but whose global key map is $\collect{tr}$
\end{definition}

\begin{claim}[\textcode{collectTraceProp}]
    \label{collect_submap}
    Let tr be a tree of nodes and $0 \leq i < 2 \cdot \, \size{tr}$ an integer
    \[\fst{((\collectTr{tr})[i])} \subseteq \collect{tr}\] 
\end{claim}

\begin{proof}
    By backward induction on $i$ and applying \cref{scan_indexing_state}.
\end{proof}

\begin{claim}[\textcode{collectTraceDoesNotAppear}, \textcode{collectDoesNotAppear}]
    \label{collect_not_contains}
    Let tr be a tree of nodes, $0 \leq i < 2 \cdot \, \size{tr}$ an integer and $k$ a key. 
    \[k \text{ does not appear before } i \text{ in } \collectTr{tr} \iff k \notin \fst{((\collectTr{tr})[i])}\] 
    In particular
    \[k \text{ does not appear before } 2 \cdot \size{tr} - 1 \text{ in } \collectTr{tr} \iff k \notin \collect{tr}\]
\end{claim}

\begin{proof}
    Induction on $i$, applying \cref{scan_indexing_state}.
\end{proof}


\begin{corollary}[\textcode{collectGet}]
    \label{first_mapping}
    Let tr be a tree of nodes, $0 \leq i < 2 \cdot \, \size{tr}$ an integer, 
    $n := \snd{((\collectTr{tr})[i])}$. If $n$ is an Action node with a well-defined key and $i$ is the first appearance of $n.k$ in $\collectTr{tr}$, then
    \[(\collect{tr})[n.k] = \mapping{n}\] 
\end{corollary}
    
\begin{proof}
    By \cref{collect_not_contains}, $n.k \notin \fst{((\collectTr{tr})[i])}$. By applying \cref{scan_indexing_state} we have that $(n.k \to \mapping{n}) \in \fst{((\collectTr{tr})[i + 1])}$
    if $i < 2 \cdot \, \size{tr} - 1$ and $(n.k \to \mapping{n}) \in \collect{tr}$ otherwise. In the first case we make use of \cref{collect_submap} to prove the claim.
\end{proof}

\begin{corollary}[\textcode{collectContains}]
    \label{find_k_first_appear}
    Let $tr$ be a tree of nodes and  $k$ a key. If $k \in \collect{tr}$ then there exists an integer $0 \leq  i < 2 \cdot \size{tr} - 1$ such that
    $i$ is the first appearance of $k$ in $\collectTr{tr}$.
\end{corollary}
\begin{proof}
    By \cref{collect_not_contains}, if $k \in \collect{tr}$ then $k$ does not appear before $2 \cdot \size{tr} - 1$. \cref{find_first_appear} concludes the proof.
\end{proof}

\begin{corollary}[\textcode{firstAppearsHandleNodeUndefinedEmpty}]
    \label{defined_globalkeys_mapping}
    Let tr be a tree of nodes, $init$ a state, $0 \leq i < 2\cdot \size{tr} - 1$ an integer, let $l := \scan{tr}{init}$, and $n := \snd{(l[i])}$. 
   If $n$ is an Action node with a well-defined key, $i$ is the first appearance of $n.k$ in $l$ and $\defined{(\fst{(l[i])})}$ then 
   \[\defined{(\fst{(l[i + 1])})} \iff \actkey{n.k}{(\get{init})} = (\emptyState{tr}.globalKeys)[n.k]\]
\end{corollary}

\begin{proof}
    Let $l_{\varepsilon} = \scan{tr}{\emptyState{tr}}$. We know by \cref{scan_indexing_node} that $n = \snd{(l_{\varepsilon}[i])}$.
     and $\fst{(l_\varepsilon[i + 1])} = \hNode{(\fst{(l_\varepsilon[i])})}{n}$.
    Furthemore by \cref{appear_same}, $n.k$ does not appear before $i$ in $l_{\varepsilon}$. Finally by \cref{defined_traverse_prop}, if $\defined{(\traverse{tr}{\emptyState{tr}})}$ then $\defined{(\fst{(l_{\varepsilon}[i])})}$.
    
    \begin{align*}
        &\actkey{n.k}{(\get{init})} = (\emptyState{tr}.globalKeys)[n.k] \\
        \iff &\actkey{n.k}{(\get{init})} = (\collect{tr})[n.k] \\
        \iff &\actkey{n.k}{(\get{init})} =\, \mapping{n} &\text{by \cref{first_mapping}} \\
        \iff &\defined{(\hNode{(\get{(\fst{(l[i])})})}{n})} &\text{by \cref{defined_first_appear}}\\
        \iff &\defined{(\fst{(l[i + 1])})} &\text{by \cref{scan_indexing_state}}
    \end{align*}
\end{proof}

\begin{corollary}
    \label{defined_empty_traverse}
    Let tr be a tree of nodes, $init$ a state, $0 \leq i < 2\cdot \size{tr} - 1$ an integer, let $l := \scan{tr}{init}$, and $n := \snd{(l[i])}$. 
   If $n$ is an Action node with a well-defined key, $\defined{(\traverse{tr}{\emptyState{tr}})}$, $n.k$ appears before $i$ in $l$ and $\defined{(\fst{(l[i])})}$ then 
   \[\defined{(\fst{(l[i + 1])})}\]
\end{corollary}

\begin{proof}
    By \cref{defined_traverse_prop}, if $\defined{(\traverse{tr}{\emptyState{tr}})}$ then $\defined{(\fst{((\scan{tr}{\emptyState{tr}})[i])})}$ and \\
    $\defined{(\fst{((\scan{tr}{\emptyState{tr}})[i + 1])})}$. Applying \cref{same_defined_appear} concludes the proof.
\end{proof}


\begin{res}[\textcode{traverseTransactionEmptyDefined}]
    Let $tr$ be a tree of nodes and $init$ a well-defined state. If $\defined{(\traverse{tr}{\emptyState{tr}})}$, then
    \[ (\forall (k \to m) \in \emptyState{tr}.globalKeys,\ \actkey{k}{(\get{init})} = m) \iff \defined{(\traverse{tr}{init})}  \]  
\end{res}


\begin{proof}
    Let $l := \scan{tr}{init}$.

    $(\Rightarrow)$ direction: By \cref{defined_alt_def}, we only need to prove that for an arbitrary $0 \leq i < 2 \cdot \, \size{tr} \, - 1$,\\
     $\defined{(\fst{(l[i])})} \implies \defined{(\fst{(l[i + 1])})}$.
     If $n := \snd{(l[i])}$ is a Rollback node, if $\trd{(l[i])} =\, \up$ or if $n$ is an Action node with no key, then by \cref{scan_indexing_state} (and \cref{actkey_handle_node} in the Action node case) this is automatically true.
     
     If $n$ is an Action node then either:
     \begin{itemize}
        \item $i$ is the first appearance of $n.k$ in which case by \cref{defined_globalkeys_mapping} validates the claim
        \item $n.k$ appears before $i$ in which case by \cref{defined_empty_traverse}, $\defined{(\fst{(l[i + 1])})}$
     \end{itemize}

     $(\Leftarrow)$ direction:
     Assume there exists a key $k$ such that $k \in \emptyState{tr}.globalKeys$ and $\actkey{k}{(\get{init})} \neq (\emptyState{tr}.globalKeys)[k]$. 
     Then $k \in \collect{tr}$ and by \cref{find_k_first_appear}, there is a $0 \leq i < 2 \cdot \size{tr} - 1$ such that 
     $i$ is the first appearance of $k$ in $\collectTr{tr}$. In particular this means that $n := \snd{((\collectTr{tr})[i])}$ is an Action node with a well-defined
     key and $k = n.k$. By \cref{defined_globalkeys_mapping} this means that either $\neg{\defined{(\fst{(l[i])})}}$ or $\neg{\defined{(\fst{(l[i + 1])})}}$, which both imply by \cref{defined_traverse_prop}
     that $\neg{\defined{(\traverse{tr}{init})}}$.
\end{proof}


\end{document}

-- Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module ContractKeys (main) where

import DA.List (sort)
import DA.Text (isInfixOf)

import UpgradeTestLib

import qualified V1.ContractKeys as V1
import qualified V2.ContractKeys as V2
import qualified V1.ChangedKeyExpr as V1
import qualified V2.ChangedKeyExpr as V2
import qualified V1.ChangedMaintainersExpr as V1
import qualified V2.ChangedMaintainersExpr as V2
import qualified V1.UpgradedContractKeys as V1
import qualified V2.UpgradedContractKeys as V2
import qualified V1.InvalidKeyUpgrade as V1
import qualified V2.InvalidKeyUpgrade as V2
import qualified V1.InvalidKeyRenaming as V1
import qualified V2.InvalidKeyRenaming as V2
import qualified V1.ContractKeyPresence as V1
import qualified V2.ContractKeyPresence as V2
import qualified V1.IfaceMod as Iface
import qualified V1.KeyUpgradeClient as Client

{- PACKAGE
name: contract-key-upgrades-iface
versions: 1
-}

{- MODULE
package: contract-key-upgrades-iface
contents: |
  module IfaceMod where

  data MyUnit = MyUnit {}
    deriving (Eq, Show)

  interface I where
    viewtype MyUnit

    nonconsuming choice NoOp : ()
      controller signatory this
      do pure ()
-}

{- PACKAGE
name: contract-key-upgrades
versions: 2
depends: contract-key-upgrades-iface-1.0.0
-}

main : TestTree
main = tests
  [ subtree "Unchanged key type"
    [ subtree "Unchanged key expression"
      [ ("queryContractKey, src=v1 tgt=v2", queryKeyUnchanged)
      , ("exerciseByKeyCmd, src=v1 tgt=v2", exerciseCmdKeyUnchanged)
      , ("fetchByKey, src=v1 tgt=v2 ", fetchKeyUnchanged)
      , ("exerciseByKey, src=v1 tgt=v2", exerciseUpdateKeyUnchanged)
      ]
    , subtree "Changed key expression"
      [ subtree "Unchanged key value"
        [ ("queryContractId, src=v1 tgt=v2", queryKeyChangedExprSameValue)
        , ("queryContractKey, src=v1 tgt=v2", qckKeyChangedExprSameValue)
        , ("fetch, src=v1 tgt=v2", fetchKeyChangedExprSameValue)
        , ("fetchByInterface, src=v1 tgt=i", fbiKeyChangedExprSameValue)
        , ("fetchByKey, src=v1 tgt=v2", fbkKeyChangedExprSameValue)
        , ("exercise, src=v1 tgt=v2", exerciseKeyChangedExprSameValue)
        , ("exerciseByInterface, src=v1 tgt=i", ebiKeyChangedExprSameValue)
        , ("exerciseByKey, src=v1 tgt=v2", ebkKeyChangedExprSameValue)
        , ("exerciseCmd, src=v1 tgt=v2", exerciseCmdKeyChangedExprSameValue)
        , ("exerciseByKeyCmd, src=v1 tgt=v2", ebkCmdKeyChangedExprSameValue)
        ]
      , subtree "Changed key value"
        [ ("queryContractId, src=v1 tgt=v2", queryKeyChangedExprChangedValue)
        , ("queryContractKey, src=v1 tgt=v2", qckKeyChangedExprChangedValue)
        , ("fetch, src=v1 tgt=v2", fetchKeyChangedExprChangedValue)
        , ("fetchByInterface, src=v1 tgt=i", fbiKeyChangedExprChangedValue)
        , ("fetchByKey, src=v1 tgt=v2", fbkKeyChangedExprChangedValue)
        , ("exercise, src=v1 tgt=v2", exerciseKeyChangedExprChangedValue)
        , ("exerciseByInterface, src=v1 tgt=i", ebiKeyChangedExprChangedValue)
        , ("exerciseByKey, src=v1 tgt=v2", ebkKeyChangedExprChangedValue)
        , ("exerciseCmd, src=v1 tgt=v2", exerciseCmdKeyChangedExprChangedValue)
        , ("exerciseByKeyCmd, src=v1 tgt=v2", ebkCmdKeyChangedExprChangedValue)
        ]
      ]
    , subtree "Changed maintainers expression"
      [ subtree "Unchanged maintainers value"
        [ ("queryContractId, src=v1 tgt=v2", queryMaintainersChangedExprSameValue)
        , ("queryContractMaintainers, src=v1 tgt=v2", qckMaintainersChangedExprSameValue)
        , ("fetch, src=v1 tgt=v2", fetchMaintainersChangedExprSameValue)
        , ("fetchByKey, src=v1 tgt=v2", fbkMaintainersChangedExprSameValue)
        , ("exercise, src=v1 tgt=v2", exerciseMaintainersChangedExprSameValue)
        , ("exerciseByMaintainers, src=v1 tgt=v2", ebkMaintainersChangedExprSameValue)
        , ("exerciseCmd, src=v1 tgt=v2", exerciseCmdMaintainersChangedExprSameValue)
        , ("exerciseByMaintainersCmd, src=v1 tgt=v2", ebkCmdMaintainersChangedExprSameValue)
        ]
      , subtree "Changed maintainers value"
        [ ("queryContractId, src=v1 tgt=v2", queryMaintainersChangedExprChangedValue)
        , ("queryContractMaintainers, src=v1 tgt=v2", qckMaintainersChangedExprChangedValue)
        , ("fetch, src=v1 tgt=v2", fetchMaintainersChangedExprChangedValue)
        , ("fetchByKey, src=v1 tgt=v2", fbkMaintainersChangedExprChangedValue)
        , ("exercise, src=v1 tgt=v2", exerciseMaintainersChangedExprChangedValue)
        , ("exerciseByMaintainers, src=v1 tgt=v2", ebkMaintainersChangedExprChangedValue)
        , ("exerciseCmd, src=v1 tgt=v2", exerciseCmdMaintainersChangedExprChangedValue)
        , ("exerciseByMaintainersCmd, src=v1 tgt=v2", ebkCmdMaintainersChangedExprChangedValue)
        ]
      ]
    ]
  , subtree "Changed key type, valid upgrade"
    [ subtree "Unchanged key value (modulo trailing `None`s)"
      [ ("queryContractKey, src=v1 tgt=v2", queryKeyUpgraded)
      , ("exerciseByKeyCmd, src=v1 tgt=v2", exerciseCmdKeyUpgraded)
      , ("fetch, src=v1 tgt=v2", fetchKeyUpgraded)
      , ("exerciseByKey, src=v1 tgt=v2", exerciseUpdateKeyUpgraded)
      ]
    ]
  , subtree "Changed key type, invalid upgrade"
    [ broken ("queryContractKeyCmd, global", queryInvalidKeyUpgradeGlobal)
    , broken ("exerciseByKeyCmd, global", exerciseInvalidKeyUpgradeGlobal)
    , broken ("fetch, local", fetchInvalidKeyUpgradeLocal)
    , broken ("exerciseByKey, local", exerciseInvalidKeyUpgradeLocal)
    ]
  , subtree "Renamed key label, invalid upgrade"
    [ broken ("queryContractKeyCmd, global", queryInvalidKeyRenamingGlobal)
    , broken ("exerciseByKeyCmd, global", exerciseInvalidKeyRenamingGlobal)
    , broken ("fetch, local", fetchInvalidKeyRenamingLocal)
    , broken ("exerciseByKey, local", exerciseInvalidKeyRenamingLocal)
    ]
  , subtree "Changed key presence"
    [ subtree "Key in v1, no key in v2"
      [ ("fetch", fetchTemplateWithUnexpectedKey)
      ]
    , subtree "No key in v1, key in v2"
      [ ("fetch", fetchTemplateWithUnexpectedlyMissingKey)
      ]
    ]
  ]

{- MODULE
package: contract-key-upgrades
contents: |
  module ContractKeys where

  data UnchangedKeyKey = UnchangedKeyKey with
      p : Party
      n : Int
    deriving (Eq, Show)

  template UnchangedKey
    with
      party : Party
      n : Int
      newField : Optional Text                        -- @V  2
    where
      signatory party
      key (UnchangedKeyKey party n) : UnchangedKeyKey
      maintainer key.p

      choice UnchangedKeyCall : Text
        controller party
        do pure "V1"                                  -- @V 1
        do pure "V2"                                  -- @V  2

  template UnchangedKeyHelper
    with
      party : Party
    where
      signatory party
      choice UnchangedKeyFetch : (ContractId UnchangedKey, UnchangedKey) with
          k : UnchangedKeyKey
        controller party
        do fetchByKey k

      choice UnchangedKeyExercise : Text with
          k : UnchangedKeyKey
        controller party
        do exerciseByKey @UnchangedKey k UnchangedKeyCall
-}

queryKeyUnchanged : Test
queryKeyUnchanged = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.UnchangedKey a 1)
  keyRes <- queryContractKey a $ V2.UnchangedKeyKey a 1
  case keyRes of
    Some (foundCid, foundContract) | show foundCid == show cid && foundContract == V2.UnchangedKey a 1 None -> pure ()
    _ -> assertFail $ "Didn't find correct contract, expected " <> show (cid, V2.UnchangedKey a 1 None) <> ", got " <> show keyRes

exerciseCmdKeyUnchanged : Test
exerciseCmdKeyUnchanged = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.UnchangedKey a 1)
  res <- a `submit` exerciseByKeyExactCmd @V2.UnchangedKey (V2.UnchangedKeyKey a 1) V2.UnchangedKeyCall
  res === "V2"

fetchKeyUnchanged : Test
fetchKeyUnchanged = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createCmd (V1.UnchangedKey a 1)
  (foundCid, foundContract) <- a `submit` createAndExerciseCmd (V2.UnchangedKeyHelper a) (V2.UnchangedKeyFetch $ V2.UnchangedKeyKey a 1)
  foundContract === V2.UnchangedKey a 1 None
  show foundCid === show cid

exerciseUpdateKeyUnchanged : Test
exerciseUpdateKeyUnchanged = test $ do
  a <- allocateParty "alice"
  _ <- a `submit` createCmd (V1.UnchangedKey a 1)
  res <- a `submit` createAndExerciseCmd (V2.UnchangedKeyHelper a) (V2.UnchangedKeyExercise $ V2.UnchangedKeyKey a 1)
  res === "V2"

{- MODULE
package: contract-key-upgrades
contents: |
  module ChangedKeyExpr where

  import IfaceMod

  data ChangedKeyExprKey = ChangedKeyExprKey with
      p : Party
      b : Bool
    deriving (Eq, Show)

  template ChangedKeyExpr
    with
      party : Party
      b : Bool
    where
      signatory party
      key (ChangedKeyExprKey party False) : ChangedKeyExprKey -- @V 1
      key (ChangedKeyExprKey party b)     : ChangedKeyExprKey -- @V  2
      maintainer key.p

      interface instance I for ChangedKeyExpr where
        view = MyUnit {}

      choice ChangedKeyExprCall : Text
        controller party
        do pure "V1"                                          -- @V 1
        do pure "V2"                                          -- @V  2

  template ChangedKeyExprHelper
    with
      party : Party
    where
      signatory party

      choice ChangedKeyExprFetch : ChangedKeyExpr with
          cid : ContractId ChangedKeyExpr
        controller party
        do fetch cid

      choice ChangedKeyExprFetchByInterface : MyUnit with
          cid : ContractId I
        controller party
        do
          i <- fetch cid
          pure (view i)

      choice ChangedKeyExprFetchByKey : (ContractId ChangedKeyExpr, ChangedKeyExpr) with
          k : ChangedKeyExprKey
        controller party
        do fetchByKey k

      choice ChangedKeyExprExercise : Text with
          cid : ContractId ChangedKeyExpr
        controller party
        do exercise @ChangedKeyExpr cid ChangedKeyExprCall

      choice ChangedKeyExprExerciseByInterface : () with
          cid : ContractId I
        controller party
        do exercise @I cid NoOp

      choice ChangedKeyExprExerciseByKey : Text with
          k : ChangedKeyExprKey
        controller party
        do exerciseByKey @ChangedKeyExpr k ChangedKeyExprCall
-}

qckKeyChangedExprSameValue : Test
qckKeyChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a False)
  keyRes <- queryContractKey a $ V2.ChangedKeyExprKey a False
  case keyRes of
    Some (foundCid, foundContract) | show foundCid == show cid && foundContract == V2.ChangedKeyExpr a False -> pure ()
    _ -> assertFail $ "Didn't find correct contract, expected " <> show (cid, V2.ChangedKeyExpr a False) <> ", got " <> show keyRes

queryKeyChangedExprSameValue : Test
queryKeyChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a False)
  res <- queryContractId a (coerceContractId @_ @V2.ChangedKeyExpr cid)
  case res of
    Some foundContract | foundContract == V2.ChangedKeyExpr a False -> pure ()
    _ -> assertFail $ "Didn't find correct contract, expected " <> show (V2.ChangedKeyExpr a False) <> ", got " <> show res

qckKeyChangedExprChangedValue : Test
qckKeyChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a True)
  -- It is not daml-script's role to perform upgrade validation checks. It merely acts as a proxy for the ledger API
  -- that upgrades the returned value to fit the requested type.
  r <- queryContractKey @V2.ChangedKeyExpr a $ V2.ChangedKeyExprKey a False
  r === Some (coerceContractId @_ @V2.ChangedKeyExpr cid, V2.ChangedKeyExpr a True)

queryKeyChangedExprChangedValue : Test
queryKeyChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a True)
  r <- queryContractId a (coerceContractId @_ @V2.ChangedKeyExpr cid)
  -- It is not daml-script's role to perform upgrade validation checks. It merely acts as a proxy for the ledger API
  -- that upgrades the returned value to fit the requested type.
  r === Some (V2.ChangedKeyExpr a True)

fetchKeyChangedExprSameValue : Test
fetchKeyChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a False)
  foundContract <- a `submit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprFetch $ coerceContractId cid)
  foundContract === V2.ChangedKeyExpr a False

fetchKeyChangedExprChangedValue : Test
fetchKeyChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a True)
  expectMetadataChangedError @V2.ChangedKeyExpr (V2.ChangedKeyExprKey a True) [a] =<<
    a `trySubmit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprFetch $ coerceContractId cid)

fbiKeyChangedExprSameValue : Test
fbiKeyChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a False)
  foundContract <- a `submit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprFetchByInterface $ coerceContractId cid)
  foundContract === Iface.MyUnit {}

fbiKeyChangedExprChangedValue : Test
fbiKeyChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a True)
  expectMetadataChangedError @V2.ChangedKeyExpr (V2.ChangedKeyExprKey a True) [a] =<<
    a `trySubmit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprFetchByInterface $ coerceContractId cid)

fbkKeyChangedExprSameValue : Test
fbkKeyChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a False)
  (foundCid, foundContract) <- a `submit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprFetchByKey $ V2.ChangedKeyExprKey a False)
  foundContract === V2.ChangedKeyExpr a False
  show foundCid === show cid

fbkKeyChangedExprChangedValue : Test
fbkKeyChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a True)
  expectMetadataChangedError @V2.ChangedKeyExpr (V2.ChangedKeyExprKey a True) [a] =<<
    a `trySubmit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprFetchByKey $ V2.ChangedKeyExprKey a False)

exerciseKeyChangedExprSameValue : Test
exerciseKeyChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a False)
  res <- a `submit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprExercise $ coerceContractId cid)
  res === "V2"

ebiKeyChangedExprSameValue : Test
ebiKeyChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a False)
  res <- a `submit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprExerciseByInterface $ coerceContractId cid)
  res === ()

ebkKeyChangedExprSameValue : Test
ebkKeyChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  _ <- a `submit` createExactCmd (V1.ChangedKeyExpr a False)
  res <- a `submit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprExerciseByKey $ V2.ChangedKeyExprKey a False)
  res === "V2"

exerciseCmdKeyChangedExprSameValue : Test
exerciseCmdKeyChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a False)
  res <- a `submit` exerciseExactCmd @V2.ChangedKeyExpr (coerceContractId cid) V2.ChangedKeyExprCall
  res === "V2"

ebkCmdKeyChangedExprSameValue : Test
ebkCmdKeyChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  _ <- a `submit` createExactCmd (V1.ChangedKeyExpr a False)
  res <- a `submit` exerciseByKeyExactCmd @V2.ChangedKeyExpr (V2.ChangedKeyExprKey a False) V2.ChangedKeyExprCall
  res === "V2"

exerciseKeyChangedExprChangedValue : Test
exerciseKeyChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a True)
  expectMetadataChangedError @V2.ChangedKeyExpr (V2.ChangedKeyExprKey a True) [a] =<<
    a `trySubmit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprExercise $ coerceContractId cid)

ebiKeyChangedExprChangedValue : Test
ebiKeyChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a True)
  expectMetadataChangedError @V2.ChangedKeyExpr (V2.ChangedKeyExprKey a True) [a] =<<
    a `trySubmit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprExerciseByInterface $ coerceContractId cid)

ebkKeyChangedExprChangedValue : Test
ebkKeyChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  _ <- a `submit` createExactCmd (V1.ChangedKeyExpr a True)
  expectMetadataChangedError @V2.ChangedKeyExpr (V2.ChangedKeyExprKey a True) [a] =<<
    a `trySubmit` createAndExerciseCmd (V2.ChangedKeyExprHelper a) (V2.ChangedKeyExprExerciseByKey $ V2.ChangedKeyExprKey a False)

exerciseCmdKeyChangedExprChangedValue : Test
exerciseCmdKeyChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedKeyExpr a True)
  expectMetadataChangedError @V2.ChangedKeyExpr (V2.ChangedKeyExprKey a True) [a] =<<
    a `trySubmit` exerciseExactCmd @V2.ChangedKeyExpr (coerceContractId cid) V2.ChangedKeyExprCall

ebkCmdKeyChangedExprChangedValue : Test
ebkCmdKeyChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  _ <- a `submit` createExactCmd (V1.ChangedKeyExpr a True)
  expectMetadataChangedError @V2.ChangedKeyExpr (V2.ChangedKeyExprKey a True) [a] =<<
    a `trySubmit` exerciseByKeyExactCmd @V2.ChangedKeyExpr (V2.ChangedKeyExprKey a False) V2.ChangedKeyExprCall

{- MODULE
package: contract-key-upgrades
contents: |
  module ChangedMaintainersExpr where

  data ChangedMaintainersExprKey = ChangedMaintainersExprKey with
      p1 : Party
      p2 : Party
    deriving (Eq, Show)

  template ChangedMaintainersExpr
    with
      p1 : Party
      p2 : Party
    where
      signatory p1
      key (ChangedMaintainersExprKey p1 p2) : ChangedMaintainersExprKey
      maintainer key.p1                                       -- @V 1
      maintainer key.p2                                       -- @V  2

      choice ChangedMaintainersExprCall : Text
        controller p1
        do pure "V1"                                          -- @V 1
        do pure "V2"                                          -- @V  2

  template ChangedMaintainersExprHelper
    with
      party : Party
    where
      signatory party

      choice ChangedMaintainersExprFetch : ChangedMaintainersExpr with
          cid : ContractId ChangedMaintainersExpr
        controller party
        do fetch cid

      choice ChangedMaintainersExprFetchByKey : (ContractId ChangedMaintainersExpr, ChangedMaintainersExpr) with
          k : ChangedMaintainersExprKey
        controller party
        do fetchByKey k

      choice ChangedMaintainersExprExercise : Text with
          cid : ContractId ChangedMaintainersExpr
        controller party
        do exercise @ChangedMaintainersExpr cid ChangedMaintainersExprCall

      choice ChangedMaintainersExprExerciseByKey : Text with
          k : ChangedMaintainersExprKey
        controller party
        do exerciseByKey @ChangedMaintainersExpr k ChangedMaintainersExprCall
-}

qckMaintainersChangedExprSameValue : Test
qckMaintainersChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a a)
  keyRes <- queryContractKey a $ V2.ChangedMaintainersExprKey a a
  case keyRes of
    Some (foundCid, foundContract) | show foundCid == show cid && foundContract == V2.ChangedMaintainersExpr a a -> pure ()
    _ -> assertFail $ "Didn't find correct contract, expected " <> show (cid, V2.ChangedMaintainersExpr a a) <> ", got " <> show keyRes

queryMaintainersChangedExprSameValue : Test
queryMaintainersChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a a)
  res <- queryContractId a (coerceContractId @_ @V2.ChangedMaintainersExpr cid)
  case res of
    Some foundContract | foundContract == V2.ChangedMaintainersExpr a a -> pure ()
    _ -> assertFail $ "Didn't find correct contract, expected " <> show (V2.ChangedMaintainersExpr a a) <> ", got " <> show res

qckMaintainersChangedExprChangedValue : Test
qckMaintainersChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  b <- allocateParty "bob"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a b)
  r <- queryContractKey @V2.ChangedMaintainersExpr a $ V2.ChangedMaintainersExprKey a b
  r === Some (coerceContractId @_ @V2.ChangedMaintainersExpr cid, V2.ChangedMaintainersExpr a b)

queryMaintainersChangedExprChangedValue : Test
queryMaintainersChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  b <- allocateParty "bob"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a b)
  r <- queryContractId a (coerceContractId @_ @V2.ChangedMaintainersExpr cid)
  r === Some (V2.ChangedMaintainersExpr a b)

fetchMaintainersChangedExprSameValue : Test
fetchMaintainersChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a a)
  foundContract <- a `submit` createAndExerciseCmd (V2.ChangedMaintainersExprHelper a) (V2.ChangedMaintainersExprFetch $ coerceContractId cid)
  foundContract === V2.ChangedMaintainersExpr a a

fetchMaintainersChangedExprChangedValue : Test
fetchMaintainersChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  b <- allocateParty "bob"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a b)
  expectMetadataChangedError @V2.ChangedMaintainersExpr (V2.ChangedMaintainersExprKey a b) [b] =<<
    a `trySubmit` createAndExerciseCmd (V2.ChangedMaintainersExprHelper a) (V2.ChangedMaintainersExprFetch $ coerceContractId cid)

fbkMaintainersChangedExprSameValue : Test
fbkMaintainersChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a a)
  (foundCid, foundContract) <- a `submit` createAndExerciseCmd (V2.ChangedMaintainersExprHelper a) (V2.ChangedMaintainersExprFetchByKey $ V2.ChangedMaintainersExprKey a a)
  foundContract === V2.ChangedMaintainersExpr a a
  show foundCid === show cid

fbkMaintainersChangedExprChangedValue : Test
fbkMaintainersChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  b <- allocateParty "bob"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a b)
  expectMetadataChangedError @V2.ChangedMaintainersExpr (V2.ChangedMaintainersExprKey a b) [b] =<<
    a `trySubmit` createAndExerciseCmd (V2.ChangedMaintainersExprHelper a) (V2.ChangedMaintainersExprFetchByKey $ V2.ChangedMaintainersExprKey a b)

exerciseMaintainersChangedExprSameValue : Test
exerciseMaintainersChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a a)
  res <- a `submit` createAndExerciseCmd (V2.ChangedMaintainersExprHelper a) (V2.ChangedMaintainersExprExercise $ coerceContractId cid)
  res === "V2"

ebkMaintainersChangedExprSameValue : Test
ebkMaintainersChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  _ <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a a)
  res <- a `submit` createAndExerciseCmd (V2.ChangedMaintainersExprHelper a) (V2.ChangedMaintainersExprExerciseByKey $ V2.ChangedMaintainersExprKey a a)
  res === "V2"

exerciseCmdMaintainersChangedExprSameValue : Test
exerciseCmdMaintainersChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a a)
  res <- a `submit` exerciseExactCmd @V2.ChangedMaintainersExpr (coerceContractId cid) V2.ChangedMaintainersExprCall
  res === "V2"

ebkCmdMaintainersChangedExprSameValue : Test
ebkCmdMaintainersChangedExprSameValue = test $ do
  a <- allocateParty "alice"
  _ <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a a)
  res <- a `submit` exerciseByKeyExactCmd @V2.ChangedMaintainersExpr (V2.ChangedMaintainersExprKey a a) V2.ChangedMaintainersExprCall
  res === "V2"

exerciseMaintainersChangedExprChangedValue : Test
exerciseMaintainersChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  b <- allocateParty "bob"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a b)
  expectMetadataChangedError @V2.ChangedMaintainersExpr (V2.ChangedMaintainersExprKey a b) [b] =<<
    a `trySubmit` createAndExerciseCmd (V2.ChangedMaintainersExprHelper a) (V2.ChangedMaintainersExprExercise $ coerceContractId cid)

ebkMaintainersChangedExprChangedValue : Test
ebkMaintainersChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  b <- allocateParty "bob"
  _ <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a b)
  expectMetadataChangedError @V2.ChangedMaintainersExpr (V2.ChangedMaintainersExprKey a b) [b] =<<
    a `trySubmit` createAndExerciseCmd (V2.ChangedMaintainersExprHelper a) (V2.ChangedMaintainersExprExerciseByKey $ V2.ChangedMaintainersExprKey a b)

exerciseCmdMaintainersChangedExprChangedValue : Test
exerciseCmdMaintainersChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  b <- allocateParty "bob"
  cid <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a b)
  expectMetadataChangedError @V2.ChangedMaintainersExpr (V2.ChangedMaintainersExprKey a b) [b] =<<
    a `trySubmit` exerciseExactCmd @V2.ChangedMaintainersExpr (coerceContractId cid) V2.ChangedMaintainersExprCall

ebkCmdMaintainersChangedExprChangedValue : Test
ebkCmdMaintainersChangedExprChangedValue = test $ do
  a <- allocateParty "alice"
  b <- allocateParty "bob"
  _ <- a `submit` createExactCmd (V1.ChangedMaintainersExpr a b)
  expectMetadataChangedError @V2.ChangedMaintainersExpr (V2.ChangedMaintainersExprKey a b) [b] =<<
    a `trySubmit` exerciseByKeyExactCmd @V2.ChangedMaintainersExpr (V2.ChangedMaintainersExprKey a b) V2.ChangedMaintainersExprCall

{- MODULE
package: contract-key-upgrades
contents: |
  module UpgradedContractKeys where

  data UpgradedKeyKey = UpgradedKeyKey with
      p : Party
      n : Int
      m : Optional Int                                -- @V 2
    deriving (Eq, Show)

  template UpgradedKey
    with
      party : Party
      n : Int
      m : Optional Int                                -- @V 2
    where
      signatory party
      key (UpgradedKeyKey party n) : UpgradedKeyKey   -- @V 1
      key (UpgradedKeyKey party n m) : UpgradedKeyKey -- @V 2
      maintainer key.p

      choice UpgradedKeyCall : Text
        controller party
        do pure "V1"                                  -- @V 1
        do pure "V2"                                  -- @V 2

  template UpgradedKeyHelper
    with
      party : Party
    where
      signatory party
      choice UpgradedKeyFetch : (ContractId UpgradedKey, UpgradedKey) with
          k : UpgradedKeyKey
        controller party
        do fetchByKey k

      choice UpgradedKeyExercise : Text with
          k : UpgradedKeyKey
        controller party
        do exerciseByKey @UpgradedKey k UpgradedKeyCall
-}

queryKeyUpgraded : Test
queryKeyUpgraded = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.UpgradedKey a 1)
  keyRes <- queryContractKey a $ V2.UpgradedKeyKey a 1 None
  case keyRes of
    Some (foundCid, foundContract) | show foundCid == show cid && foundContract == V2.UpgradedKey a 1 None -> pure ()
    _ -> assertFail $ "Didn't find correct contract, expected " <> show (cid, V2.UpgradedKey a 1 None) <> ", got " <> show keyRes

exerciseCmdKeyUpgraded : Test
exerciseCmdKeyUpgraded = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.UpgradedKey a 1)
  res <- a `submit` exerciseByKeyExactCmd @V2.UpgradedKey (V2.UpgradedKeyKey a 1 None) V2.UpgradedKeyCall
  res === "V2"

fetchKeyUpgraded : Test
fetchKeyUpgraded = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.UpgradedKey a 1)
  (foundCid, foundContract) <- a `submit` createAndExerciseCmd (V2.UpgradedKeyHelper a) (V2.UpgradedKeyFetch $ V2.UpgradedKeyKey a 1 None)
  foundContract === V2.UpgradedKey a 1 None
  show foundCid === show cid

exerciseUpdateKeyUpgraded : Test
exerciseUpdateKeyUpgraded = test $ do
  a <- allocateParty "alice"
  _ <- a `submit` createExactCmd (V1.UpgradedKey a 1)
  res <- a `submit` createAndExerciseCmd (V2.UpgradedKeyHelper a) (V2.UpgradedKeyExercise $ V2.UpgradedKeyKey a 1 None)
  res === "V2"

{- MODULE
package: contract-key-upgrades
contents: |
  module InvalidKeyUpgrade where

  data InvalidKeyUpgradeKey = InvalidKeyUpgradeKey with
      p : Party
      n : Int                -- @V 1
      n : Bool               -- @V 2
    deriving (Eq, Show)

  template InvalidKeyUpgrade
    with
      party : Party
    where
      signatory party
      key (InvalidKeyUpgradeKey party 0) : InvalidKeyUpgradeKey     -- @V 1
      key (InvalidKeyUpgradeKey party False) : InvalidKeyUpgradeKey -- @V 2
      maintainer key.p

      choice InvalidKeyUpgradeCall : Text
        controller party
        do pure (show (key this).n)
-}

{- MODULE
package: contract-key-upgrades
contents: |
  module InvalidKeyRenaming where

  data InvalidKeyRenamingKey = InvalidKeyRenamingKey with
      p : Party
      n : Int                -- @V 1
      m : Int                -- @V 2
    deriving (Eq, Show)

  template InvalidKeyRenaming
    with
      party : Party
    where
      signatory party
      key (InvalidKeyRenamingKey party 42) : InvalidKeyRenamingKey
      maintainer key.p

      choice InvalidKeyRenamingCall : Int
        controller party
        do
          pure (key this).n  -- @V 1
          pure (key this).m  -- @V 2
-}

{- PACKAGE
name: contract-key-upgrades-client
versions: 1
depends: |
  contract-key-upgrades-1.0.0
  contract-key-upgrades-2.0.0
-}

{- MODULE
package: contract-key-upgrades-client
contents: |
  module KeyUpgradeClient where

  import V1.InvalidKeyUpgrade as V1
  import V2.InvalidKeyUpgrade as V2
  import V1.InvalidKeyRenaming as V1
  import V2.InvalidKeyRenaming as V2

  template KeyUpgradeClient
    with
      party : Party
    where
      signatory party

      -- InvalidKeyUpgrade

      choice InvalidKeyUpgradeFetch : (ContractId V2.InvalidKeyUpgrade, V2.InvalidKeyUpgrade)
        controller party
        do
          cid <- create (V1.InvalidKeyUpgrade party)
          fetchByKey (V2.InvalidKeyUpgradeKey party False)

      choice InvalidKeyUpgradeExercise : Text
        controller party
        do
          cid <- create (V1.InvalidKeyUpgrade party)
          exerciseByKey @V2.InvalidKeyUpgrade (V2.InvalidKeyUpgradeKey party False) V2.InvalidKeyUpgradeCall

      -- InvalidKeyRenaming

      choice InvalidKeyRenamingFetch : (ContractId V2.InvalidKeyRenaming, V2.InvalidKeyRenaming)
        controller party
        do
          cid <- create (V1.InvalidKeyRenaming party)
          fetchByKey (V2.InvalidKeyRenamingKey party 42)

      choice InvalidKeyRenamingExercise : Int
        controller party
        do
          cid <- create (V1.InvalidKeyRenaming party)
          exerciseByKey @V2.InvalidKeyRenaming (V2.InvalidKeyRenamingKey party 42) V2.InvalidKeyRenamingCall
-}

-- InvalidKeyUpgrade

queryInvalidKeyUpgradeGlobal : Test
queryInvalidKeyUpgradeGlobal = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.InvalidKeyUpgrade a)
  keyRes <- queryContractKey @V2.InvalidKeyUpgrade a $ V2.InvalidKeyUpgradeKey a False
  case keyRes of
    None -> pure ()
    _ -> assertFail ("Expected None (key not found), but got: " <> show keyRes)

exerciseInvalidKeyUpgradeGlobal : Test
exerciseInvalidKeyUpgradeGlobal = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.InvalidKeyUpgrade a)
  res <- a `trySubmit` exerciseByKeyExactCmd @V2.InvalidKeyUpgrade (V2.InvalidKeyUpgradeKey a False) V2.InvalidKeyUpgradeCall
  case res of
    Left (ContractKeyNotFound _) -> pure ()
    _ -> assertFail ("Expected ContractKeyNotFound, but got: " <> show res)
    
fetchInvalidKeyUpgradeLocal : Test
fetchInvalidKeyUpgradeLocal = test $ do
  a <- allocateParty "alice"
  res <- a `trySubmit` createAndExerciseCmd (Client.KeyUpgradeClient a) Client.InvalidKeyUpgradeFetch
  case res of
    Left (ContractKeyNotFound _) -> pure ()
    _ -> assertFail ("Expected ContractKeyNotFound, but got: " <> show res)

exerciseInvalidKeyUpgradeLocal : Test
exerciseInvalidKeyUpgradeLocal = test $ do
  a <- allocateParty "alice"
  res <- a `trySubmit` createAndExerciseCmd (Client.KeyUpgradeClient a) Client.InvalidKeyUpgradeExercise
  case res of
    Left (ContractKeyNotFound _) -> pure ()
    _ -> assertFail ("Expected ContractKeyNotFound, but got: " <> show res)

-- InvalidKeyRenaming

queryInvalidKeyRenamingGlobal : Test
queryInvalidKeyRenamingGlobal = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.InvalidKeyRenaming a)
  keyRes <- queryContractKey @V2.InvalidKeyRenaming a $ V2.InvalidKeyRenamingKey a 42
  case keyRes of
    None -> pure ()
    _ -> assertFail ("Expected None (key not found), but got: " <> show keyRes)

exerciseInvalidKeyRenamingGlobal : Test
exerciseInvalidKeyRenamingGlobal = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.InvalidKeyRenaming a)
  res <- a `trySubmit` exerciseByKeyExactCmd @V2.InvalidKeyRenaming (V2.InvalidKeyRenamingKey a 42) V2.InvalidKeyRenamingCall
  case res of
    Left (ContractKeyNotFound _) -> pure ()
    _ -> assertFail ("Expected ContractKeyNotFound, but got: " <> show res)

fetchInvalidKeyRenamingLocal : Test
fetchInvalidKeyRenamingLocal = test $ do
  a <- allocateParty "alice"
  res <- a `trySubmit` createAndExerciseCmd (Client.KeyUpgradeClient a) Client.InvalidKeyRenamingFetch
  case res of
    Left (ContractKeyNotFound _) -> pure ()
    _ -> assertFail ("Expected ContractKeyNotFound, but got: " <> show res)

exerciseInvalidKeyRenamingLocal : Test
exerciseInvalidKeyRenamingLocal = test $ do
  a <- allocateParty "alice"
  res <- a `trySubmit` createAndExerciseCmd (Client.KeyUpgradeClient a) Client.InvalidKeyRenamingExercise
  case res of
    Left (ContractKeyNotFound _) -> pure ()
    _ -> assertFail ("Expected ContractKeyNotFound, but got: " <> show res)

{- MODULE
package: contract-key-upgrades
contents: |
  module ContractKeyPresence where

  data ContractKeyPresenceKey = ContractKeyPresenceKey with
      p : Party
    deriving (Eq, Show)

  template ContractKeyPresenceTemplate
    with
      party : Party
    where
      signatory party
      key (ContractKeyPresenceKey party) : ContractKeyPresenceKey -- @V 1
      maintainer key.p -- @V 1

      choice DummyChoice : ()
        controller party
        do pure ()
-}

fetchTemplateWithUnexpectedKey : Test
fetchTemplateWithUnexpectedKey = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V1.ContractKeyPresenceTemplate a)
  let v2cid = coerceContractId @_ @V2.ContractKeyPresenceTemplate cid
  res <- a `trySubmit` exerciseCmd @V2.ContractKeyPresenceTemplate v2cid V2.DummyChoice
  case res of
    -- We expect the original key to be present and the recomputed key to be absent.
    Left (UpgradeError (ValidationFailed _ _ _ _ _ _ _ (Some _) _ _ None) _) -> pure ()
    other -> assertFail ("Expected failure with missing absent key and present recomputed key, but got: " <> show other)

fetchTemplateWithUnexpectedlyMissingKey : Test
fetchTemplateWithUnexpectedlyMissingKey = test $ do
  a <- allocateParty "alice"
  cid <- a `submit` createExactCmd (V2.ContractKeyPresenceTemplate a)
  let v1cid = coerceContractId @_ @V1.ContractKeyPresenceTemplate cid
  res <- a `trySubmit` exerciseExactCmd @V1.ContractKeyPresenceTemplate v1cid V1.DummyChoice
  case res of
    -- We expect the original key to be absent and the recomputed key to be present.
    Left (UpgradeError (ValidationFailed _ _ _ _ _ _ _ None _ _ (Some _)) _) -> pure ()
    other -> assertFail ("Expected failure with present original key and absent recomputed key, but got: " <> show other)

------------------------------------------------------------------------------------------------------------------------

expectMetadataChangedError : forall t k a. (HasTemplateTypeRep t, HasFromAnyContractKey t k, Eq k) => k -> [Party] -> Either SubmitError a -> Script ()
expectMetadataChangedError key maintainers r = case r of
    Right _ -> assertFail "Expected failure but got success"
    Left (UpgradeError (ValidationFailed _ _ _ _ _ _ _ _ _ _ (Some (foundKey, foundMaintainers))) msg)
      | fromAnyContractKey @t foundKey == Some key &&
        sort maintainers == sort foundMaintainers
      -> pure ()
    Left e -> assertFail $ "Expected Upgrade error but got " <> show e

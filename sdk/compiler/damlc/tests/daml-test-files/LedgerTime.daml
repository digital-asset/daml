-- Copyright (c) 2020, Digital Asset (Switzerland) GmbH and/or its affiliates.
-- All rights reserved.

module LedgerTime where

import DA.Assert ((===), assertDeadlineExceeded, assertWithinDeadline)
import DA.Text (isInfixOf)
import DA.Time
import Daml.Script

template LabeledContract with
    party : Party
    label : Text
  where
    signatory party

    nonconsuming choice CheckLT : Bool
      with
        dueBy: Time
      controller party
      do
        isLedgerTimeLT dueBy

    nonconsuming choice CheckLE : Bool
      with
        dueBy: Time
      controller party
      do
        isLedgerTimeLE dueBy

    nonconsuming choice CheckGT : Bool
      with
        dueBy: Time
      controller party
      do
        isLedgerTimeGT dueBy

    nonconsuming choice CheckGE : Bool
      with
        dueBy: Time
      controller party
      do
        isLedgerTimeGE dueBy

    nonconsuming choice CheckWithinDeadline : ()
      with
        deadline: Time
      controller party
      do
        assertWithinDeadline "within-deadline" deadline
        pure ()

    nonconsuming choice CheckDeadlineExceeded : ()
      with
        deadline: Time
      controller party
      do
        assertDeadlineExceeded "deadline-exceeded" deadline
        pure ()

main =
  script do
    alice <- allocateParty "alice"
    cid <- submit alice $ createCmd (LabeledContract alice "test-action")
    timePrev <- getTime
    let
      timeNow = addRelTime timePrev (microseconds 1)
      timeNext = addRelTime timePrev (microseconds 2)
      timeMin = minBound @Time
      timeMax = maxBound @Time

    -- isLedgerTimeLT
    setTime timeNow
    (lt0, TransactionTree _ (Some (TimeRange lt0LB lt0UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckLT timeNext)
    lt0 === True
    lt0LB === timeMin
    lt0UB === timeNow
    setTime timeNow
    (lt1, TransactionTree _ (Some (TimeRange lt1LB lt1UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckLT timeNow)
    lt1 === False
    lt1LB === timeNow
    lt1UB === timeMax
    setTime timeNow
    (lt2, TransactionTree _ (Some (TimeRange lt2LB lt2UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckLT timePrev)
    lt2 === False
    lt2LB === timePrev
    lt2UB === timeMax
    setTime timeNow
    (lt3, TransactionTree _ (Some (TimeRange lt3LB lt3UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckLT timeMin)
    lt3 === False
    lt3LB === timeMin
    lt3UB === timeMax
    setTime timeNow
    (lt4, TransactionTree _ (Some (TimeRange lt4LB lt4UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckLT timeMax)
    lt4 === True
    lt4LB === timeMin
    subTime timeMax lt4UB === microseconds 1

    -- isLedgerTimeLE
    setTime timeNow
    (le0, TransactionTree _ (Some (TimeRange le0LB le0UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckLE timeNext)
    le0 === True
    le0LB === timeMin
    le0UB === timeNext
    setTime timeNow
    (le1, TransactionTree _ (Some (TimeRange le1LB le1UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckLE timeNow)
    le1 === True
    le1LB === timeMin
    le1UB === timeNow
    setTime timeNow
    (le2, TransactionTree _ (Some (TimeRange le2LB le2UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckLE timePrev)
    le2 === False
    le2LB === timeNow
    le2UB === timeMax
    setTime timeNow
    (le3, TransactionTree _ (Some (TimeRange le3LB le3UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckLE timeMin)
    le3 === False
    subTime le3LB timeMin === microseconds 1
    le3UB === timeMax
    setTime timeNow
    resultLE0 <- trySubmit alice $ exerciseCmd cid (CheckLE timeMax)
    case resultLE0 of
      Left (FailureStatusError fsError) | "GeneralError" `isInfixOf` fsError.errorId ->
        fsError.message === "Can not compare against the maximum time bound"
      Left e ->
        error $ "failureStatusError incorrect error: " <> show e
      Right _ ->
        error "failureStatusError incorrectly succeeded"

    -- isLedgerTimeGT
    setTime timeNow
    (gt0, TransactionTree _ (Some (TimeRange gt0LB gt0UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckGT timeNext)
    gt0 === False
    gt0LB === timeMin
    gt0UB === timeNext
    setTime timeNow
    (gt1, TransactionTree _ (Some (TimeRange gt1LB gt1UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckGT timeNow)
    gt1 === False
    gt1LB === timeMin
    gt1UB === timeNow
    setTime timeNow
    (gt2, TransactionTree _ (Some (TimeRange gt2LB gt2UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckGT timePrev)
    gt2 === True
    gt2LB === timeNow
    gt2UB === timeMax
    setTime timeNow
    (gt3, TransactionTree _ (Some (TimeRange gt3LB gt3UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckGT timeMin)
    gt3 === True
    subTime gt3LB timeMin === microseconds 1
    gt3UB === timeMax
    setTime timeNow
    resultGT0 <- trySubmit alice $ exerciseCmd cid (CheckGT timeMax)
    case resultGT0 of
      Left (FailureStatusError fsError) | "GeneralError" `isInfixOf` fsError.errorId ->
        fsError.message === "Can not compare against the maximum time bound"
      Left e ->
        error $ "failureStatusError incorrect error: " <> show e
      Right _ ->
        error "failureStatusError incorrectly succeeded"

    -- isLedgerTimeGE
    setTime timeNow
    (ge0, TransactionTree _ (Some (TimeRange ge0LB ge0UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckGE timeNext)
    ge0 === False
    ge0LB === timeMin
    ge0UB === timeNow
    setTime timeNow
    (ge1, TransactionTree _ (Some (TimeRange ge1LB ge1UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckGE timeNow)
    ge1 === True
    ge1LB === timeNow
    ge1UB === timeMax
    setTime timeNow
    (ge2, TransactionTree _ (Some (TimeRange ge2LB ge2UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckGE timePrev)
    ge2 === True
    ge2LB === timePrev
    ge2UB === timeMax
    setTime timeNow
    (ge3, TransactionTree _ (Some (TimeRange ge3LB ge3UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckGE timeMin)
    ge3 === True
    ge3LB === timeMin
    ge3UB === timeMax
    setTime timeNow
    (ge4, TransactionTree _ (Some (TimeRange ge4LB ge4UB))) <- submitResultAndTree alice $ exerciseCmd cid (CheckGE timeMax)
    ge4 === False
    ge4LB === timeMin
    subTime timeMax ge4UB === microseconds 1

    -- assertWithinDeadline
    setTime timeNow
    _ <- submit alice $ exerciseCmd cid (CheckWithinDeadline timeNext)
    setTime timeNow
    resultWD0 <- trySubmit alice $ exerciseCmd cid (CheckWithinDeadline timeNow)
    case resultWD0 of
      Left (FailureStatusError fsError) | fsError.errorId == "stdlib.daml.com/deadline-exceeded" ->
        fsError.message === ("Ledger time is at or past deadline 'within-deadline' at " <> show timeNow)
      Left e ->
        error $ "failureStatusError incorrect error: " <> show e
      Right _ ->
        error "failureStatusError incorrectly succeeded"
    setTime timeNow
    resultWD1 <- trySubmit alice $ exerciseCmd cid (CheckWithinDeadline timePrev)
    case resultWD1 of
      Left (FailureStatusError fsError) | fsError.errorId == "stdlib.daml.com/deadline-exceeded" ->
        fsError.message === ("Ledger time is at or past deadline 'within-deadline' at " <> show timePrev)
      Left e ->
        error $ "failureStatusError incorrect error: " <> show e
      Right _ ->
        error "failureStatusError incorrectly succeeded"
    setTime timeNow
    resultWD2 <- trySubmit alice $ exerciseCmd cid (CheckWithinDeadline timeMin)
    case resultWD2 of
      Left (FailureStatusError fsError) | fsError.errorId == "stdlib.daml.com/deadline-exceeded" ->
        fsError.message === ("Ledger time is at or past deadline 'within-deadline' at " <> show timeMin)
      Left e ->
        error $ "failureStatusError incorrect error: " <> show e
      Right _ ->
        error "failureStatusError incorrectly succeeded"
    setTime timeNow
    _ <- submit alice $ exerciseCmd cid (CheckWithinDeadline timeMax)

    -- assertDeadlineExceeded
    setTime timeNow
    resultDE0 <- trySubmit alice $ exerciseCmd cid (CheckDeadlineExceeded timeNext)
    case resultDE0 of
      Left (FailureStatusError fsError) | fsError.errorId == "stdlib.daml.com/deadline-not-exceeded" ->
        fsError.message === ("Ledger time is strictly before deadline 'deadline-exceeded' at " <> show timeNext)
      Left e ->
        error $ "failureStatusError incorrect error: " <> show e
      Right _ ->
        error "failureStatusError incorrectly succeeded"
    setTime timeNow
    _ <- submit alice $ exerciseCmd cid (CheckDeadlineExceeded timeNow)
    setTime timeNow
    _ <- submit alice $ exerciseCmd cid (CheckDeadlineExceeded timePrev)
    setTime timeNow
    _ <- submit alice $ exerciseCmd cid (CheckDeadlineExceeded timeMin)
    setTime timeNow
    resultDE1 <- trySubmit alice $ exerciseCmd cid (CheckDeadlineExceeded timeMax)
    case resultDE1 of
      Left (FailureStatusError fsError) | fsError.errorId == "stdlib.daml.com/deadline-not-exceeded" ->
        fsError.message === ("Ledger time is strictly before deadline 'deadline-exceeded' at " <> show timeMax)
      Left e ->
        error $ "failureStatusError incorrect error: " <> show e
      Right _ ->
        error "failureStatusError incorrectly succeeded"

    pure ()

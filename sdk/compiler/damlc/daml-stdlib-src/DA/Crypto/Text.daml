-- Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- @SUPPORTS-LF-FEATURE DAML_CCTP

{-# LANGUAGE CPP #-}

-- | Functions for working with Crypto builtins.
-- For example, as used to implement CCTP functionality.
module DA.Crypto.Text
  (keccak256
  , secp256k1
  , HasToHex(..)
  , HasFromHex(..)
  , numericViaStringToHex
  , numericViaStringFromHex
  , BytesHex
  , PublicKeyHex
  , SignatureHex
  , byteCount
  , isBytes32Hex
  , minBytes32Hex
  , maxBytes32Hex
  , isUInt32Hex
  , minUInt32Hex
  , maxUInt32Hex
  , isUInt64Hex
  , minUInt64Hex
  , maxUInt64Hex
  , isUInt256Hex
  , minUInt256Hex
  , maxUInt256Hex
  , packHexBytes
  , sliceHexBytes
  ) where

import DA.Text qualified as Text
import GHC.Types (primitive)

-- TODO: https://github.com/DACH-NY/canton-network-utilities/issues/2943: Introduce ByteString opaque data types

type BytesHex = Text

-- | A DER formatted public key to be used for ECDSA signature verification
type PublicKeyHex = Text

-- | A DER formatted SECP256K1 signature
type SignatureHex = Text

hexByteToInt : Text -> Int
hexByteToInt "0" = 0
hexByteToInt "1" = 1
hexByteToInt "2" = 2
hexByteToInt "3" = 3
hexByteToInt "4" = 4
hexByteToInt "5" = 5
hexByteToInt "6" = 6
hexByteToInt "7" = 7
hexByteToInt "8" = 8
hexByteToInt "9" = 9
hexByteToInt "a" = 10
hexByteToInt "b" = 11
hexByteToInt "c" = 12
hexByteToInt "d" = 13
hexByteToInt "e" = 14
hexByteToInt "f" = 15
hexByteToInt "A" = 10
hexByteToInt "B" = 11
hexByteToInt "C" = 12
hexByteToInt "D" = 13
hexByteToInt "E" = 14
hexByteToInt "F" = 15
hexByteToInt hexChars | Text.length hexChars == 2 && Text.isHex hexChars = (hexByteToInt (Text.substring 1 1 hexChars)) + 16 * (hexByteToInt (Text.substring 0 1 hexChars))
hexByteToInt hexChars | not (Text.isHex hexChars) = error $ "Argument is not a hex string: " <> hexChars
hexByteToInt hexChars = error $ "Hex string should have length <= 2: " <> hexChars

-- TODO: https://github.com/DACH-NY/canton-network-utilities/issues/2922: fully parse DER hex encoded formats
isDEREncoded : Text -> Bool
isDEREncoded msg = Text.isHex msg && Text.substring 0 2 msg == "30" && Text.length msg == 2 * (2 + (hexByteToInt (Text.substring 2 2 msg)))

-- | Computes the KECCAK256 hash of the UTF8 bytes of the `Text`, and returns it in its hex-encoded
-- form. The hex encoding uses lowercase letters.
keccak256 : BytesHex -> BytesHex
keccak256 msg | Text.isHex msg = primitive @"BEKecCak256Text" (Text.asciiToLower msg)
keccak256 msg = error $ "Message argument is not a hex string: " <> msg

-- | Validate the SECP256K1 signature given a hex encoded message and a hex encoded DER formatted public key.
secp256k1 : SignatureHex -> BytesHex -> PublicKeyHex -> Bool
secp256k1 sig msg pk | isDEREncoded sig && Text.isHex msg && isDEREncoded pk = primitive @"BESecp256k1Bool" (Text.asciiToLower sig) (Text.asciiToLower msg) (Text.asciiToLower pk)
secp256k1 sig _ _ | not (isDEREncoded sig) = error $ "Signature argument is not a DER encoded hex string: " <> sig
secp256k1 _ msg _ | not (Text.isHex msg) = error $ "Message argument is not a hex string: " <> msg
secp256k1 _ _ pk = error $ "Public key argument is not a DER encoded hex string: " <> pk

class HasToHex a where
  -- | Converts a typed data value into a hex encoded string.
  toHex: a -> BytesHex

instance HasToHex Text where
  toHex = primitive @"BEEncodeHex"

uint16ToHexByte: Int -> BytesHex
uint16ToHexByte n | 0 <= n && n <= 9 = show n
uint16ToHexByte 10 = "a"
uint16ToHexByte 11 = "b"
uint16ToHexByte 12 = "c"
uint16ToHexByte 13 = "d"
uint16ToHexByte 14 = "e"
uint16ToHexByte 15 = "f"
uint16ToHexByte n = error $ "UInt16 should be in range [0, 16): " <> show n

uint256ToHexByte: Int -> BytesHex
uint256ToHexByte n | 0 <= n && n < 256 = (uint16ToHexByte(n / 16)) <> (uint16ToHexByte(n % 16))
uint256ToHexByte n = error $ "UInt256 should be in range [0, 256): " <> show n

uintToHexByteList: Int -> [BytesHex]
uintToHexByteList n | n < 0 = error $ "UInt should be positive: " <> show n
uintToHexByteList n | 0 <= n && n < 256 = [uint256ToHexByte n]
uintToHexByteList n = uint256ToHexByte(n % 256) :: uintToHexByteList(n / 256)

instance HasToHex Int where
  toHex n = Text.implode(reverse(uintToHexByteList n))

instance HasToHex Party where
  toHex p = toHex(partyToText p)

-- Numerics can be thought of as a decimal string with a scale. As usage sites need to know the scale, we can
-- simply hex encode the string representation of the underlying numeric's decimal string. This allows `parseNumeric`
-- to be used to define `HasFromHex` instances.
numericViaStringToHex : NumericScale n => Numeric n -> BytesHex
numericViaStringToHex num = toHex(show num)

class HasFromHex a where
  -- | Converts a hex encoded string into a typed data value.
  fromHex: BytesHex -> a

instance HasFromHex (Optional Text) where
  fromHex hex | Text.isHex hex = Some(primitive @"BEDecodeHex" (Text.asciiToLower hex))
  fromHex _ = None

instance HasFromHex (Optional Int) where
  fromHex "" = Some 0
  fromHex hex | Text.isHex hex && Text.length hex == 2 = Some(hexByteToInt hex)
  fromHex hex | Text.isHex hex = do
    right <- fromHex(Text.substring ((Text.length hex) - 2) 2 hex)
    left <- fromHex(Text.substring 0 ((Text.length hex) - 2) hex)
    Some(left * 256 + right)
  fromHex _ = None

instance HasFromHex (Optional Party) where
  fromHex hex | Text.isHex hex = do
    txt <- fromHex hex
    partyFromText txt
  fromHex _ = None

-- Numerics can be thought of as a decimal string with a scale. As usage sites need to know the scale, we can
-- simply hex encode the string representation of the underlying numeric's decimal string. This allows `parseNumeric`
-- to be used to define `HasFromHex` instances.
numericViaStringFromHex: NumericScale n => BytesHex -> Optional (Numeric n)
numericViaStringFromHex hex | Text.isHex hex = do
  txt <- fromHex hex
  Text.parseNumeric txt
numericViaStringFromHex _ = None

-- | Number of bytes present in a byte encoded string.
byteCount: BytesHex -> Int
byteCount "" = 0
byteCount hex | Text.isHex hex = (Text.length hex) / 2
byteCount arg = error $ "Expected a hex encoded string but argument was: " <> arg

constList: Int -> a -> [a]
constList 0 _ = []
constList n x = x :: (constList (n - 1) x)

byteRepeat: Int -> BytesHex -> BytesHex
byteRepeat len byte | Text.isHex byte && byteCount byte == 1 && len >= 0 = Text.implode(constList len byte)
byteRepeat _ arg | not (Text.isHex arg) = error $ "Expected a hex encoded string but argument was: " <> arg
byteRepeat _ hex | Text.isHex hex && byteCount hex /= 1 = error $ "Expected a byte value but hex encoded string was: " <> hex
byteRepeat len _ = error $ "Expected a positive length but argument was: " <> show len

-- | Minimum Bytes32 hex value
minBytes32Hex: BytesHex
minBytes32Hex = byteRepeat 32 "00"
-- | Maximum Bytes32 hex value
maxBytes32Hex: BytesHex
maxBytes32Hex = byteRepeat 32 "ff"

-- | Validate that the byte encoded string is Bytes32Hex
isBytes32Hex: BytesHex -> Bool
isBytes32Hex hex | Text.isHex hex = byteCount hex == 32
isBytes32Hex arg = error $ "Expected a hex encoded string but argument was: " <> arg

-- | Minimum UInt32 hex value
minUInt32Hex: BytesHex
minUInt32Hex = byteRepeat 5 "00"
-- | Maximum UInt32 hex value
maxUInt32Hex: BytesHex
maxUInt32Hex = byteRepeat 5 "ff"

-- | Validate that the byte encoded string is UInt32Hex
isUInt32Hex: BytesHex -> Bool
isUInt32Hex hex | Text.isHex hex = byteCount hex == 5
isUInt32Hex arg = error $ "Expected a hex encoded string but argument was: " <> arg

-- | Minimum UInt64 hex value
minUInt64Hex: BytesHex
minUInt64Hex = byteRepeat 6 "00"
-- | Maximum UInt64 hex value
maxUInt64Hex: BytesHex
maxUInt64Hex = byteRepeat 6 "ff"

-- | Validate that the byte encoded string is UInt64Hex
isUInt64Hex: BytesHex -> Bool
isUInt64Hex hex | Text.isHex hex = byteCount hex == 6
isUInt64Hex arg = error $ "Expected a hex encoded string but argument was: " <> arg

-- | Minimum UInt256 hex value
minUInt256Hex: BytesHex
minUInt256Hex = byteRepeat 8 "00"
-- | Maximum UInt256 hex value
maxUInt256Hex: BytesHex
maxUInt256Hex = byteRepeat 8 "ff"

-- | Validate that the byte encoded string is UInt256Hex
isUInt256Hex: BytesHex -> Bool
isUInt256Hex hex | Text.isHex hex = byteCount hex == 8
isUInt256Hex arg = error $ "Expected a hex encoded string but argument was: " <> arg

-- | Pack a byte encoded string to a given byte count size. If the byte string is shorter than the pad
-- size, then prefix with 00 byte strings. If the byte string is larger, then truncate the byte string.
packHexBytes: BytesHex -> Int -> Optional BytesHex
packHexBytes hex pad | Text.isHex hex && 0 <= pad && byteCount hex <= pad = Some((byteRepeat (pad - byteCount hex) "00") <> hex)
packHexBytes hex pad | Text.isHex hex && 0 <= pad = Some(Text.drop ((pad - byteCount hex) * 2) hex)
packHexBytes _ _ = None

-- | Extract the byte string starting at startByte up to, but excluding, endByte. Byte indexing starts at 1.
sliceHexBytes: BytesHex -> Int -> Int -> Either Text BytesHex
sliceHexBytes hex startByte endByte | Text.isHex hex && 1 <= startByte && startByte <= endByte && endByte <= (byteCount hex) + 1 = Right(Text.substring ((startByte - 1) * 2) ((endByte - startByte) * 2) hex)
sliceHexBytes hex startByte _ | Text.isHex hex && startByte < 1 =  Left("Expected start byte to be >= 1, was: " <> show startByte)
sliceHexBytes hex startByte endByte | Text.isHex hex && 1 <= startByte =  Left("Expected end byte to be >= " <> show(startByte) <> " and <= " <> show((byteCount hex) + 1) <> " was: " <> show(endByte))
sliceHexBytes arg _ _ =  Left("Expected a hex encoded string but argument was: " <> arg)

-- Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- @SUPPORTS-LF-FEATURE DAML_CCTP

{-# LANGUAGE CPP #-}

-- | Functions for working with Crypto builtins.
-- For example, as used to implement CCTP functionality.
module DA.Crypto.Text
  (keccak256
  , secp256k1
  , HasToHex(..)
  , HasFromHex(..)
  , BytesHex
  , PublicKeyHex
  , SignatureHex
  , byteCount
  , isBytes32Hex
  , isUInt32Hex
  , isUInt64Hex
  , isUInt256Hex
  , packHexBytes
  , sliceHexBytes
  ) where

import DA.Text qualified as Text
import GHC.Types (primitive)

-- TODO: https://github.com/DACH-NY/canton-network-utilities/issues/2943: Introduce ByteString opaque data types

type BytesHex = Text

-- | A DER formatted public key to be used for ECDSA signature verification
type PublicKeyHex = Text

-- | A DER formatted SECP256K1 signature
type SignatureHex = Text

-- | HIDE
hexByteToInt : Text -> Int
hexByteToInt "0" = 0
hexByteToInt "1" = 1
hexByteToInt "2" = 2
hexByteToInt "3" = 3
hexByteToInt "4" = 4
hexByteToInt "5" = 5
hexByteToInt "6" = 6
hexByteToInt "7" = 7
hexByteToInt "8" = 8
hexByteToInt "9" = 9
hexByteToInt "a" = 10
hexByteToInt "b" = 11
hexByteToInt "c" = 12
hexByteToInt "d" = 13
hexByteToInt "e" = 14
hexByteToInt "f" = 15
hexByteToInt "A" = 10
hexByteToInt "B" = 11
hexByteToInt "C" = 12
hexByteToInt "D" = 13
hexByteToInt "E" = 14
hexByteToInt "F" = 15
hexByteToInt hexChars | Text.length hexChars == 2 && Text.isHex hexChars = (hexByteToInt (Text.substring 1 1 hexChars)) + 16 * (hexByteToInt (Text.substring 0 1 hexChars))
hexByteToInt hexChars | not (Text.isHex hexChars) = error $ "Argument is not a hex string: " <> hexChars
hexByteToInt hexChars = error $ "Hex string should have length <= 2: " <> hexChars

-- TODO: https://github.com/DACH-NY/canton-network-utilities/issues/2922: fully parse DER hex encoded formats
isDEREncoded : Text -> Bool
isDEREncoded msg = Text.isHex msg && Text.substring 0 2 msg == "30" && Text.length msg == 2 * (2 + (hexByteToInt (Text.substring 2 2 msg)))

-- | Computes the KECCAK256 hash of the UTF8 bytes of the `Text`, and returns it in its hex-encoded
-- form. The hex encoding uses lowercase letters.
keccak256 : BytesHex -> BytesHex
keccak256 msg | Text.isHex msg = primitive @"BEKecCak256Text" (Text.asciiToLower msg)
keccak256 msg = error $ "Message argument is not a hex string: " <> msg

-- | Validate the SECP256K1 signature given a hex encoded message and a hex encoded DER formatted public key.
secp256k1 : SignatureHex -> BytesHex -> PublicKeyHex -> Bool
secp256k1 sig msg pk | isDEREncoded sig && Text.isHex msg && isDEREncoded pk = primitive @"BESecp256k1Bool" (Text.asciiToLower sig) (Text.asciiToLower msg) (Text.asciiToLower pk)
secp256k1 sig _ _ | not (isDEREncoded sig) = error $ "Signature argument is not a DER encoded hex string: " <> sig
secp256k1 _ msg _ | not (Text.isHex msg) = error $ "Message argument is not a hex string: " <> msg
secp256k1 _ _ pk = error $ "Public key argument is not a DER encoded hex string: " <> pk

class HasToHex a where
  -- | Converts a typed data value into a hex encoded string.
  toHex: a -> BytesHex

instance HasToHex Text where
  toHex = primitive @"BEEncodeHex"

instance HasToHex Int64 where
  toHex n = ???

instance HasToHex (Numeric n) where
  toHex num = ???

instance HasToHex Party where
  toHex p = toHex(partyToText p)

instance HasToHex (ContractId a) where
  toHex cid = ???

class HasFromHex a where
  -- | Converts a hex encoded string into a typed data value.
  fromHex: BytesHex -> a

instance HasFromHex (Optional Text) where
  fromHex "" = ""
  fromHex hex | Text.isHex hex = Some(primitive @"BEDecodeHex" (Text.asciiToLower hex))
  fromHex _ = None

instance HasFromHex (Optional Int64) where
  fromHex hex | Text.isHex hex = Some(???)
  fromHex _ = None

instance HasFromHex (Optional(Numeric n)) where
  fromHex hex | Text.isHex hex = Some(???)
  fromHex _ = None

instance HasFromHex (Optional Party) where
  fromHex hex | Text.isHex hex = (fromHex hex) map partyFromText
  fromHex _ = None

instance HasFromHex (Optional(ContractId a)) where
  fromHex hex | Text.isHex hex = ???
  fromHex _ = None

-- | Number of bytes present in a byte encoded string.
byteCount: BytesHex -> Optional Int64
byteCount hex | Text.isHex hex = Some((Text.length hex) / 2)
byteCount _ = None

-- | Validate that the byte encoded string is Bytes32Hex
isBytes32Hex: BytesHex -> Optional Bool
isBytes32Hex hex | Text.isHex hex = byteCount hex == Some(32)
isBytes32Hex _ = None

-- | Validate that the byte encoded string is UInt32Hex
isUInt32Hex: BytesHex -> Optional Bool
isUInt32Hex hex | Text.isHex hex = byteCount hex == Some(5)
isUInt32Hex _ = None

-- | Validate that the byte encoded string is UInt64Hex
isUInt64Hex: BytesHex -> Optional Bool
isUInt64Hex hex | Text.isHex hex = byteCount hex == Some(6)
isUInt64Hex _ = None

-- | Validate that the byte encoded string is UInt256Hex
isUInt256Hex: BytesHex -> Optional Bool
isUInt256Hex hex | Text.isHex hex = byteCount hex == Some(8)
isUInt256Hex _ = None

-- | Pack a byte encoded string to a given byte count size. If the byte string is shorter than the pad
-- size, then prefix with 00 byte strings. If the byte string is larger, then truncate the byte string.
packHexBytes: BytesHex -> Int64 -> Optional BytesHex
packHexBytes hex pad | Text.isHex hex && 0 <= pad && byteCount hex <= pad = Some(??? <> hex)
packHexBytes hex pad | Text.isHex hex && 0 <= pad = Some(Text.drop ((pad - byteCount hex) * 2) hex)
packHexBytes _ _ = None

-- | Extract the byte string starting at startByte up to, but excluding, endByte. Byte indexing starts at 1.
sliceHexBytes: BytesHex -> Int64 -> Int64 -> Optional BytesHex
sliceHexBytes hex startByte endByte | Text.isHex hex && 1 <= startByte && startByte <= endByte && endByte <= (byteCount hex) + 1 = Some(Text.substring (startByte * 2) ((endByte - startByte) * 2) hex)
sliceHexBytes _ _ _ = None

-- | Validate that the byte encoded hex string is a valid Ethereum address.
-- Only hex string formats (and not ICAP address formats) are supported.
isEthereumAddress: BytesHex -> Optional Bool
isEthereumAddress hex | Text.isHex hex && byteCount hex == 20 && Text.take 1 hex != "0" && Text.take 1 (Text.reverse hex) != "0" && getEthereumChecksumAddress hex == Some(hex) = Some(true)
isEthereumAddress hex | Text.isHex hex = Some(false)
isEthereumAddress _ = None

-- | HIDE
getEthereumChecksumAddress: BytesHex -> Optional BytesHex
getEthereumChecksumAddress hex | Text.isHex hex = Some(???)
getEthereumChecksumAddress _ = None

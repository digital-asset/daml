-- Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- @SUPPORTS-LF-FEATURE DAML_CCTP

{-# LANGUAGE CPP #-}

-- | Functions for working with Crypto builtins.
-- For example, as used to implement CCTP functionality.
module DA.Crypto.Text
  (keccak256
  , secp256k1
  , HasToHex(..)
  , HasFromHex(..)
  , BytesHex
  , PublicKeyHex
  , SignatureHex
  , byteCount
  , isBytes32Hex
  , isUInt32Hex
  , isUInt64Hex
  , isUInt256Hex
  , packHexBytes
  , sliceHexBytes
  ) where

import DA.Optional (fromSome)
import DA.Text qualified as Text
import GHC.Types (primitive)

-- TODO: https://github.com/DACH-NY/canton-network-utilities/issues/2943: Introduce ByteString opaque data types

type BytesHex = Text

-- | A DER formatted public key to be used for ECDSA signature verification
type PublicKeyHex = Text

-- | A DER formatted SECP256K1 signature
type SignatureHex = Text

-- | HIDE
hexByteToInt : Text -> Int
hexByteToInt "0" = 0
hexByteToInt "1" = 1
hexByteToInt "2" = 2
hexByteToInt "3" = 3
hexByteToInt "4" = 4
hexByteToInt "5" = 5
hexByteToInt "6" = 6
hexByteToInt "7" = 7
hexByteToInt "8" = 8
hexByteToInt "9" = 9
hexByteToInt "a" = 10
hexByteToInt "b" = 11
hexByteToInt "c" = 12
hexByteToInt "d" = 13
hexByteToInt "e" = 14
hexByteToInt "f" = 15
hexByteToInt "A" = 10
hexByteToInt "B" = 11
hexByteToInt "C" = 12
hexByteToInt "D" = 13
hexByteToInt "E" = 14
hexByteToInt "F" = 15
hexByteToInt hexChars | Text.length hexChars == 2 && Text.isHex hexChars = (hexByteToInt (Text.substring 1 1 hexChars)) + 16 * (hexByteToInt (Text.substring 0 1 hexChars))
hexByteToInt hexChars | not (Text.isHex hexChars) = error $ "Argument is not a hex string: " <> hexChars
hexByteToInt hexChars = error $ "Hex string should have length <= 2: " <> hexChars

-- TODO: https://github.com/DACH-NY/canton-network-utilities/issues/2922: fully parse DER hex encoded formats
isDEREncoded : Text -> Bool
isDEREncoded msg = Text.isHex msg && Text.substring 0 2 msg == "30" && Text.length msg == 2 * (2 + (hexByteToInt (Text.substring 2 2 msg)))

-- | Computes the KECCAK256 hash of the UTF8 bytes of the `Text`, and returns it in its hex-encoded
-- form. The hex encoding uses lowercase letters.
keccak256 : BytesHex -> BytesHex
keccak256 msg | Text.isHex msg = primitive @"BEKecCak256Text" (Text.asciiToLower msg)
keccak256 msg = error $ "Message argument is not a hex string: " <> msg

-- | Validate the SECP256K1 signature given a hex encoded message and a hex encoded DER formatted public key.
secp256k1 : SignatureHex -> BytesHex -> PublicKeyHex -> Bool
secp256k1 sig msg pk | isDEREncoded sig && Text.isHex msg && isDEREncoded pk = primitive @"BESecp256k1Bool" (Text.asciiToLower sig) (Text.asciiToLower msg) (Text.asciiToLower pk)
secp256k1 sig _ _ | not (isDEREncoded sig) = error $ "Signature argument is not a DER encoded hex string: " <> sig
secp256k1 _ msg _ | not (Text.isHex msg) = error $ "Message argument is not a hex string: " <> msg
secp256k1 _ _ pk = error $ "Public key argument is not a DER encoded hex string: " <> pk

class HasToHex a where
  -- | Converts a typed data value into a hex encoded string.
  toHex: a -> BytesHex

instance HasToHex Text where
  toHex = primitive @"BEEncodeHex"

-- | HIDE
intToHexByte: Int -> BytesHex
intToHexByte n | 0 <= n && n <= 9 = show n
intToHexByte 10 = "a"
intToHexByte 11 = "b"
intToHexByte 12 = "c"
intToHexByte 13 = "d"
intToHexByte 14 = "e"
intToHexByte 15 = "f"
intToHexByte n | n < 256 = (intToHexByte(n / 16)) <> (intToHexByte(n % 16))
intToHexByte n = (intToHexByte(n / 256)) <> (intToHexByte(n % 256))

instance HasToHex Int where
  toHex n | 0 <= n && n <= 9 = "0" <> (show n)
  toHex 10 = "0a"
  toHex 11 = "0b"
  toHex 12 = "0c"
  toHex 13 = "0d"
  toHex 14 = "0e"
  toHex 15 = "0f"
  toHex n = intToHexByte n

instance HasToHex Party where
  toHex p = toHex(partyToText p)

instance NumericScale n => HasToHex (Numeric n) where
  toHex num = toHex(show num)

class HasFromHex a where
  -- | Converts a hex encoded string into a typed data value.
  fromHex: BytesHex -> a

instance HasFromHex Text where
  fromHex "" = ""
  fromHex hex | Text.isHex hex = primitive @"BEDecodeHex" (Text.asciiToLower hex)
  fromHex arg = error $ "Expected a hex encoded string but argument was: " <> arg

instance HasFromHex Int where
  fromHex "" = 0
  fromHex hex | Text.isHex hex && Text.length hex == 2 = hexByteToInt hex
  fromHex hex | Text.isHex hex =
    let right = fromHex(Text.substring ((Text.length hex) - 2) 2 hex)
        left = fromHex(Text.substring 0 ((Text.length hex) - 2) hex)
    in
      left * 256 + right
  fromHex arg = error $ "Expected a hex encoded string but argument was: " <> arg

instance HasFromHex Party where
  fromHex hex | Text.isHex hex = fromSome(partyFromText(fromHex hex))
  fromHex arg = error $ "Expected a hex encoded string but argument was: " <> arg

instance NumericScale n => HasFromHex (Numeric n) where
  fromHex hex | Text.isHex hex = fromSome(Text.parseNumeric(fromHex hex))
  fromHex arg = error $ "Expected a hex encoded string but argument was: " <> arg

-- | Number of bytes present in a byte encoded string.
byteCount: BytesHex -> Int
byteCount "" = 0
byteCount hex | Text.isHex hex = (Text.length hex) / 2
byteCount arg = error $ "Expected a hex encoded string but argument was: " <> arg

-- | Validate that the byte encoded string is Bytes32Hex
isBytes32Hex: BytesHex -> Bool
isBytes32Hex hex | Text.isHex hex = byteCount hex == 32
isBytes32Hex arg = error $ "Expected a hex encoded string but argument was: " <> arg

-- | Validate that the byte encoded string is UInt32Hex
isUInt32Hex: BytesHex -> Bool
isUInt32Hex hex | Text.isHex hex = byteCount hex == 5
isUInt32Hex arg = error $ "Expected a hex encoded string but argument was: " <> arg

-- | Validate that the byte encoded string is UInt64Hex
isUInt64Hex: BytesHex -> Bool
isUInt64Hex hex | Text.isHex hex = byteCount hex == 6
isUInt64Hex arg = error $ "Expected a hex encoded string but argument was: " <> arg

-- | Validate that the byte encoded string is UInt256Hex
isUInt256Hex: BytesHex -> Bool
isUInt256Hex hex | Text.isHex hex = byteCount hex == 8
isUInt256Hex arg = error $ "Expected a hex encoded string but argument was: " <> arg

-- | HIDE
constList: Int -> a -> [a]
constList 0 _ = []
constList n x = [x] ++ (constList (n - 1) x)

-- | Pack a byte encoded string to a given byte count size. If the byte string is shorter than the pad
-- size, then prefix with 00 byte strings. If the byte string is larger, then truncate the byte string.
packHexBytes: BytesHex -> Int -> BytesHex
packHexBytes hex pad | Text.isHex hex && 0 <= pad && byteCount hex <= pad = (Text.implode(constList (pad - byteCount hex) "00")) <> hex
packHexBytes hex pad | Text.isHex hex && 0 <= pad = Text.drop ((pad - byteCount hex) * 2) hex
packHexBytes arg _ = error $ "Expected a hex encoded string but argument was: " <> arg

-- | Extract the byte string starting at startByte up to, but excluding, endByte. Byte indexing starts at 1.
sliceHexBytes: BytesHex -> Int -> Int -> BytesHex
sliceHexBytes hex startByte endByte | Text.isHex hex && 1 <= startByte && startByte <= endByte && endByte <= (byteCount hex) + 1 = Text.substring ((startByte - 1) * 2) ((endByte - startByte) * 2) hex
sliceHexBytes hex startByte _ | Text.isHex hex && startByte < 1 =  error $ "Expected start byte to be >= 1, was: " <> show startByte
sliceHexBytes hex startByte endByte | Text.isHex hex && 1 <= startByte =  error $ "Expected end byte to be >= " <> show(startByte) <> " and <= " <> show((byteCount hex) + 1) <> " was: " <> show(endByte)
sliceHexBytes arg _ _ =  error $ "Expected a hex encoded string but argument was: " <> arg

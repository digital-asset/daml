# Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

# When adding, removing or changing a dependency in this file, update the pinned dependencies by executing
# $ bazel run @unpinned_maven//:pin
# See https://github.com/bazelbuild/rules_jvm_external#updating-maven_installjson

load("@rules_jvm_external//:defs.bzl", "maven_install")
load("@rules_jvm_external//:specs.bzl", "maven")
load(
    "@scala_version//:index.bzl",
    "scala_major_version",
    "scala_version",
)
load(
    "//bazel_tools:scalapb.bzl",
    "scalapb_protoc_version",
    "scalapb_version",
)
load("@common_deps//:common_deps.bzl", "DEPS")

version_specific = {
}

# ** Upgrading tcnative in sync with main netty version **
# Look for "tcnative.version" in top-level pom.xml.
# For example for netty version netty-4.1.68.Final look here https://github.com/netty/netty/blob/netty-4.1.68.Final/pom.xml#L511:
# ```
# <tcnative.version>2.0.42.Final</tcnative.version>
# ```

# Bumping versions of io.grpc:* has a few implications:
# 1. io.grpc:grpc-protobuf has a dependency on com.google.protobuf:protobuf-java, which in
#    turn needs to be aligned with the version of protoc we are using (as declared in deps.bzl).
#    ScalaPB also depends on a specific version of protobuf-java, but it's not strict:
#    as long as the version we use is greater than or equal to the version required by ScalaPB,
#    everything should work.
#
# 2. To keep TLS for the Ledger API Server working, the following three artifacts need be updated
# in sync according to https://github.com/grpc/grpc-java/blob/master/SECURITY.md#netty
#
# * io.grpc:grpc-netty
# * io.netty:netty-handler
# * io.netty:netty-tcnative-boringssl-static
#
# This effectively means all io.grpc:*, io.netty:*, and `com.google.protobuf:protobuf-java
# need to be updated with careful consideration.

apispec_version = "0.7.1"
netty_tcnative_version = "2.0.61.Final"
netty_version = "4.1.108.Final"
grpc_version = "1.60.0"
protobuf_version = "3.24.0"
pekko_version = "1.0.1"
pekko_http_version = "1.0.0"
tapir_version = "1.8.5"
ujson_version = "4.0.2"

guava_version = "31.1-jre"

# Updated 2024-03-15
opentelemetry_version = "1.36.0"
opentelemetry_instrumentation_version = "2.1.0-alpha"
prometheus_version = "0.16.0"

# group libraries controlled by the same org
circe_version = "0.14.2"

def install_java_deps():
    maven_install(
        artifacts = version_specific.get(scala_major_version, []) +
                    ["{}:{}:{}".format(d["org"], d["artifact"], d["version"]) for d in DEPS],
        fetch_sources = True,
        maven_install_json = "@com_github_digital_asset_daml//:maven_install_{}.json".format(scala_major_version),
        override_targets = {
            # Replacements for core Scala libraries.
            # These libraries must be provided by the Scala toolchain.
            #
            # Without these you may get obscure compiler errors about missing implicits,
            # or types that should be `Any`.
            # This needs to be kept in sync with //bazel-tools:pom_file.bzl
            "org.scala-lang:scala-compiler": "@io_bazel_rules_scala_scala_compiler//:io_bazel_rules_scala_scala_compiler",
            "org.scala-lang:scala-library": "@io_bazel_rules_scala_scala_library//:io_bazel_rules_scala_scala_library",
            "org.scala-lang:scala-reflect": "@io_bazel_rules_scala_scala_reflect//:io_bazel_rules_scala_scala_reflect",
            "org.scala-lang.modules:scala-parser-combinators": "@io_bazel_rules_scala_scala_parser_combinators//:io_bazel_rules_scala_scala_parser_combinators",
            "org.scala-tools.testing:test-interface": "//:org_scala_sbt_test_interface",
            "org.scalactic:scalactic_2.12": "@io_bazel_rules_scala_scalactic//:io_bazel_rules_scala_scalactic",
            "org.scalatest:scalatest_2.12": "@io_bazel_rules_scala_scalatest//:io_bazel_rules_scala_scalatest",
        },
        repositories = [
            "https://repo1.maven.org/maven2",
        ],
        # The strict_visibility attribute controls whether all artifacts should
        # be visible (including transitive dependencies), or whether only
        # explicitly declared artifacts should be visible. The targets
        # generated by maven_install do not forward transitive dependencies.
        # Instead, users need to explicitly declare each package a dependency
        # from which they wish to import. This makes strict visibility
        # inconvenient as one would have to pin versions of transitive
        # dependencies in this file, which complicates version updates later
        # on. Therefore, we don't enable strict visibility. This is the default.
        # strict_visibility = True,
        version_conflict_policy = "pinned",
    )
    maven_install(
        name = "canton_maven",
        maven_install_json = "@//:canton_maven_install.json",
        artifacts = [
            "org.flywaydb:flyway-core:9.15.2",
        ],
        repositories = [
            "https://repo1.maven.org/maven2",
        ],
        fetch_sources = True,
        version_conflict_policy = "pinned",
    )

    # Do not use those dependencies in anything new !
    maven_install(
        name = "deprecated_maven",
        maven_install_json = "@//:deprecated_maven_install.json",
        artifacts = [
            "io.gatling.highcharts:gatling-charts-highcharts:3.5.1",
            "io.gatling:gatling-app:3.5.1",
        ],
        repositories = [
            "https://repo1.maven.org/maven2",
        ],
        fetch_sources = True,
        version_conflict_policy = "pinned",
    )

-- Hoogle documentation for Daml, generated by damlc
-- See Hoogle, http://www.haskell.org/hoogle/

-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates.
-- All rights reserved. Any unauthorized use, duplication or distribution is strictly prohibited.

-- | Daml Standard Library.
@url https://docs.daml.com/daml/stdlib
@package daml-stdlib
@version 1.2.0

-- | The pieces that make up the Daml language.
@url https://docs.daml.com/daml/stdlib/Prelude.html#module-prelude-72703
module Prelude

-- | Existential choice type that can wrap an arbitrary choice.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-any-anychoice-86490
data AnyChoice

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-da-internal-any-anychoice-64121
AnyChoice :: Any -> TemplateTypeRep -> AnyChoice

getAnyChoice :: AnyChoice -> Any

getAnyChoiceTemplateTypeRep :: AnyChoice -> TemplateTypeRep

-- | Existential contract key type that can wrap an arbitrary contract key.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-any-anycontractkey-68193
data AnyContractKey

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-da-internal-any-anycontractkey-82848
AnyContractKey :: Any -> TemplateTypeRep -> AnyContractKey

getAnyContractKey :: AnyContractKey -> Any

getAnyContractKeyTemplateTypeRep :: AnyContractKey -> TemplateTypeRep

-- | Existential template type that can wrap an arbitrary template.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-any-anytemplate-63703
data AnyTemplate

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-da-internal-any-anytemplate-32540
AnyTemplate :: Any -> AnyTemplate

getAnyTemplate :: AnyTemplate -> Any

-- | Unique textual representation of a template Id.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-any-templatetyperep-33792
data TemplateTypeRep

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-da-internal-any-templatetyperep-57303
TemplateTypeRep :: TypeRep -> TemplateTypeRep

getTemplateTypeRep :: TemplateTypeRep -> TypeRep

-- | The `Down` type can be used for reversing sorting order.
--   For example, `sortOn (\x -> Down x.field)` would sort by descending `field`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-down-down-61433
data Down a

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-da-internal-down-down-26630
Down :: a -> Down

-- | (Daml-LF >= 1.15) Constraint that indicates that a template implements an interface.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-interface-implements-92077
type Implements t i = (HasInterfaceTypeRep i, HasToInterface t i, HasFromInterface t i)

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   A wrapper for all exception types.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-lf-anyexception-7004
data AnyException

-- | The `ContractId a` type represents an ID for a contract created from a template `a`.
--   You can use the ID to fetch the contract, among other things.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-lf-contractid-95282
data ContractId a

-- | The `Date` type represents a date, for example `date 2007 Apr 5`.
--   The bounds for Date are 0001-01-01 and 9999-12-31.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-lf-date-32253
data Date

-- | The `Map a b` type represents an associative array from keys of type `a`
--   to values of type `b`. It uses the built-in equality for keys. Import
--   `DA.Map` to use it.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-lf-map-90052
data Map a b

-- | The `Party` type represents a party to a contract.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-lf-party-57932
data Party

-- | The `TextMap a` type represents an associative array from keys of type
--   `Text` to values of type `a`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-lf-textmap-11691
data TextMap a

-- | The `Time` type represents a specific datetime in UTC,
--   for example `time (date 2007 Apr 5) 14 30 05`.
--   The bounds for Time are 0001-01-01T00:00:00.000000Z and
--   9999-12-31T23:59:59.999999Z.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-lf-time-63886
data Time

-- | The `Update a` type represents an `Action` to update or query the ledger,
--   before returning a value of type `a`. Examples include `create` and `fetch`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-lf-update-68072
data Update a

-- | The `Optional` type encapsulates an optional value.  A value of type
--   `Optional a` either contains a value of type `a` (represented as `Some a`),
--   or it is empty (represented as `None`).  Using `Optional` is a good way to
--   deal with errors or exceptional cases without resorting to drastic
--   measures such as `error`.
--   
--   The `Optional` type is also an `Action`.  It is a simple kind of error
--   `Action`, where all errors are represented by `None`.  A richer
--   error `Action` could be built using the `Data.Either.Either` type.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-prelude-optional-37153
data Optional a

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-da-internal-prelude-none-34906
None :: Optional

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-da-internal-prelude-some-71164
Some :: a -> Optional

-- | The data type corresponding to the implicit `Archive`
--   choice in every template.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-template-archive-15178
data Archive

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-da-internal-template-archive-55291
Archive :: Archive

-- | Constraint satisfied by choices.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-template-functions-choice-82157
type Choice t c r = (Template t, HasExercise t c r, HasToAnyChoice t c r, HasFromAnyChoice t c r)

@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-template-functions-template-31804
type Template t = (HasTemplateTypeRep t, HasToAnyTemplate t, HasFromAnyTemplate t)

-- | Constraint satisfied by template keys.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-internal-template-functions-templatekey-95200
type TemplateKey t k = (Template t, HasKey t k, HasLookupByKey t k, HasFetchByKey t k, HasMaintainer t k, HasToAnyContractKey t k, HasFromAnyContractKey t k)

-- | The `Either` type represents values with two possibilities: a value of
--   type `Either a b` is either `Left a` or `Right b`.
--   
--   The `Either` type is sometimes used to represent a value which is
--   either correct or an error; by convention, the `Left` constructor is
--   used to hold an error value and the `Right` constructor is used to
--   hold a correct value (mnemonic: "right" also means "correct").
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-da-types-either-56020
data Either a b

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-da-types-left-53933
Left :: a -> Either

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-da-types-right-18483
Right :: b -> Either

-- | `showS` should represent some text, and applying it to some argument
--   should prepend the argument to the represented text.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-ghc-show-shows-46771
type ShowS = Text -> Text

-- | A type for Boolean values, ie `True` and `False`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-ghc-types-bool-66265
data Bool

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-ghc-types-false-77590
False :: Bool

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-ghc-types-true-99264
True :: Bool

@url https://docs.daml.com/daml/stdlib/Prelude.html#type-ghc-types-decimal-18135
type Decimal = Numeric 10

-- | A type representing a 64-bit integer.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-ghc-types-int-37261
data Int

-- | (Kind) This is the kind of type-level naturals.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-ghc-types-nat-55875
data Nat

-- | A type for fixed-point decimal numbers, with the scale
--   being passed as part of the type.
--   
--   `Numeric n` represents a fixed-point decimal number with a
--   fixed precision of 38 (i.e. 38 digits not including a leading zero)
--   and a scale of `n`, i.e., `n` digits after the decimal point.
--   
--   `n` must be between 0 and 37 (bounds inclusive).
--   
--   Examples:
--   ```
--   0.01 : Numeric 2
--   0.0001 : Numeric 4
--   ```
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-ghc-types-numeric-891
data Numeric n

-- | A type for giving information about ordering:
--   being less than (`LT`), equal to (`EQ`), or greater than
--   (`GT`) something.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-ghc-types-ordering-35353
data Ordering

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-ghc-types-lt-57618
LT :: Ordering

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-ghc-types-eq-5100
EQ :: Ordering

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-ghc-types-gt-28015
GT :: Ordering

-- | A type for text strings, that can represent any unicode code point.
--   For example `"Hello, world"`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-ghc-types-text-51952
data Text

-- | A type for lists, for example `[1,2,3]`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#type-ghc-types-x-2599
data ([]) a

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-ghc-types-x-63478
([]) :: []

@url https://docs.daml.com/daml/stdlib/Prelude.html#constr-ghc-types-colon-97313
(:) :: _ -> _ -> []

-- | Constraint that determines whether an assertion can be made
--   in this context.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-assert-canassert-67323
class (Action m) => CanAssert m

-- | Abort since an assertion has failed. In an Update, Scenario,
--   or Script context this will throw an AssertionFailed
--   exception. In an `Either Text` context, this will return the
--   message as an error.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-assert-assertfail-25389
assertFail :: (CanAssert m) => Text -> m t

-- | (Daml-LF >= 1.15) Exposes the `interfaceTypeRep` function. Available only for interfaces.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-interface-hasinterfacetyperep-84221
class HasInterfaceTypeRep i

-- | (Daml-LF >= 1.15) Exposes the `toInterface` and `toInterfaceContractId` functions.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-interface-hastointerface-68104
class HasToInterface t i

-- | (Daml-LF >= 1.15) Exposes `fromInterface` and `fromInterfaceContractId`
--   functions.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-interface-hasfrominterface-43863
class HasFromInterface t i

-- | (Daml-LF >= 1.15) Attempt to convert an interface value back into a
--   template value. A `None` indicates that the expected template
--   type doesn't match the underyling template type for the
--   interface value.
--   
--   For example, `fromInterface @MyTemplate value` will try to convert
--   the interface value `value` into the template type `MyTemplate`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-interface-frominterface-94157
fromInterface :: (HasFromInterface t i) => i -> Optional t

@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-interface-hasinterfaceview-4492
class HasInterfaceView i v

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-interface-view-89932
_view :: (HasInterfaceView i v) => i -> v

-- | The `HasTime` class is for where the time is available: `Update`
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-lf-hastime-96546
class HasTime m

-- | Get the current time.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-lf-gettime-65753
getTime :: (HasTime m, HasCallStack) => m Time

-- | The `CanAbort` class is for `Action` s that can be aborted.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-lf-canabort-29060
class (Action m) => CanAbort m

-- | Abort the current action with a message.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-lf-abort-93286
abort :: (CanAbort m) => Text -> m a

@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-prelude-applicative-9257
class (Functor f) => Applicative f

-- | Lift a value.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-pure-90071
pure :: (Applicative f) => a -> f a

-- | Sequentially apply the function.
--   
--   A few functors support an implementation of `<*>` that is more
--   efficient than the default one.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-ltstargt-38714
(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of `liftA2` that is more
--   efficient than the default one. In particular, if `fmap` is an
--   expensive operation, it is likely better to use `liftA2` than to
--   `fmap` over the structure and then use `<*>`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-lifta2-20157
liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-stargt-24971
(*>) :: (Applicative f) => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-ltstar-15465
(<*) :: (Applicative f) => f a -> f b -> f a

@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-prelude-action-68790
class (Applicative m) => Action m

-- | Sequentially compose two actions, passing any value produced
--   by the first as an argument to the second.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-gtgteq-32767
(>>=) :: (Action m) => m a -> (a -> m b) -> m b

-- | This class exists to desugar pattern matches in do-notation.
--   Polymorphic usage, or calling `fail` directly, is not recommended.
--   Instead consider using `CanAbort`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-prelude-actionfail-34438
class (Action m) => ActionFail m

-- | Fail with an error message.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-fail-40565
fail :: (ActionFail m) => Text -> m a

-- | The class of semigroups (types with an associative binary operation).
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-prelude-semigroup-78998
class Semigroup a

-- | An associative operation.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-ltgt-2365
(<>) :: (Semigroup a) => a -> a -> a

-- | The class of monoids (types with an associative binary operation that has an identity).
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-prelude-monoid-6742
class (Semigroup a) => Monoid a

-- | Identity of `(<>)`
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-mempty-31919
mempty :: (Monoid a) => a

-- | Fold a list using the monoid.
--   For example using `mconcat` on a list of strings would concatenate all strings to one lone string.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-mconcat-59411
mconcat :: (Monoid a) => [a] -> a

-- | Exposes `signatory` function. Part of the `Template` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hassignatory-17507
class HasSignatory t

-- | The signatories of a contract.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-signatory-70149
signatory :: (HasSignatory t) => t -> [Party]

-- | Exposes `observer` function. Part of the `Template` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasobserver-3182
class HasObserver t

-- | The observers of a contract.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-observer-97032
observer :: (HasObserver t) => t -> [Party]

-- | Exposes `ensure` function. Part of the `Template` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasensure-18132
class HasEnsure t

-- | A predicate that must be true, otherwise contract creation will fail.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-ensure-45498
ensure :: (HasEnsure t) => t -> Bool

-- | Exposes `create` function. Part of the `Template` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hascreate-45738
class HasCreate t

-- | Create a contract based on a template `t`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-create-34708
create :: (HasCreate t) => t -> Update (ContractId t)

-- | Exposes `fetch` function. Part of the `Template` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasfetch-52387
class HasFetch t

-- | Fetch the contract data associated with the given contract ID.
--   If the `ContractId t` supplied is not the contract ID of an active
--   contract, this fails and aborts the entire transaction.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-fetch-90069
fetch :: (HasFetch t) => ContractId t -> Update t

-- | Exposes `softFetch` function
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hassoftfetch-65731
class HasSoftFetch t

@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hassoftexercise-29758
class HasSoftExercise t c r

-- | Exposes `archive` function. Part of the `Template` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasarchive-7071
class HasArchive t

-- | Archive the contract with the given contract ID.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-archive-2977
archive :: (HasArchive t) => ContractId t -> Update ()

-- | Exposes `templateTypeRep` function in Daml-LF 1.7 or later.
--   Part of the `Template` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hastemplatetyperep-24134
class HasTemplateTypeRep t

-- | Exposes `toAnyTemplate` function in Daml-LF 1.7 or later.
--   Part of the `Template` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hastoanytemplate-94418
class HasToAnyTemplate t

-- | Exposes `fromAnyTemplate` function in Daml-LF 1.7 or later.
--   Part of the `Template` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasfromanytemplate-95481
class HasFromAnyTemplate t

-- | Exposes `exercise` function. Part of the `Choice` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasexercise-70422
class HasExercise t c r

-- | Exercise a choice on the contract with the given contract ID.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-exercise-22396
exercise :: (HasExercise t c r) => ContractId t -> c -> Update r

-- | Exposes `choiceController` function. Part of the `Choice` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-haschoicecontroller-39229
class HasChoiceController t c

-- | Exposes `choiceObserver` function. Part of the `Choice` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-haschoiceobserver-31221
class HasChoiceObserver t c

-- | (1.dev only) Exposes `exerciseGuarded` function.
--   Only available for interface choices.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasexerciseguarded-97843
class HasExerciseGuarded t c r

-- | (1.dev only) Exercise a choice on the contract with
--   the given contract ID, only if the predicate returns `True`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-exerciseguarded-9285
exerciseGuarded :: (HasExerciseGuarded t c r) => (t -> Bool) -> ContractId t -> c -> Update r

-- | Exposes `toAnyChoice` function for Daml-LF 1.7 or later.
--   Part of the `Choice` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hastoanychoice-82571
class HasToAnyChoice t c r

-- | Exposes `fromAnyChoice` function for Daml-LF 1.7 or later.
--   Part of the `Choice` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasfromanychoice-81184
class HasFromAnyChoice t c r

-- | Exposes `key` function. Part of the `TemplateKey` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-haskey-87616
class HasKey t k

-- | The key of a contract.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-key-44978
key :: (HasKey t k) => t -> k

-- | Exposes `lookupByKey` function. Part of the `TemplateKey` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-haslookupbykey-92299
class HasLookupByKey t k

-- | Look up the contract ID `t` associated with a given contract key `k`.
--   
--   You must pass the `t` using an explicit type application. For
--   instance, if you want to look up a contract of template `Account` by its
--   key `k`, you must call `lookupByKey @Account k`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-lookupbykey-92781
lookupByKey :: (HasLookupByKey t k) => k -> Update (Optional (ContractId t))

-- | Exposes `fetchByKey` function. Part of the `TemplateKey` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasfetchbykey-54638
class HasFetchByKey t k

-- | Fetch the contract ID and contract data associated with a given
--   contract key.
--   
--   You must pass the `t` using an explicit type application. For
--   instance, if you want to fetch a contract of template `Account` by its
--   key `k`, you must call `fetchByKey @Account k`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-fetchbykey-95464
fetchByKey :: (HasFetchByKey t k) => k -> Update (ContractId t, t)

-- | Exposes `maintainer` function. Part of the `TemplateKey` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasmaintainer-28932
class HasMaintainer t k

-- | Exposes `toAnyContractKey` function in Daml-LF 1.7 or later.
--   Part of the `TemplateKey` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hastoanycontractkey-35010
class HasToAnyContractKey t k

-- | Exposes `fromAnyContractKey` function in Daml-LF 1.7 or later.
--   Part of the `TemplateKey` constraint.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasfromanycontractkey-95587
class HasFromAnyContractKey t k

-- | Exposes `exerciseByKey` function.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-hasexercisebykey-36549
class HasExerciseByKey t k c r

-- | Accepted ways to specify a list of parties: either a single party, or a list of parties.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-da-internal-template-functions-isparties-53750
class IsParties a

-- | Convert to list of parties.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-toparties-75184
toParties :: (IsParties a) => a -> [Party]

-- | A `Functor` is a typeclass for things that can be mapped over (using
--   its `fmap` function. Examples include `Optional`, `[]` and `Update`).
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-base-functor-31205
class Functor f

-- | `fmap` takes a function of type `a -> b`, and turns it into a
--   function of type `f a -> f b`, where `f` is the type which is an
--   instance of `Functor`.
--   
--   For example, `map` is an `fmap` that only works on lists.
--   It takes a function `a -> b` and a `[a]`, and returns a `[b]`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-base-fmap-51390
fmap :: (Functor f) => (a -> b) -> f a -> f b

-- | Replace all locations in the input `f b` with the same value `a`.
--   The default definition is `fmap . const`, but you can override
--   this with a more efficient version.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-base-ltdollar-81052
(<$) :: (Functor f) => a -> f b -> f a

-- | The `Eq` class defines equality (`==`) and inequality (`/=`).
--   All the basic datatypes exported by the "Prelude" are instances of `Eq`,
--   and `Eq` may be derived for any datatype whose constituents are also
--   instances of `Eq`.
--   
--   Usually, `==` is expected to implement an equivalence relationship where two
--   values comparing equal are indistinguishable by "public" functions, with
--   a "public" function being one not allowing to see implementation details. For
--   example, for a type representing non-normalised natural numbers modulo 100,
--   a "public" function doesn't make the difference between 1 and 201. It is
--   expected to have the following properties:
--   
--   **Reflexivity**: `x == x` = `True`
--   
--   **Symmetry**: `x == y` = `y == x`
--   
--   **Transitivity**: if `x == y && y == z` = `True`, then `x == z` = `True`
--   
--   **Substitutivity**: if `x == y` = `True` and `f` is a "public" function
--   whose return type is an instance of `Eq`, then `f x == f y` = `True`
--   
--   **Negation**: `x /= y` = `not (x == y)`
--   
--   Minimal complete definition: either `==` or `/=`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-classes-eq-22713
class Eq a

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-eqeq-39798
(==) :: (Eq a) => a -> a -> Bool

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-slasheq-13204
(/=) :: (Eq a) => a -> a -> Bool

-- | The `Ord` class is used for totally ordered datatypes.
--   
--   Instances of `Ord` can be derived for any user-defined datatype whose
--   constituent types are in `Ord`. The declared order of the constructors in
--   the data declaration determines the ordering in derived `Ord` instances. The
--   `Ordering` datatype allows a single comparison to determine the precise
--   ordering of two objects.
--   
--   The Haskell Report defines no laws for `Ord`. However, `<=` is customarily
--   expected to implement a non-strict partial order and have the following
--   properties:
--   
--   **Transitivity**: if `x <= y && y <= z` = `True`, then `x <= z` = `True`
--   
--   **Reflexivity**: `x <= x` = `True`
--   
--   **Antisymmetry**: if `x <= y && y <= x` = `True`, then `x == y` = `True`
--   
--   Note that the following operator interactions are expected to hold:
--   
--   1. `x >= y` = `y <= x`
--   2. `x < y` = `x <= y && x /= y`
--   3. `x > y` = `y < x`
--   4. `x < y` = `compare x y == LT`
--   5. `x > y` = `compare x y == GT`
--   6. `x == y` = `compare x y == EQ`
--   7. `min x y == if x <= y then x else y` = 'True'
--   8. `max x y == if x >= y then x else y` = 'True'
--   
--   Minimal complete definition: either `compare` or `<=`.
--   Using `compare` can be more efficient for complex types.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-classes-ord-6395
class (Eq a) => Ord a

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-compare-51066
compare :: (Ord a) => a -> a -> Ordering

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-lt-18689
(<) :: (Ord a) => a -> a -> Bool

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-lteq-90533
(<=) :: (Ord a) => a -> a -> Bool

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-gt-9999
(>) :: (Ord a) => a -> a -> Bool

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-gteq-27019
(>=) :: (Ord a) => a -> a -> Bool

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-max-68325
max :: (Ord a) => a -> a -> a

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-min-95471
min :: (Ord a) => a -> a -> a

-- | Is this a valid scale for the `Numeric` type?
--   
--   This typeclass is used to prevent the creation of Numeric values
--   with too large a scale. The scale controls the number of digits available
--   after the decimal point, and it must be between 0 and 37 inclusive.
--   
--   Thus the only available instances of this typeclass are `NumericScale 0`
--   through `NumericScale 37`. This cannot be extended without additional
--   compiler and runtime support. You cannot implement a custom instance
--   of this typeclass.
--   
--   If you have an error message in your code of the form "No instance for
--   `(NumericScale n)`", this is probably caused by having a numeric literal
--   whose scale cannot be inferred by the compiler. You can usually fix this
--   by adding a type signature to the definition, or annotating the numeric
--   literal directly (for example, instead of writing `3.14159` you can write
--   `(3.14159 : Numeric 5)`).
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-classes-numericscale-83720
class NumericScale n

-- | Get the scale of a `Numeric` as an integer. For example,
--   `numericScale (3.14159 : Numeric 5)` equals `5`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-numericscale-22799
numericScale :: (NumericScale n) => Int

-- | 1 with scale n
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-numericone-15415
numericOne :: (NumericScale n) => Numeric n

-- | Use the `Bounded` class to name the upper and lower limits of a
--   type.
--   
--   You can derive an instance of the `Bounded` class for any enumeration
--   type. `minBound`  is the first constructor listed in the `data`
--   declaration  and `maxBound` is the last.
--   
--   You can also derive an instance of `Bounded` for single-constructor data types whose
--   constituent types are in `Bounded`.
--   
--   `Ord` is not a superclass of `Bounded` because types that are not
--   totally ordered can still have upper and lower bounds.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-enum-bounded-34379
class Bounded a

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-enum-minbound-62730
minBound :: (Bounded a) => a

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-enum-maxbound-99484
maxBound :: (Bounded a) => a

-- | Use the `Enum` class to define operations on sequentially ordered
--   types: that is, types that can be enumerated. `Enum` members have
--   defined successors and predecessors, which you can get with the `succ`
--   and `pred` functions.
--   
--   Types that are an instance of class `Bounded` as well as `Enum`
--   should respect the following laws:
--   
--   * Both `succ maxBound` and `pred minBound` should result in
--     a runtime error.
--   
--   * `fromEnum` and `toEnum` should give a runtime error if the
--     result value is not representable in the result type.
--     For example, `toEnum 7 : Bool` is an error.
--   
--   * `enumFrom` and `enumFromThen` should be defined with an implicit bound,
--     like this:
--   
--   ```
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--       where
--           bound | fromEnum y >= fromEnum x = maxBound
--                 | otherwise                = minBound
--   ```
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-enum-enum-63048
class Enum a

-- | Returns the successor of the given value. For example, for
--   numeric types, `succ` adds 1.
--   
--   If the type is also an instance of `Bounded`, `succ maxBound`
--   results in a runtime error.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-enum-succ-78724
succ :: (Enum a) => a -> a

-- | Returns the predecessor of the given value. For example, for
--   numeric types, `pred` subtracts 1.
--   
--   If the type is also an instance of `Bounded`, `pred minBound`
--   results in a runtime error.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-enum-pred-25539
pred :: (Enum a) => a -> a

-- | Convert a value from an `Int` to an `Enum` value: ie,
--   `toEnum i` returns the item at the `i` th position of
--   (the instance of) `Enum`
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-enum-toenum-73120
toEnum :: (Enum a) => Int -> a

-- | Convert a value from an `Enum` value to an `Int`: ie, returns
--   the `Int` position of the element within the `Enum`.
--   
--   If `fromEnum` is applied to a value that's too large to
--   fit in an `Int`, what is returned is up to your implementation.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-enum-fromenum-36901
fromEnum :: (Enum a) => a -> Int

-- | Return a list of the `Enum` values starting at the `Int`
--   position. For example:
--   
--   * `enumFrom 6 : [Int] = [6,7,8,9,...,maxBound : Int]`
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-enum-enumfrom-64349
enumFrom :: (Enum a) => a -> [a]

-- | Returns a list of the `Enum` values with the first value at
--   the first `Int` position, the second value at the second `Int`
--   position, and further values with the same distance between them.
--   
--   For example:
--   
--   * `enumFromThen 4 6 : [Int] = [4,6,8,10...]`
--   * `enumFromThen 6 2 : [Int] = [6,2,-2,-6,...,minBound :: Int]`
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-enum-enumfromthen-57624
enumFromThen :: (Enum a) => a -> a -> [a]

-- | Returns a list of the `Enum` values with the first value at
--   the first `Int` position, and the last value at the last `Int`
--   position.
--   
--   This is what's behind the language feature that lets you write
--   `[n,m..]`.
--   
--   For example:
--   
--   * `enumFromTo 6 10 : [Int] = [6,7,8,9,10]`
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-enum-enumfromto-5096
enumFromTo :: (Enum a) => a -> a -> [a]

-- | Returns a list of the `Enum` values with the first value at
--   the first `Int` position, the second value at the second `Int`
--   position, and further values with the same distance between them,
--   with the final value at the final `Int` position.
--   
--   This is what's behind the language feature that lets you write
--   `[n,n'..m]`.
--   
--   For example:
--   
--   * `enumFromThenTo 4 2 -6 : [Int] = [4,2,0,-2,-4,-6]`
--   * `enumFromThenTo 6 8 2 : [Int] = []`
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-enum-enumfromthento-6169
enumFromThenTo :: (Enum a) => a -> a -> a -> [a]

-- | Use the `Additive` class for types that can be added.
--   Instances have to respect the following laws:
--   
--   * `(+)` must be associative, ie: `(x + y) + z` = `x + (y + z)`
--   * `(+)` must be commutative, ie: `x + y` = `y + x`
--   * `x + aunit` = `x`
--   * `negate` gives the additive inverse, ie: `x + negate x` = `aunit`
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-num-additive-25881
class Additive a

-- | Add the two arguments together.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-plus-27850
(+) :: (Additive a) => a -> a -> a

-- | The additive identity for the type. For example, for numbers, this is 0.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-aunit-61822
aunit :: (Additive a) => a

-- | Subtract the second argument from the first argument, ie. `x - y` = `x + negate y`
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-dash-19160
(-) :: (Additive a) => a -> a -> a

-- | Negate the argument: `x + negate x` = `aunit`
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-negate-48522
negate :: (Additive a) => a -> a

-- | Use the `Multiplicative` class for types that can be multiplied.
--   Instances have to respect the following laws:
--   
--   * `(*)` is associative, ie:`(x * y) * z` = `x * (y * z)`
--   * `(*)` is commutative, ie: `x * y` = `y * x`
--   * `x * munit` = `x`
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-num-multiplicative-10593
class Multiplicative a

-- | Multipy the arguments together
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-star-29927
(*) :: (Multiplicative a) => a -> a -> a

-- | The multiplicative identity for the type. For example, for numbers, this is 1.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-munit-70418
munit :: (Multiplicative a) => a

-- | `x ^ n` raises `x` to the power of `n`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-hat-82067
(^) :: (Multiplicative a) => a -> Int -> a

-- | `Number` is a class for numerical types.
--   As well as the rules for `Additive` and `Multiplicative`, instances
--   also have to respect the following law:
--   
--   * `(*)` is distributive with respect to `(+)`. That is:
--       `a * (b + c)` = `(a * b) + (a * c)` and `(b + c) * a` = `(b * a) + (c * a)`
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-num-number-53664
class (Additive a, Multiplicative a) => Number a

-- | The `Signed` is for the sign of a number.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-num-signed-2671
class Signed a

-- | Sign of a number.
--   For real numbers, the 'signum' is either `-1` (negative), `0` (zero)
--   or `1` (positive).
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-signum-92649
signum :: (Signed a) => a -> a

-- | The absolute value: that is, the value without the sign.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-abs-35083
abs :: (Signed a) => a -> a

-- | Use the `Divisible` class for types that can be divided.
--   Instances should respect that division is the inverse of
--   multiplication, i.e. `x * y / y` is equal to `x` whenever
--   it is defined.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-num-divisible-86689
class (Multiplicative a) => Divisible a

-- | `x / y` divides `x` by `y`
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-slash-10470
(/) :: (Divisible a) => a -> a -> a

-- | Use the `Fractional` class for types that can be divided
--   and where the reciprocal is well defined. Instances
--   have to respect the following laws:
--   
--   * When `recip x` is defined, it must be the inverse of
--   `x` with respect to multiplication: `x * recip x = munit`
--   
--   * When `recip y` is defined, then `x / y = x * recip y`
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-num-fractional-79050
class (Divisible a) => Fractional a

-- | Calculates the reciprocal: `recip x` is `1/x`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-recip-73404
recip :: (Fractional a) => a -> a

-- | Use the `Show` class for values that can be converted to a
--   readable `Text` value.
--   
--   Derived instances of `Show` have the following properties:
--   
--   * The result of `show` is a syntactically correct expression
--     that only contains constants (given the fixity declarations in
--     force at the point where the type is declared).
--     It only contains the constructor names defined in the data type,
--     parentheses, and spaces. When labelled constructor fields are
--     used, braces, commas, field names, and equal signs are also used.
--   
--   * If the constructor is defined to be an infix operator, then
--     `showsPrec` produces infix applications of the constructor.
--   
--   * If the  precedence of the top-level constructor in `x` is less than `d`
--     (associativity is ignored), the representation will be enclosed in
--     parentheses. For example, if `d` is `0` then the result
--     is never surrounded in parentheses; if `d` is `11` it is always
--     surrounded in parentheses, unless it is an atomic expression.
--   
--   * If the constructor is defined using record syntax, then `show`
--     will produce the record-syntax form, with the fields given in the
--     same order as the original declaration.
@url https://docs.daml.com/daml/stdlib/Prelude.html#class-ghc-show-show-65360
class Show a

-- | Convert a value to a readable `Text` value. Unlike `show`,
--   `showsPrec` should satisfy the rule
--   `showsPrec d x r ++ s == showsPrec d x (r ++ s)`
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-show-showsprec-34581
showsPrec :: (Show a) => Int -> a -> ShowS

-- | Convert a value to a readable `Text` value.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-show-show-51173
show :: (Show a) => a -> Text

-- | Allows you to show lists of values.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-show-showlist-14969
showList :: (Show a) => [a] -> ShowS

-- | Check whether a condition is true. If it's not, abort the transaction.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-assert-assert-75697
assert :: (CanAssert m) => Bool -> m ()

-- | Check whether a condition is true. If it's not, abort the transaction
--   with a message.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-assert-assertmsg-31545
assertMsg :: (CanAssert m) => Text -> Bool -> m ()

-- | Check whether the given time is in the future. If it's not, abort the transaction.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-assert-assertafter-43038
assertAfter :: (CanAssert m, HasTime m) => Time -> m ()

-- | Check whether the given time is in the past. If it's not, abort the transaction.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-assert-assertbefore-99854
assertBefore :: (CanAssert m, HasTime m) => Time -> m ()

-- | Convert from number of days since epoch (i.e. the number of days since
--   January 1, 1970) to a date.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-date-dayssinceepochtodate-57782
daysSinceEpochToDate :: Int -> Date

-- | Convert from a date to number of days from epoch (i.e. the number of days
--   since January 1, 1970).
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-date-datetodayssinceepoch-98906
dateToDaysSinceEpoch :: Date -> Int

-- | (Daml-LF >= 1.15) Obtain the `TemplateTypeRep` for the template given in the interface value.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-interface-interfacetyperep-28987
interfaceTypeRep :: (HasInterfaceTypeRep i) => i -> TemplateTypeRep

-- | (Daml-LF >= 1.15) Convert a template value into an interface value.
--   For example `toInterface @MyInterface value` converts a template
--   `value` into a `MyInterface` type.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-interface-tointerface-33774
toInterface :: (HasToInterface t i) => t -> i

-- | (Daml-LF >= 1.15) Convert a template contract id into an interface
--   contract id. For example, `toInterfaceContractId @MyInterface cid`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-interface-tointerfacecontractid-24085
toInterfaceContractId :: (HasToInterface t i) => ContractId t -> ContractId i

-- | (Daml-LF >= 1.15) Convert an interface contract id into a template
--   contract id. For example, `fromInterfaceContractId @MyTemplate cid`.
--   
--   Can also be used to convert an interface contract id into a contract id of
--   one of its requiring interfaces.
--   
--   This function does not verify that the interface contract id
--   actually points to a template of the given type. This means
--   that a subsequent `fetch`, `exercise`, or `archive` may fail, if,
--   for example, the contract id points to a contract that implements
--   the interface but is of a different template type than expected.
--   
--   Therefore, you should only use `fromInterfaceContractId` in situations
--   where you already know that the contract id points to a contract of the
--   right template type. You can also use it in situations where you will
--   fetch, exercise, or archive the contract right away, when a transaction
--   failure is the appropriate response to the contract having the wrong
--   template type.
--   
--   In all other cases, consider using `fetchFromInterface` instead.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-interface-frominterfacecontractid-39614
fromInterfaceContractId :: (HasFromInterface t i) => ContractId i -> ContractId t

-- | (Daml-LF >= 1.15) Convert an interface contract id into a contract id of a
--   different interface. For example, given two interfaces `Source` and `Target`,
--   and `cid : ContractId Source`,
--   `coerceInterfaceContractId @Target @Source cid : ContractId Target`.
--   
--   This function does not verify that the contract id
--   actually points to a contract that implements either interface. This means
--   that a subsequent `fetch`, `exercise`, or `archive` may fail, if,
--   for example, the contract id points to a contract of template `A` but it was
--   coerced into a `ContractId B` where `B` is an interface and there's no
--   interface instance B for A.
--   
--   Therefore, you should only use `coerceInterfaceContractId` in situations
--   where you already know that the contract id points to a contract of the right
--   type. You can also use it in situations where you will fetch, exercise, or
--   archive the contract right away, when a transaction failure is the
--   appropriate response to the contract having the wrong type.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-interface-coerceinterfacecontractid-23361
coerceInterfaceContractId :: (HasInterfaceTypeRep i, HasInterfaceTypeRep j) => ContractId i -> ContractId j

-- | (Daml-LF >= 1.15) Fetch an interface and convert it to a specific
--   template type. If conversion is succesful, this function returns
--   the converted contract and its converted contract id. Otherwise,
--   this function returns `None`.
--   
--   Can also be used to fetch and convert an interface contract id into a
--   contract and contract id of one of its requiring interfaces.
--   
--   Example:
--   ```
--   do
--     fetchResult <- fetchFromInterface @MyTemplate ifaceCid
--     case fetchResult of
--       None -> abort "Failed to convert interface to appropriate template type"
--       Some (tplCid, tpl) -> do
--          ... do something with tpl and tplCid ...
--   ```
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-interface-fetchfrominterface-99354
fetchFromInterface :: (HasFromInterface t i, HasFetch i) => ContractId i -> Update (Optional (ContractId t, t))

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-interface-exerciseinterfaceguard-49471
_exerciseInterfaceGuard :: a -> b -> c -> Bool

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-interface-view-38554
view :: (HasInterfaceView i v) => i -> v

-- | Convert the `Party` to `Text`, giving back what you passed to `getParty`.
--   In most cases, you should use `show` instead. `show` wraps
--   the party in `'ticks'` making it clear it was a `Party` originally.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-lf-partytotext-91600
partyToText :: Party -> Text

-- | Converts a `Text` to `Party`. It returns `None` if the provided text contains
--   any forbidden characters. See Daml-LF spec for a specification on which characters
--   are allowed in parties. Note that this function accepts text _without_
--   single quotes.
--   
--   This function does not check on whether the provided
--   text corresponds to a party that "exists" on a given ledger: it merely converts
--   the given `Text` to a `Party`. The only way to guarantee that a given `Party`
--   exists on a given ledger is to involve it in a contract.
--   
--   This function, together with `partyToText`, forms an isomorphism between
--   valid party strings and parties. In other words, the following equations hold:
--   
--   ```daml-force
--   ∀ p. partyFromText (partyToText p) = Some p
--   ∀ txt p. partyFromText txt = Some p ==> partyToText p = txt
--   ```
--   
--   This function will crash at runtime if you compile Daml to Daml-LF < 1.2.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-lf-partyfromtext-17681
partyFromText :: Text -> Optional Party

-- | Used to convert the type index of a `ContractId`, since they are just
--   pointers. Note that subsequent fetches and exercises might fail if the
--   template of the contract on the ledger doesn't match.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-lf-coercecontractid-14371
coerceContractId :: ContractId a -> ContractId b

-- | Turn a function that takes a pair into a function that takes two arguments.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-curry-6393
curry :: ((a, b) -> c) -> a -> b -> c

-- | Turn a function that takes two arguments into a function that takes a pair.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-uncurry-79420
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | Sequentially compose two actions, discarding any value produced
--   by the first. This is like sequencing operators (such as the semicolon)
--   in imperative languages.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-gtgt-56231
(>>) :: (Action m) => m a -> m b -> m b

-- | Synonym for `<*>`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-ap-60204
ap :: (Applicative f) => f (a -> b) -> f a -> f b

-- | Inject a value into the monadic type. For example, for `Update` and a
--   value of type `a`, `return` would give you an `Update a`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-return-15945
return :: (Applicative m) => a -> m a

-- | Collapses nested actions into a single action.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-join-43001
join :: (Action m) => m (m a) -> m a

-- | The identity function.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-identity-53027
identity :: a -> a

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-guard-82483
guard :: (ActionFail m) => Bool -> m ()

-- | This function is a left fold, which you can use to inspect/analyse/consume lists.
--   `foldl f i xs` performs a left fold over the list `xs` using
--   the function `f`, using the starting value `i`.
--   
--   Examples:
--   
--   ```
--   >>> foldl (+) 0 [1,2,3]
--   6
--   
--   >>> foldl (^) 10 [2,3]
--   1000000
--   ```
--   
--   Note that foldl works from left-to-right over the list arguments.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-foldl-3431
foldl :: (b -> a -> b) -> b -> [a] -> b

-- | `find p xs` finds the first element of the list `xs` where the
--   predicate `p` is true. There might not be such an element, which
--   is why this function returns an `Optional a`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-find-82808
find :: (a -> Bool) -> [a] -> Optional a

-- | Gives the length of the list.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-length-32819
length :: [a] -> Int

-- | Are there any elements in the list where the predicate is true?
--   `any p xs` is `True` if `p` holds for at least one element of `xs`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-any-88476
any :: (a -> Bool) -> [a] -> Bool

-- | Is the predicate true for all of the elements in the list?
--   `all p xs` is `True` if `p` holds for every element of `xs`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-all-93363
all :: (a -> Bool) -> [a] -> Bool

-- | Is at least one of elements in a list of `Bool` true?
--   `or bs` is `True` if at least one element of `bs` is `True`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-or-54324
or :: [Bool] -> Bool

-- | Is every element in a list of Bool true?
--   `and bs` is `True` if every element of `bs` is `True`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-and-20777
and :: [Bool] -> Bool

-- | Does this value exist in this list?
--   `elem x xs` is `True` if `x` is an element of the list `xs`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-elem-84192
elem :: (Eq a) => a -> [a] -> Bool

-- | Negation of `elem`:
--   `elem x xs` is `True` if `x` is _not_ an element of the list `xs`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-notelem-95004
notElem :: (Eq a) => a -> [a] -> Bool

-- | Synonym for `fmap`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-ltdollargt-82160
(<$>) :: (Functor f) => (a -> b) -> f a -> f b

-- | The `optional` function takes a default value, a function, and a `Optional`
--   value.  If the `Optional` value is `None`, the function returns the
--   default value.  Otherwise, it applies the function to the value inside
--   the `Some` and returns the result.
--   
--   Basic usage examples:
--   
--   ```
--   >>> optional False (> 2) (Some 3)
--   True
--   ```
--   
--   ```
--   >>> optional False (> 2) None
--   False
--   ```
--   
--   ```
--   >>> optional 0 (*2) (Some 5)
--   10
--   >>> optional 0 (*2) None
--   0
--   ```
--   
--   This example applies `show` to a `Optional Int`. If you have `Some n`,
--   this shows the underlying `Int`, `n`. But if you have `None`, this
--   returns the empty string instead of (for example) `None`:
--   
--   ```
--   >>> optional "" show (Some 5)
--   "5"
--   >>> optional "" show (None : Optional Int)
--   ""
--   ```
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-optional-80885
optional :: b -> (a -> b) -> Optional a -> b

-- | The `either` function provides case analysis for the `Either` type.
--   If the value is `Left a`, it applies the first function to `a`;
--   if it is `Right b`, it applies the second function to `b`.
--   
--   Examples:
--   
--   This example has two values of type `Either [Int] Int`, one using the
--   `Left` constructor and another using the `Right` constructor. Then
--   it applies `either` the `length` function (if it has a `[Int]`)
--   or the "times-two" function (if it has an `Int`):
--   
--   ```
--   >>> let s = Left [1,2,3] : Either [Int] Int in either length (*2) s
--   3
--   >>> let n = Right 3 : Either [Int] Int in either length (*2) n
--   6
--   ```
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-either-9020
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | Take a list of lists and concatenate those lists into one list.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-concat-86947
concat :: [[a]] -> [a]

-- | Concatenate two lists.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-plusplus-64685
(++) :: [a] -> [a] -> [a]

-- | Flip the order of the arguments of a two argument function.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-flip-60304
flip :: (a -> b -> c) -> b -> a -> c

-- | Reverse a list.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-reverse-91564
reverse :: [a] -> [a]

-- | Apply an applicative function to each element of a list.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-mapa-5250
mapA :: (Applicative m) => (a -> m b) -> [a] -> m [b]

-- | `forA` is `mapA` with its arguments flipped.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-fora-2999
forA :: (Applicative m) => [a] -> (a -> m b) -> m [b]

-- | Perform a list of actions in sequence and collect the results.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-sequence-43906
sequence :: (Applicative m) => [m a] -> m [a]

-- | `=<<` is `>>=` with its arguments flipped.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-eqltlt-62567
(=<<) :: (Action m) => (a -> m b) -> m a -> m b

-- | Map a function over each element of a list, and concatenate all the results.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-concatmap-18810
concatMap :: (a -> [b]) -> [a] -> [b]

-- | `replicate i x` gives the list `[x, x, x, ..., x]` with `i` copies of `x`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-replicate-97857
replicate :: Int -> a -> [a]

-- | Take the first `n` elements of a list.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-take-28256
take :: Int -> [a] -> [a]

-- | Drop the first `n` elements of a list.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-drop-39374
drop :: Int -> [a] -> [a]

-- | Split a list at a given index.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-splitat-62285
splitAt :: Int -> [a] -> ([a], [a])

-- | Take elements from a list while the predicate holds.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-takewhile-28496
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | Drop elements from a list while the predicate holds.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-dropwhile-40350
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | `span p xs` is equivalent to `(takeWhile p xs, dropWhile p xs)`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-span-51013
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | The `partition` function takes a predicate, a list and returns
--   the pair of lists of elements which do and do not satisfy the
--   predicate, respectively; i.e.,
--   
--   > partition p xs == (filter p xs, filter (not . p) xs)
--   
--   ```
--   >>> partition (<0) [1, -2, -3, 4, -5, 6]
--   ([-2, -3, -5], [1, 4, 6])
--   ```
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-partition-74270
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | Break a list into two, just before the first element where the predicate holds.
--   `break p xs` is equivalent to `span (not . p) xs`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-break-18317
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | Look up the first element with a matching key.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-lookup-7541
lookup :: (Eq a) => a -> [(a, b)] -> Optional b

-- | Generate a list containing all values of a given enumeration.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-enumerate-9854
enumerate :: (Enum a, Bounded a) => [a]

-- | `zip` takes two lists and returns a list of corresponding pairs.
--   If one list is shorter, the excess elements of the longer list are discarded.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-zip-87479
zip :: [a] -> [b] -> [(a, b)]

-- | `zip3` takes three lists and returns a list of triples, analogous to `zip`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-zip3-8569
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | `zipWith` takes a function and two lists.
--   It generalises `zip` by combining elements using the function, instead of forming pairs.
--   If one list is shorter, the excess elements of the longer list are discarded.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-zipwith-13207
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | `zipWith3` generalises `zip3` by combining elements using the function, instead of forming triples.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-zipwith3-3785
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | Turn a list of pairs into a pair of lists.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-unzip-18278
unzip :: [(a, b)] -> ([a], [b])

-- | Turn a list of triples into a triple of lists.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-unzip3-67086
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | `traceRaw msg a` prints `msg` and returns `a`, for debugging purposes.
--   
--   The default configuration on the participant logs these messages at DEBUG level.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-traceraw-94102
traceRaw :: Text -> a -> a

-- | `trace b a` prints `b` and returns `a`, for debugging purposes.
--   
--   The default configuration on the participant logs these messages at DEBUG level.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-trace-56451
trace :: (Show b) => b -> a -> a

-- | `traceId a` prints `a` and returns `a`, for debugging purposes.
--   
--   The default configuration on the participant logs these messages at DEBUG level.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-traceid-75962
traceId :: (Show b) => b -> b

-- | `debug x` prints `x` for debugging purposes.
--   
--   The default configuration on the participant logs these messages at DEBUG level.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-debug-24649
debug :: (Show b, Action m) => b -> m ()

-- | `debugRaw msg` prints `msg` for debugging purposes.
--   
--   The default configuration on the participant logs these messages at DEBUG level.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-debugraw-7384
debugRaw :: (Action m) => Text -> m ()

-- | Return the first element of a tuple.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-fst-55341
fst :: (a, b) -> a

-- | Return the second element of a tuple.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-snd-88623
snd :: (a, b) -> b

-- | `truncate x` rounds `x` toward zero.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-truncate-45759
truncate :: Numeric n -> Int

-- | Convert an `Int` to a `Numeric`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-inttonumeric-99696
intToNumeric :: (NumericScale n) => Int -> Numeric n

-- | Convert an `Int` to a `Decimal`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-inttodecimal-16628
intToDecimal :: Int -> Decimal

-- | Bankers' Rounding: `roundBankers dp x` rounds `x` to `dp` decimal places, where a `.5` is rounded to the nearest even digit.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-roundbankers-80419
roundBankers :: Int -> Numeric n -> Numeric n

-- | Commercial Rounding: `roundCommercial dp x` rounds `x` to `dp` decimal places, where a `.5` is rounded away from zero.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-roundcommercial-50292
roundCommercial :: (NumericScale n) => Int -> Numeric n -> Numeric n

-- | Round a `Numeric` to the nearest integer, where a `.5` is rounded away from zero.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-round-17808
round :: (NumericScale n) => Numeric n -> Int

-- | Round a `Decimal` down to the nearest integer.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-floor-26810
floor :: (NumericScale n) => Numeric n -> Int

-- | Round a `Decimal` up to the nearest integer.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-ceiling-19727
ceiling :: (NumericScale n) => Numeric n -> Int

-- | Is the list empty? `null xs` is true if `xs` is the empty list.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-null-12330
null :: [a] -> Bool

-- | Filters the list using the function: keep only the elements where the predicate holds.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-filter-41317
filter :: (a -> Bool) -> [a] -> [a]

-- | Add together all the elements in the list.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-sum-46659
sum :: (Additive a) => [a] -> a

-- | Multiply all the elements in the list together.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-product-15907
product :: (Multiplicative a) => [a] -> a

-- | A convenience function that can be used to mark something not implemented.
--   Always throws an error with "Not implemented."
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-prelude-undefined-12708
undefined :: a

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-softfetch-60405
softFetch :: (HasSoftFetch t) => ContractId t -> Update t

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-softexercise-80500
softExercise :: (HasSoftExercise t c r) => ContractId t -> c -> Update r

-- | The stakeholders of a contract: its signatories and observers.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-stakeholder-47883
stakeholder :: (HasSignatory t, HasObserver t) => t -> [Party]

-- | The list of maintainers of a contract key.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-maintainer-44226
maintainer :: (HasMaintainer t k) => k -> [Party]

-- | Exercise a choice on the contract associated with the given key.
--   
--   You must pass the `t` using an explicit type application. For
--   instance, if you want to exercise a choice `Withdraw` on a contract of
--   template `Account` given by its key `k`, you must call
--   `exerciseByKey @Account k Withdraw`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-exercisebykey-78695
exerciseByKey :: (HasExerciseByKey t k c r) => k -> c -> Update r

-- | Create a contract and exercise the choice on the newly created contract.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-createandexercise-2676
createAndExercise :: (HasCreate t, HasExercise t c r) => t -> c -> Update r

-- | Generate a unique textual representation of the template id.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-templatetyperep-92004
templateTypeRep :: (HasTemplateTypeRep t) => TemplateTypeRep

-- | Wrap the template in `AnyTemplate`.
--   
--   Only available for Daml-LF 1.7 or later.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-toanytemplate-14372
toAnyTemplate :: (HasToAnyTemplate t) => t -> AnyTemplate

-- | Extract the underlying template from `AnyTemplate` if the type matches
--   or return `None`.
--   
--   Only available for Daml-LF 1.7 or later.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-fromanytemplate-39771
fromAnyTemplate :: (HasFromAnyTemplate t) => AnyTemplate -> Optional t

-- | Wrap a choice in `AnyChoice`.
--   
--   You must pass the template type `t` using an explicit type application.
--   For example `toAnyChoice @Account Withdraw`.
--   
--   Only available for Daml-LF 1.7 or later.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-toanychoice-22033
toAnyChoice :: (HasTemplateTypeRep t, HasToAnyChoice t c r) => c -> AnyChoice

-- | Extract the underlying choice from `AnyChoice` if the template and
--   choice types match, or return `None`.
--   
--   You must pass the template type `t` using an explicit type application.
--   For example `fromAnyChoice @Account choice`.
--   
--   Only available for Daml-LF 1.7 or later.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-fromanychoice-95102
fromAnyChoice :: (HasTemplateTypeRep t, HasFromAnyChoice t c r) => AnyChoice -> Optional c

-- | Wrap a contract key in `AnyContractKey`.
--   
--   You must pass the template type `t` using an explicit type application.
--   For example `toAnyContractKey @Proposal k`.
--   
--   Only available for Daml-LF 1.7 or later.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-toanycontractkey-75916
toAnyContractKey :: (HasTemplateTypeRep t, HasToAnyContractKey t k) => k -> AnyContractKey

-- | Extract the underlying key from `AnyContractKey` if the template and
--   choice types match, or return `None`.
--   
--   You must pass the template type `t` using an explicit type application.
--   For example `fromAnyContractKey @Proposal k`.
--   
--   Only available for Daml-LF 1.7 or later.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-fromanycontractkey-60533
fromAnyContractKey :: (HasTemplateTypeRep t, HasFromAnyContractKey t k) => AnyContractKey -> Optional k

-- | True if contract exists, submitter is a stakeholder, and all maintainers
--   authorize. False if contract does not exist and all maintainers authorize.
--   Fails otherwise.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-da-internal-template-functions-visiblebykey-51464
visibleByKey :: (HasLookupByKey t k) => k -> Update Bool

-- | Used as an alternative in conditions.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-base-otherwise-74255
otherwise :: Bool

-- | `map f xs` applies the function `f` to all elements of the list `xs`
--   and returns the list of results (in the same order as `xs`).
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-base-map-90641
map :: (a -> b) -> [a] -> [b]

-- | This function is a right fold, which you can use to manipulate lists.
--   `foldr f i xs` performs a right fold over the list `xs` using
--   the function `f`, using the starting value `i`.
--   
--   Note that foldr works from right-to-left over the list elements.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-base-foldr-98040
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | Composes two functions, i.e., `(f . g) x = f (g x)`.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-base-dot-65651
(.) :: (b -> c) -> (a -> b) -> a -> c

-- | `const x` is a unary function which evaluates to `x` for all inputs.
--   
--   ```
--   >>> const 42 "hello"
--   42
--   ```
--   
--   ```
--   >>> map (const 42) [0..3]
--   [42,42,42,42]
--   ```
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-base-const-63840
const :: a -> b -> a

-- | Take a function from `a` to `b` and a value of type `a`, and apply the
--   function to the value of type `a`, returning a value of type `b`.
--   This function has a very low precedence, which is why you might want to use
--   it instead of regular function application.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-base-dollar-9101
($) :: (a -> b) -> a -> b

-- | Boolean \"and\".
--   This function has short-circuiting semantics, i.e., when both arguments are
--   present and the first arguments evaluates to 'False', the second argument
--   is not evaluated at all.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-ampamp-27924
(&&) :: Bool -> Bool -> Bool

-- | Boolean \"or\".
--   This function has short-circuiting semantics, i.e., when both arguments are
--   present and the first arguments evaluates to 'True', the second argument
--   is not evaluated at all.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-pipepipe-13296
(||) :: Bool -> Bool -> Bool

-- | Boolean \"not\"
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-classes-not-45172
not :: Bool -> Bool

-- | Throws a `GeneralError` exception.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-err-error-7998
error :: Text -> a

-- | `subtract x y` is equivalent to `y - x`.
--   
--   This is useful for partial application, e.g., in `subtract 1` since `(- 1)` is
--   interpreted as the number `-1` and not a function that subtracts `1` from
--   its argument.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-subtract-88614
subtract :: (Additive a) => a -> a -> a

-- | `x % y` calculates the remainder of `x` by `y`
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-num-x-53920
(%) :: Int -> Int -> Int

@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-show-shows-71951
shows :: (Show a) => a -> ShowS

-- | Utility function that surrounds the inner show function with
--   parentheses when the 'Bool' parameter is 'True'.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-show-showparen-94620
showParen :: Bool -> ShowS -> ShowS

-- | Utility function converting a 'String' to a show function that
--   simply prepends the string unchanged.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-show-showstring-40356
showString :: Text -> ShowS

-- | Prepends a single space to the front of the string.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-show-showspace-56114
showSpace :: ShowS

-- | Prepends a comma and a single space to the front of the string.
@url https://docs.daml.com/daml/stdlib/Prelude.html#function-ghc-show-showcommaspace-16566
showCommaSpace :: ShowS

-- | Action
@url https://docs.daml.com/daml/stdlib/DA-Action.html#module-da-action-7169
module DA.Action

-- | Conditional execution of `Action` expressions. For example,
--   ```
--     when final (archive contractId)
--   ```
--   will archive the contract `contractId` if the Boolean value `final` is
--   `True`, and otherwise do nothing.
--   
--   This function has short-circuiting semantics, i.e., when both arguments are
--   present and the first arguments evaluates to `False`, the second argument
--   is not evaluated at all.
@url https://docs.daml.com/daml/stdlib/DA-Action.html#function-da-action-when-35467
when :: (Applicative f) => Bool -> f () -> f ()

-- | The reverse of `when`.
--   
--   This function has short-circuiting semantics, i.e., when both arguments are
--   present and the first arguments evaluates to `True`, the second argument
--   is not evaluated at all.
@url https://docs.daml.com/daml/stdlib/DA-Action.html#function-da-action-unless-8539
unless :: (Applicative f) => Bool -> f () -> f ()

-- | The `foldrA` is analogous to `foldr`, except that its result is
--   encapsulated in an action. Note that `foldrA` works from right-to-left
--   over the list arguments.
@url https://docs.daml.com/daml/stdlib/DA-Action.html#function-da-action-foldra-2803
foldrA :: (Action m) => (a -> b -> m b) -> b -> [a] -> m b

-- | `foldr1A` is like `foldrA` but raises an error when presented
--   with an empty list argument.
@url https://docs.daml.com/daml/stdlib/DA-Action.html#function-da-action-foldr1a-55935
foldr1A :: (Action m) => (a -> a -> m a) -> [a] -> m a

-- | `foldlA` is analogous to `foldl`, except that its result is
--   encapsulated in an action. Note that `foldlA` works from
--   left-to-right over the list arguments.
@url https://docs.daml.com/daml/stdlib/DA-Action.html#function-da-action-foldla-78897
foldlA :: (Action m) => (b -> a -> m b) -> b -> [a] -> m b

-- | The `foldl1A` is like `foldlA` but raises an errors when
--   presented with an empty list argument.
@url https://docs.daml.com/daml/stdlib/DA-Action.html#function-da-action-foldl1a-65193
foldl1A :: (Action m) => (a -> a -> m a) -> [a] -> m a

-- | Filters the list using the applicative function: keeps only the elements where the predicate holds.
--   Example: given a collection of Iou contract IDs one can find only the GBPs.
--   
--   ```
--   filterA (fmap (\iou -> iou.currency == "GBP") . fetch) iouCids
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Action.html#function-da-action-filtera-13011
filterA :: (Applicative m) => (a -> m Bool) -> [a] -> m [a]

-- | `replicateA n act` performs the action `n` times, gathering the
--   results.
@url https://docs.daml.com/daml/stdlib/DA-Action.html#function-da-action-replicatea-98867
replicateA :: (Applicative m) => Int -> m a -> m [a]

-- | Like `replicateA`, but discards the result.
@url https://docs.daml.com/daml/stdlib/DA-Action.html#function-da-action-replicatea-83733
replicateA_ :: (Applicative m) => Int -> m a -> m ()

-- | Left-to-right composition of Kleisli arrows.
@url https://docs.daml.com/daml/stdlib/DA-Action.html#function-da-action-gteqgt-60955
(>=>) :: (Action m) => (a -> m b) -> (b -> m c) -> a -> m c

-- | Right-to-left composition of Kleisli arrows. @('>=>')@, with the arguments
--   flipped.
@url https://docs.daml.com/daml/stdlib/DA-Action.html#function-da-action-lteqlt-31871
(<=<) :: (Action m) => (b -> m c) -> (a -> m b) -> a -> m c

-- | DA.Action.State
@url https://docs.daml.com/daml/stdlib/DA-Action-State.html#module-da-action-state-50232
module DA.Action.State

-- | A value of type `State s a` represents a computation that has access to a state variable
--   of type `s` and produces a value of type `a`.
--   
--   >>> runState (modify (+1)) 0
--   ((), 1)
--   
--   >>> evalState (modify (+1)) 0
--   ()
--   
--   >>> execState (modify (+1)) 0
--   1
--   
--   >>> runState (do x <- get; modify (+1); pure x) 0
--   (0, 1)
--   
--   >>> runState (put 1) 0
--   ((), 1)
--   
--   >>> runState (modify (+1)) 0
--   ((), 1)
--   
--   Note that values of type `State s a` are not serializable.
@url https://docs.daml.com/daml/stdlib/DA-Action-State.html#type-da-action-state-type-state-76783
data State s a

@url https://docs.daml.com/daml/stdlib/DA-Action-State.html#constr-da-action-state-type-state-26
State :: (s -> (a, s)) -> State

runState :: State -> s -> (a, s)

-- | Special case of `runState` that does not return the final state.
@url https://docs.daml.com/daml/stdlib/DA-Action-State.html#function-da-action-state-evalstate-95640
evalState :: State s a -> s -> a

-- | Special case of `runState` that does only retun the final state.
@url https://docs.daml.com/daml/stdlib/DA-Action-State.html#function-da-action-state-execstate-48251
execState :: State s a -> s -> s

-- | DA.Action.State.Class
@url https://docs.daml.com/daml/stdlib/DA-Action-State-Class.html#module-da-action-state-class-12696
module DA.Action.State.Class

-- | Action `m` has a state variable of type `s`.
--   
--   Rules:
--     * `get *> ma  =  ma`
--     * `ma <* get  =  ma`
--     * `put a >>= get   =  put a $> a`
--     * `put a *> put b  =  put b`
--     * `(,) <$> get <*> get  =  get <&> \a -> (a, a)`
--   
--   Informally, these rules mean it behaves like an ordinary assignable variable:
--   it doesn't magically change value by looking at it, if you put a value there
--   that's always the value you'll get if you read it, assigning a value but
--   never reading that value has no effect, and so on.
@url https://docs.daml.com/daml/stdlib/DA-Action-State-Class.html#class-da-action-state-class-actionstate-80467
class ActionState s m

-- | Fetch the current value of the state variable.
@url https://docs.daml.com/daml/stdlib/DA-Action-State-Class.html#function-da-action-state-class-get-54107
get :: (ActionState s m) => m s

-- | Set the value of the state variable.
@url https://docs.daml.com/daml/stdlib/DA-Action-State-Class.html#function-da-action-state-class-put-15832
put :: (ActionState s m) => s -> m ()

-- | Modify the state variable with the given function.
@url https://docs.daml.com/daml/stdlib/DA-Action-State-Class.html#function-da-action-state-class-modify-80630
modify :: (ActionState s m) => (s -> s) -> m ()

@url https://docs.daml.com/daml/stdlib/DA-Assert.html#module-da-assert-92761
module DA.Assert

-- | Check two values for equality. If they're not equal,
--   fail with a message.
@url https://docs.daml.com/daml/stdlib/DA-Assert.html#function-da-assert-asserteq-7135
assertEq :: (CanAssert m, Show a, Eq a) => a -> a -> m ()

-- | Infix version of `assertEq`.
@url https://docs.daml.com/daml/stdlib/DA-Assert.html#function-da-assert-eqeqeq-18699
(===) :: (CanAssert m, Show a, Eq a) => a -> a -> m ()

-- | Check two values for inequality. If they're equal,
--   fail with a message.
@url https://docs.daml.com/daml/stdlib/DA-Assert.html#function-da-assert-assertnoteq-28771
assertNotEq :: (CanAssert m, Show a, Eq a) => a -> a -> m ()

-- | Infix version of `assertNotEq`.
@url https://docs.daml.com/daml/stdlib/DA-Assert.html#function-da-assert-eqslasheq-37517
(=/=) :: (CanAssert m, Show a, Eq a) => a -> a -> m ()

-- | Check whether the given time is in the future. If it's not,
--   abort with a message.
@url https://docs.daml.com/daml/stdlib/DA-Assert.html#function-da-assert-assertaftermsg-14090
assertAfterMsg :: (CanAssert m, HasTime m) => Text -> Time -> m ()

-- | Check whether the given time is in the past. If it's not,
--   abort with a message.
@url https://docs.daml.com/daml/stdlib/DA-Assert.html#function-da-assert-assertbeforemsg-56514
assertBeforeMsg :: (CanAssert m, HasTime m) => Text -> Time -> m ()

-- | Check whether the ledger time of the transaction is strictly before the given deadline.
--   If it's not, abort with a message.
@url https://docs.daml.com/daml/stdlib/DA-Assert.html#function-da-assert-assertwithindeadline-85580
assertWithinDeadline :: Text -> Time -> Update ()

-- | Check whether the ledger time of the transaction is at or after the given deadline.
--   If it's not, abort with a message.
@url https://docs.daml.com/daml/stdlib/DA-Assert.html#function-da-assert-assertdeadlineexceeded-21600
assertDeadlineExceeded :: Text -> Time -> Update ()

@url https://docs.daml.com/daml/stdlib/DA-Bifunctor.html#module-da-bifunctor-44306
module DA.Bifunctor

-- | A bifunctor is a type constructor that takes
--   two type arguments and is a functor in *both* arguments. That
--   is, unlike with `Functor`, a type constructor such as `Either`
--   does not need to be partially applied for a `Bifunctor`
--   instance, and the methods in this class permit mapping
--   functions over the Left value or the `Right` value,
--   or both at the same time.
--   
--   It is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a `Bifunctor` by either defining bimap or by
--   defining both first and second.
--   
--   If you supply bimap, you should ensure that:
--   
--   ```daml-force
--   `bimap identity identity` ≡ `identity`
--   ```
--   
--   If you supply first and second, ensure:
--   
--   ```daml-force
--   first identity ≡ identity
--   second identity ≡ identity
--   
--   ```
--   
--   If you supply both, you should also ensure:
--   
--   ```daml-force
--   bimap f g ≡ first f . second g
--   ```
--   
--   By parametricity, these will ensure that:
--   
--   ```daml-force
--   
--   bimap  (f . g) (h . i) ≡ bimap f h . bimap g i
--   first  (f . g) ≡ first  f . first  g
--   second (f . g) ≡ second f . second g
--   
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Bifunctor.html#class-da-bifunctor-bifunctor-68312
class Bifunctor p

-- | Map over both arguments at the same time.
--   
--   ```daml-force
--   bimap f g ≡ first f . second g
--   ```
--   
--   Examples:
--   
--   ```
--   >>> bimap not (+1) (True, 3)
--   (False,4)
--   
--   >>> bimap not (+1) (Left True)
--   Left False
--   
--   >>> bimap not (+1) (Right 3)
--   Right 4
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Bifunctor.html#function-da-bifunctor-bimap-49864
bimap :: (Bifunctor p) => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   ```daml-force
--   first f ≡ bimap f identity
--   ```
--   
--   Examples:
--   
--   ```
--   >>> first not (True, 3)
--   (False,3)
--   
--   >>> first not (Left True : Either Bool Int)
--   Left False
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Bifunctor.html#function-da-bifunctor-first-18253
first :: (Bifunctor p) => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   ```daml-force
--   second ≡ bimap identity
--   ```
--   
--   Examples:
--   
--   ```
--   >>> second (+1) (True, 3)
--   (True,4)
--   
--   >>> second (+1) (Right 3 : Either Bool Int)
--   Right 4
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Bifunctor.html#function-da-bifunctor-second-99394
second :: (Bifunctor p) => (b -> c) -> p a b -> p a c

-- | WARNING: DA.Crypto.Text is an alpha feature. It can change without notice.
--   use -Wno-crypto-text-is-alpha in build-options to disable this warning
--   
--   Functions for working with Crypto builtins.
--   For example, as used to implement CCTP functionality.
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#module-da-crypto-text-67266
module DA.Crypto.Text

@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#type-da-crypto-text-byteshex-47880
type BytesHex = Text

-- | A DER formatted public key to be used for ECDSA signature verification
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#type-da-crypto-text-publickeyhex-51359
type PublicKeyHex = Text

-- | A DER formatted SECP256K1 signature
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#type-da-crypto-text-signaturehex-12945
type SignatureHex = Text

@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#class-da-crypto-text-hastohex-92431
class HasToHex a

-- | Converts a typed data value into a hex encoded string.
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-tohex-12193
toHex :: (HasToHex a) => a -> BytesHex

@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#class-da-crypto-text-hasfromhex-84972
class HasFromHex a

-- | Converts a hex encoded string into a typed data value.
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-fromhex-45182
fromHex :: (HasFromHex a) => BytesHex -> a

-- | `isHex` is `True` if `t` is not empty and consists only of
--   hex or hexadecimal characters.
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-ishex-17968
isHex :: Text -> Bool

-- | Computes the KECCAK256 hash of the UTF8 bytes of the `Text`, and returns it in its hex-encoded
--   form. The hex encoding uses lowercase letters.
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-keccak256-57106
keccak256 :: BytesHex -> BytesHex

-- | Validate the SECP256K1 signature given a hex encoded message and a hex encoded DER formatted public key.
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-secp256k1-38075
secp256k1 :: SignatureHex -> BytesHex -> PublicKeyHex -> Bool

@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-numericviastringtohex-44461
numericViaStringToHex :: (NumericScale n) => Numeric n -> BytesHex

@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-numericviastringfromhex-60098
numericViaStringFromHex :: (NumericScale n) => BytesHex -> Optional (Numeric n)

-- | Number of bytes present in a byte encoded string.
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-bytecount-29784
byteCount :: BytesHex -> Int

-- | Minimum Bytes32 hex value
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-minbytes32hex-29458
minBytes32Hex :: BytesHex

-- | Maximum Bytes32 hex value
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-maxbytes32hex-56560
maxBytes32Hex :: BytesHex

-- | Validate that the byte encoded string is Bytes32Hex
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-isbytes32hex-1801
isBytes32Hex :: BytesHex -> Bool

-- | Minimum UInt32 hex value
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-minuint32hex-58146
minUInt32Hex :: BytesHex

-- | Maximum UInt32 hex value
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-maxuint32hex-80016
maxUInt32Hex :: BytesHex

-- | Validate that the byte encoded string is UInt32Hex
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-isuint32hex-65583
isUInt32Hex :: BytesHex -> Bool

-- | Minimum UInt64 hex value
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-minuint64hex-67161
minUInt64Hex :: BytesHex

-- | Maximum UInt64 hex value
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-maxuint64hex-40555
maxUInt64Hex :: BytesHex

-- | Validate that the byte encoded string is UInt64Hex
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-isuint64hex-49912
isUInt64Hex :: BytesHex -> Bool

-- | Minimum UInt256 hex value
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-minuint256hex-23801
minUInt256Hex :: BytesHex

-- | Maximum UInt256 hex value
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-maxuint256hex-58651
maxUInt256Hex :: BytesHex

-- | Validate that the byte encoded string is UInt256Hex
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-isuint256hex-33362
isUInt256Hex :: BytesHex -> Bool

-- | Pack a byte encoded string to a given byte count size. If the byte string is shorter than the pad
--   size, then prefix with 00 byte strings. If the byte string is larger, then truncate the byte string.
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-packhexbytes-55939
packHexBytes :: BytesHex -> Int -> Optional BytesHex

-- | Extract the byte string starting at startByte up to, but excluding, endByte. Byte indexing starts at 1.
@url https://docs.daml.com/daml/stdlib/DA-Crypto-Text.html#function-da-crypto-text-slicehexbytes-22633
sliceHexBytes :: BytesHex -> Int -> Int -> Either Text BytesHex

-- | This module provides a set of functions to manipulate Date values.
--   The bounds for Date are 0001-01-01T00:00:00.000000Z and
--   9999-12-31T23:59:59.999999Z.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#module-da-date-80009
module DA.Date

@url https://docs.daml.com/daml/stdlib/DA-Date.html#type-da-date-types-dayofweek-18120
data DayOfWeek

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-monday-43349
Monday :: DayOfWeek

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-tuesday-5501
Tuesday :: DayOfWeek

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-wednesday-18786
Wednesday :: DayOfWeek

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-thursday-55301
Thursday :: DayOfWeek

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-friday-14884
Friday :: DayOfWeek

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-saturday-99714
Saturday :: DayOfWeek

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-sunday-48181
Sunday :: DayOfWeek

-- | The `Month` type represents a month in the Gregorian calendar.
--   
--   Note that, while `Month` has an `Enum` instance, the `toEnum` and `fromEnum`
--   functions start counting at 0, i.e. `toEnum 1 :: Month` is `Feb`.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#type-da-date-types-month-22803
data Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-jan-1103
Jan :: Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-feb-88523
Feb :: Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-mar-5472
Mar :: Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-apr-12091
Apr :: Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-may-50999
May :: Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-jun-17739
Jun :: Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-jul-21893
Jul :: Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-aug-18125
Aug :: Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-sep-63548
Sep :: Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-oct-96134
Oct :: Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-nov-72317
Nov :: Month

@url https://docs.daml.com/daml/stdlib/DA-Date.html#constr-da-date-types-dec-74760
Dec :: Month

-- | Add the given number of days to a date.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-adddays-7836
addDays :: Date -> Int -> Date

-- | Subtract the given number of days from a date.
--   
--   `subtractDays d r` is equivalent to `addDays d (- r)`.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-subtractdays-16626
subtractDays :: Date -> Int -> Date

-- | Returns the number of days between the two given dates.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-subdate-25598
subDate :: Date -> Date -> Int

-- | Returns the day of week for the given date.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-dayofweek-99931
dayOfWeek :: Date -> DayOfWeek

-- | Constructs a `Date` from the triplet `(year, month, days)`.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-fromgregorian-85346
fromGregorian :: (Int, Month, Int) -> Date

-- | Turn `Date` value into a `(year, month, day)` triple, according
--   to the Gregorian calendar.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-togregorian-84541
toGregorian :: Date -> (Int, Month, Int)

-- | Given the three values (year, month, day), constructs a `Date` value.
--   `date y m d` turns the year `y`, month `m`, and day `d` into a `Date` value.
--   Raises an error if `d` is outside the range `1 .. monthDayCount y m`.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-date-21355
date :: Int -> Month -> Int -> Date

-- | Returns `True` if the given year is a leap year.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-isleapyear-61920
isLeapYear :: Int -> Bool

-- | Get the number corresponding to given month. For example, `Jan` corresponds
--   to `1`, `Feb` corresponds to `2`, and so on.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-frommonth-90328
fromMonth :: Month -> Int

-- | Get number of days in the given month in the given year, according to Gregorian calendar.
--   This does not take historical calendar changes into account (for example, the
--   moves from Julian to Gregorian calendar), but does count leap years.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-monthdaycount-59295
monthDayCount :: Int -> Month -> Int

-- | Constructs an instant using `year`, `month`, `day`, `hours`, `minutes`, `seconds`.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-datetime-90284
datetime :: Int -> Month -> Int -> Int -> Int -> Int -> Time

-- | Extracts UTC date from UTC time.
--   
--   This function will truncate Time to Date, but in many cases it will not return the date you really want.
--   The reason for this is that usually the source of Time would be getTime, and getTime returns UTC, and most likely
--   the date you want is something local to a location or an exchange. Consequently the date retrieved this way would be
--   yesterday if retrieved when the market opens in say Singapore.
@url https://docs.daml.com/daml/stdlib/DA-Date.html#function-da-date-todateutc-87953
toDateUTC :: Time -> Date

-- | The `Either` type represents values with two possibilities.
--   
--   It is sometimes used to represent a value which is either correct
--   or an error. By convention, the `Left` constructor is used to hold
--   an error value and the `Right` constructor is used to hold a correct
--   value (mnemonic: "right" also means correct).
@url https://docs.daml.com/daml/stdlib/DA-Either.html#module-da-either-91022
module DA.Either

-- | Extracts all the `Left` elements from a list.
@url https://docs.daml.com/daml/stdlib/DA-Either.html#function-da-either-lefts-59601
lefts :: [Either a b] -> [a]

-- | Extracts all the `Right` elements from a list.
@url https://docs.daml.com/daml/stdlib/DA-Either.html#function-da-either-rights-20455
rights :: [Either a b] -> [b]

-- | Partitions a list of `Either` into two lists, the `Left` and
--   `Right` elements respectively. Order is maintained.
@url https://docs.daml.com/daml/stdlib/DA-Either.html#function-da-either-partitioneithers-19904
partitionEithers :: [Either a b] -> ([a], [b])

-- | Return `True` if the given value is a `Left`-value, `False`
--   otherwise.
@url https://docs.daml.com/daml/stdlib/DA-Either.html#function-da-either-isleft-96021
isLeft :: Either a b -> Bool

-- | Return `True` if the given value is a `Right`-value, `False`
--   otherwise.
@url https://docs.daml.com/daml/stdlib/DA-Either.html#function-da-either-isright-36975
isRight :: Either a b -> Bool

-- | Return the contents of a `Left`-value, or a default value
--   in case of a `Right`-value.
@url https://docs.daml.com/daml/stdlib/DA-Either.html#function-da-either-fromleft-63875
fromLeft :: a -> Either a b -> a

-- | Return the contents of a `Right`-value, or a default value
--   in case of a `Left`-value.
@url https://docs.daml.com/daml/stdlib/DA-Either.html#function-da-either-fromright-27657
fromRight :: b -> Either a b -> b

-- | Convert a `Optional` value to an `Either` value, using the supplied
--   parameter as the `Left` value if the `Optional` is `None`.
@url https://docs.daml.com/daml/stdlib/DA-Either.html#function-da-either-optionaltoeither-21876
optionalToEither :: a -> Optional b -> Either a b

-- | Convert an `Either` value to a `Optional`, dropping any value in
--   `Left`.
@url https://docs.daml.com/daml/stdlib/DA-Either.html#function-da-either-eithertooptional-89140
eitherToOptional :: Either a b -> Optional b

-- | DEPRECATED: Daml 1.2 compatibility helper, use 'optionalToEither' instead of 'maybeToEither'
@url https://docs.daml.com/daml/stdlib/DA-Either.html#function-da-either-maybetoeither-6635
maybeToEither :: a -> Optional b -> Either a b

-- | DEPRECATED: Daml 1.2 compatibility helper, use 'eitherToOptional' instead of 'eitherToMaybe'
@url https://docs.daml.com/daml/stdlib/DA-Either.html#function-da-either-eithertomaybe-94811
eitherToMaybe :: Either a b -> Optional b

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   Exception handling in Daml.
--   DEPRECATED: Use `failWithStatus` and `FailureStatus` over Daml Exceptions
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#module-da-exception-55791
module DA.Exception

-- | Exception typeclass. This should not be implemented directly,
--   instead, use the `exception` syntax.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#type-da-internal-exception-exception-4133
type Exception e = (HasThrow e, HasMessage e, HasToAnyException e, HasFromAnyException e)

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   Exception raised by an arithmetic operation, such as divide-by-zero or overflow.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#type-da-exception-arithmeticerror-arithmeticerror-68828
data ArithmeticError

@url https://docs.daml.com/daml/stdlib/DA-Exception.html#constr-da-exception-arithmeticerror-arithmeticerror-83141
ArithmeticError :: Text -> ArithmeticError

message :: ArithmeticError -> Text

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   Exception raised by assert functions in DA.Assert
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#type-da-exception-assertionfailed-assertionfailed-69740
data AssertionFailed

@url https://docs.daml.com/daml/stdlib/DA-Exception.html#constr-da-exception-assertionfailed-assertionfailed-2357
AssertionFailed :: Text -> AssertionFailed

message :: AssertionFailed -> Text

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   Exception raised by `error`.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#type-da-exception-generalerror-generalerror-5800
data GeneralError

@url https://docs.daml.com/daml/stdlib/DA-Exception.html#constr-da-exception-generalerror-generalerror-9293
GeneralError :: Text -> GeneralError

message :: GeneralError -> Text

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   Exception raised when a contract is invalid, i.e. fails the ensure clause.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#type-da-exception-preconditionfailed-preconditionfailed-61218
data PreconditionFailed

@url https://docs.daml.com/daml/stdlib/DA-Exception.html#constr-da-exception-preconditionfailed-preconditionfailed-18759
PreconditionFailed :: Text -> PreconditionFailed

message :: PreconditionFailed -> Text

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   Part of the `Exception` constraint.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#class-da-internal-exception-hasthrow-30284
class HasThrow e

-- | Throw exception in a pure context.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#function-da-internal-exception-throwpure-97636
throwPure :: (HasThrow e) => e -> t

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   Part of the `Exception` constraint.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#class-da-internal-exception-hasmessage-3179
class HasMessage e

-- | Get the error message associated with an exception.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#function-da-internal-exception-message-17317
message :: (HasMessage e) => e -> Text

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   Part of the `Exception` constraint.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#class-da-internal-exception-hastoanyexception-55973
class HasToAnyException e

-- | Convert an exception type to AnyException.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#function-da-internal-exception-toanyexception-88127
toAnyException :: (HasToAnyException e) => e -> AnyException

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   Part of the `Exception` constraint.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#class-da-internal-exception-hasfromanyexception-16788
class HasFromAnyException e

-- | Convert an AnyException back to the underlying exception type, if possible.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#function-da-internal-exception-fromanyexception-70766
fromAnyException :: (HasFromAnyException e) => AnyException -> Optional e

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   Action type in which `throw` is supported.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#class-da-internal-exception-actionthrow-37623
class (Action m) => ActionThrow m

@url https://docs.daml.com/daml/stdlib/DA-Exception.html#function-da-internal-exception-throw-28546
throw :: (ActionThrow m, Exception e) => e -> m t

-- | DEPRECATED: Exceptions are deprecated, prefer `failWithStatus`, and avoid using catch.
--   Use `-Wno-deprecated-exceptions` to disable this warning.
--   
--   Action type in which `try ... catch ...` is supported.
--   DEPRECATED: Avoid the use of catch in daml code, prefer error handling on client, and throwing using `failWithStatus`
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#class-da-internal-exception-actioncatch-69238
class (ActionThrow m) => ActionCatch m

-- | Handle an exception. Use the `try ... catch ...` syntax
--   instead of calling this method directly.
@url https://docs.daml.com/daml/stdlib/DA-Exception.html#function-da-internal-exception-trycatch-24973
_tryCatch :: (ActionCatch m) => (() -> m t) -> (AnyException -> Optional (m t)) -> m t

-- | Fail, for FailureStatus
@url https://docs.daml.com/daml/stdlib/DA-Fail.html#module-da-fail-58029
module DA.Fail

-- | The category of the failure, which determines the status code and log
--   level of the failure. Maps 1-1 to the Canton error categories documented
--   here: https://docs.daml.com/canton/reference/error_codes.html#error-categories-inventory
--   
--   If you are more familiar with gRPC error codes, you can use the synonyms referenced in the
--   comments.
@url https://docs.daml.com/daml/stdlib/DA-Fail.html#type-da-internal-fail-types-failurecategory-97811
data FailureCategory

-- | Use this to report errors that are independent of the current state of the ledger,
--   and should thus not be retried.
--   
--   Corresponds to the gRPC status code `INVALID_ARGUMENT`.
--   
--   See https://docs.daml.com/canton/reference/error_codes.html#invalidindependentofsystemstate
--   for more information.
@url https://docs.daml.com/daml/stdlib/DA-Fail.html#constr-da-internal-fail-types-invalidindependentofsystemstate-84432
InvalidIndependentOfSystemState :: FailureCategory

-- | Use this to report errors that are due to the current state of the ledger,
--   but might disappear if the ledger state changes. Clients should retry these
--   requests after reading updated state from the ledger.
--   
--   Corresponds to the gRPC status code `FAILED_PRECONDITION`.
--   
--   See https://docs.daml.com/canton/reference/error_codes.html#invalidgivencurrentsystemstateother
--   for more information.
@url https://docs.daml.com/daml/stdlib/DA-Fail.html#constr-da-internal-fail-types-invalidgivencurrentsystemstateother-6547
InvalidGivenCurrentSystemStateOther :: FailureCategory

@url https://docs.daml.com/daml/stdlib/DA-Fail.html#type-da-internal-fail-types-failurestatus-69615
data FailureStatus

@url https://docs.daml.com/daml/stdlib/DA-Fail.html#constr-da-internal-fail-types-failurestatus-61878
FailureStatus :: Text -> FailureCategory -> Text -> TextMap Text -> FailureStatus

-- | Unambiguous identifier of the error.
--   SHOULD be prefixed with the DNS name identifying the app provider
--   or the API standard defining the error. For example,
--   `splice.lfdecentralizedtrust.org/insufficient-funds` could be used for
--   reporting an out of funds error in the context of the CN token standards.
errorId :: FailureStatus -> Text

-- | Category of the failure, which determines how clients are expected to handle the error.
category :: FailureStatus -> FailureCategory

-- | Developer-facing error message, which should be in English.
message :: FailureStatus -> Text

-- | Machine-readable metadata about the error in a key-value format.
--   Use this to provide extra context to clients for errors.
--   
--   SHOULD be less than < 512 characters as it MAY be truncated otherwise.
meta :: FailureStatus -> TextMap Text

@url https://docs.daml.com/daml/stdlib/DA-Fail.html#class-da-internal-fail-actionfailwithstatus-58664
class (Action m) => ActionFailWithStatus m

-- | Fail with a failure status
@url https://docs.daml.com/daml/stdlib/DA-Fail.html#function-da-internal-fail-failwithstatus-67337
failWithStatus :: (ActionFailWithStatus m) => FailureStatus -> m a

-- | Alternative name for `InvalidIndependentOfSystemState`.
@url https://docs.daml.com/daml/stdlib/DA-Fail.html#function-da-fail-invalidargument-67588
invalidArgument :: FailureCategory

-- | Alternative name for `InvalidGivenCurrentSystemStateOther`.
@url https://docs.daml.com/daml/stdlib/DA-Fail.html#function-da-fail-failedprecondition-95960
failedPrecondition :: FailureCategory

-- | Fail with a failure status in a pure context
@url https://docs.daml.com/daml/stdlib/DA-Fail.html#function-da-internal-fail-failwithstatuspure-20043
failWithStatusPure :: FailureStatus -> a

-- | Class of data structures that can be folded to a summary value.
--   It's a good idea to import this module qualified to avoid clashes with
--   functions defined in `Prelude`. Ie.:
--   ```
--   import DA.Foldable qualified as F
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#module-da-foldable-94882
module DA.Foldable

-- | Class of data structures that can be folded to a summary value.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#class-da-foldable-foldable-25994
class Foldable t

-- | Combine the elements of a structure using a monoid.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-fold-64569
fold :: (Foldable t, Monoid m) => t m -> m

-- | Combine the elements of a structure using a monoid.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-foldmap-73376
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-foldr-33982
foldr :: (Foldable t) => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-foldl-16220
foldl :: (Foldable t) => (b -> a -> b) -> b -> t a -> b

-- | A variant of foldr that has no base case, and thus should only be applied to non-empty structures.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-foldr1-73556
foldr1 :: (Foldable t) => (a -> a -> a) -> t a -> a

-- | A variant of foldl that has no base case, and thus should only be applied to non-empty structures.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-foldl1-10610
foldl1 :: (Foldable t) => (a -> a -> a) -> t a -> a

-- | List of elements of a structure, from left to right.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-tolist-58625
toList :: (Foldable t) => t a -> [a]

-- | Test whether the structure is empty. The default implementation is optimized for structures that are similar to cons-lists, because there is no general way to do better.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-null-48579
null :: (Foldable t) => t a -> Bool

-- | Returns the size/length of a finite structure as an `Int`. The default implementation is optimized for structures that are similar to cons-lists, because there is no general way to do better.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-length-39462
length :: (Foldable t) => t a -> Int

-- | Does the element occur in the structure?
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-elem-30373
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The sum function computes the sum of the numbers of a structure.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-sum-87024
sum :: (Foldable t, Additive a) => t a -> a

-- | The product function computes the product of the numbers of a structure.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-product-30784
product :: (Foldable t, Multiplicative a) => t a -> a

-- | The least element of a non-empty structure.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-minimum-4521
minimum :: (Foldable t, Ord a) => t a -> a

-- | The largest element of a non-empty structure.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-maximum-18675
maximum :: (Foldable t, Ord a) => t a -> a

-- | Map each element of a structure to an action, evaluate these
--   actions from left to right, and ignore the results. For a version
--   that doesn't ignore the results see 'DA.Traversable.mapA'.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-mapa-78745
mapA_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | 'for_' is 'mapA_' with its arguments flipped. For a version
--   that doesn't ignore the results see 'DA.Traversable.forA'.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-fora-54422
forA_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | DEPRECATED: Daml compatibility helper, use 'forA_' instead of 'forM_'
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-form-34370
forM_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Evaluate each action in the structure from left to right,
--   and ignore the results. For a version that doesn't ignore the
--   results see 'DA.Traversable.sequence'.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-sequence-26917
sequence_ :: (Foldable t, Action m) => t (m a) -> m ()

-- | The concatenation of all the elements of a container of lists.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-concat-71538
concat :: (Foldable t) => t [a] -> [a]

-- | `and` returns the conjunction of a container of Bools. For the result to be `True`, the container must be finite; `False`, however, results from a `False` value finitely far from the left end.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-and-52214
and :: (Foldable t) => t Bool -> Bool

-- | `or` returns the disjunction of a container of Bools. For the result to be `False`, the container must be finite; `True`, however, results from a `True` value finitely far from the left end.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-or-15333
or :: (Foldable t) => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the predicate.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-any-93587
any :: (Foldable t) => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the predicate.
@url https://docs.daml.com/daml/stdlib/DA-Foldable.html#function-da-foldable-all-59560
all :: (Foldable t) => (a -> Bool) -> t a -> Bool

-- | The `Functor` class is used for types that can be mapped over.
@url https://docs.daml.com/daml/stdlib/DA-Functor.html#module-da-functor-63823
module DA.Functor

-- | Replace all locations in the input (on the left) with the given
--   value (on the right).
@url https://docs.daml.com/daml/stdlib/DA-Functor.html#function-da-functor-dollargt-48161
($>) :: (Functor f) => f a -> b -> f b

-- | Map a function over a functor. Given a value `as` and a function
--   `f`, `as <&> f` is `f <$> as`. That is, `<&>` is like `<$>` but the
--   arguments are in reverse order.
@url https://docs.daml.com/daml/stdlib/DA-Functor.html#function-da-functor-ltampgt-91298
(<&>) :: (Functor f) => f a -> (a -> b) -> f b

-- | Nested `<$>`.
@url https://docs.daml.com/daml/stdlib/DA-Functor.html#function-da-functor-ltdollardollargt-89503
(<$$>) :: (Functor f, Functor g) => (a -> b) -> g (f a) -> g (f b)

-- | Replace all the locations in the input with `()`.
@url https://docs.daml.com/daml/stdlib/DA-Functor.html#function-da-functor-void-91123
void :: (Functor f) => f a -> f ()

@url https://docs.daml.com/daml/stdlib/DA-Internal-Interface-AnyView.html#module-da-internal-interface-anyview-80474
module DA.Internal.Interface.AnyView

@url https://docs.daml.com/daml/stdlib/DA-Internal-Interface-AnyView.html#class-da-internal-interface-anyview-hasfromanyview-30108
class HasFromAnyView i v

@url https://docs.daml.com/daml/stdlib/DA-Internal-Interface-AnyView.html#function-da-internal-interface-anyview-fromanyview-10400
fromAnyView :: (HasTemplateTypeRep i, HasFromAnyView i v) => AnyView -> Optional v

@url https://docs.daml.com/daml/stdlib/DA-Internal-Interface-AnyView-Types.html#module-da-internal-interface-anyview-types-13315
module DA.Internal.Interface.AnyView.Types

-- | Existential contract key type that can wrap an arbitrary contract key.
@url https://docs.daml.com/daml/stdlib/DA-Internal-Interface-AnyView-Types.html#type-da-internal-interface-anyview-types-anyview-16883
data AnyView

@url https://docs.daml.com/daml/stdlib/DA-Internal-Interface-AnyView-Types.html#constr-da-internal-interface-anyview-types-anyview-58868
AnyView :: Any -> InterfaceTypeRep -> AnyView

getAnyView :: AnyView -> Any

getAnyViewInterfaceTypeRep :: AnyView -> InterfaceTypeRep

@url https://docs.daml.com/daml/stdlib/DA-Internal-Interface-AnyView-Types.html#type-da-internal-interface-anyview-types-interfacetyperep-5047
data InterfaceTypeRep

@url https://docs.daml.com/daml/stdlib/DA-Internal-Interface-AnyView-Types.html#constr-da-internal-interface-anyview-types-interfacetyperep-24802
InterfaceTypeRep :: TypeRep -> InterfaceTypeRep

getInterfaceTypeRep :: InterfaceTypeRep -> TypeRep

-- | List
@url https://docs.daml.com/daml/stdlib/DA-List.html#module-da-list-85985
module DA.List

-- | The `sort` function implements a stable sorting algorithm. It is
--   a special case of `sortBy`, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input (a stable sort).
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-sort-96399
sort :: (Ord a) => [a] -> [a]

-- | The `sortBy` function is the non-overloaded version of `sort`.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-sortby-71202
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | `minimumBy f xs` returns the first element `x` of `xs` for which `f x y`
--   is either `LT` or `EQ` for all other `y` in `xs`. `xs` must be non-empty.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-minimumby-84625
minimumBy :: (a -> a -> Ordering) -> [a] -> a

-- | `maximumBy f xs` returns the first element `x` of `xs` for which `f x y`
--   is either `GT` or `EQ` for all other `y` in `xs`. `xs` must be non-empty.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-maximumby-22187
maximumBy :: (a -> a -> Ordering) -> [a] -> a

-- | Sort a list by comparing the results of a key function applied to
--   each element. `sortOn f` is equivalent to `sortBy (comparing f)`,
--   but has the performance advantage of only evaluating `f` once for
--   each element in the input list. This is sometimes called the
--   decorate-sort-undecorate paradigm.
--   
--   Elements are arranged from from lowest to highest, keeping
--   duplicates in the order they appeared in the input.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-sorton-99758
sortOn :: (Ord k) => (a -> k) -> [a] -> [a]

-- | `minimumOn f xs` returns the first element `x` of `xs` for which `f x`
--   is smaller than or equal to any other `f y` for `y` in `xs`. `xs` must be
--   non-empty.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-minimumon-90785
minimumOn :: (Ord k) => (a -> k) -> [a] -> a

-- | `maximumOn f xs` returns the first element `x` of `xs` for which `f x`
--   is greater than or equal to any other `f y` for `y` in `xs`. `xs` must be
--   non-empty.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-maximumon-98335
maximumOn :: (Ord k) => (a -> k) -> [a] -> a

-- | Merge two sorted lists using into a single, sorted whole, allowing
--   the programmer to specify the comparison function.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-mergeby-31951
mergeBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a]

-- | Combine elements pairwise by means of a programmer supplied
--   function from two list inputs into a single list.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-combinepairs-8661
combinePairs :: (a -> a -> a) -> [a] -> [a]

-- | Fold a non-empty list in a balanced way. Balanced means that each
--   element has approximately the same depth in the operator
--   tree. Approximately the same depth means that the difference
--   between maximum and minimum depth is at most 1. The accumulation
--   operation must be associative and commutative in order to get the
--   same result as `foldl1` or `foldr1`.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-foldbalanced1-46720
foldBalanced1 :: (a -> a -> a) -> [a] -> a

-- | The 'group' function groups equal elements into sublists such
--   that the concatenation of the result is equal to the argument.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-group-62411
group :: (Eq a) => [a] -> [[a]]

-- | The 'groupBy' function is the non-overloaded version of 'group'.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-groupby-62666
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | Similar to 'group', except that the equality is done on an
--   extracted value.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-groupon-4918
groupOn :: (Eq k) => (a -> k) -> [a] -> [[a]]

-- | `dedup l` removes duplicate elements from a list. In particular,
--   it keeps only the first occurrence of each element. It is a
--   special case of `dedupBy`, which allows the programmer to supply
--   their own equality test.
--   `dedup` is called `nub` in Haskell.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-dedup-27230
dedup :: (Ord a) => [a] -> [a]

-- | A version of `dedup` with a custom predicate.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-dedupby-29335
dedupBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | A version of `dedup` where deduplication is done
--   after applyng function. Example use: `dedupOn (.employeeNo) employees`
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-dedupon-81495
dedupOn :: (Ord k) => (a -> k) -> [a] -> [a]

-- | The `dedupSort` function sorts and removes duplicate elements from a
--   list. In particular, it keeps only the first occurrence of each
--   element.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-dedupsort-78698
dedupSort :: (Ord a) => [a] -> [a]

-- | A version of `dedupSort` with a custom predicate.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-dedupsortby-97595
dedupSortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | Returns True if and only if there are no duplicate elements in the given list.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-unique-23008
unique :: (Ord a) => [a] -> Bool

-- | A version of `unique` with a custom predicate.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-uniqueby-86149
uniqueBy :: (a -> a -> Ordering) -> [a] -> Bool

-- | Returns True if and only if there are no duplicate elements in the given list
--   after applyng function. Example use: `assert $ uniqueOn (.employeeNo) employees`
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-uniqueon-39349
uniqueOn :: (Ord k) => (a -> k) -> [a] -> Bool

-- | Given a list and a replacement list, replaces each occurance of
--   the search list with the replacement list in the operation list.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-replace-72492
replace :: (Eq a) => [a] -> [a] -> [a] -> [a]

-- | Drops the given prefix from a list. It returns the original
--   sequence if the sequence doesn't start with the given prefix.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-dropprefix-26566
dropPrefix :: (Eq a) => [a] -> [a] -> [a]

-- | Drops the given suffix from a list. It returns the original
--   sequence if the sequence doesn't end with the given suffix.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-dropsuffix-41813
dropSuffix :: (Eq a) => [a] -> [a] -> [a]

-- | The `stripPrefix` function drops the given prefix from a list.
--   It returns `None` if the list did not start with the prefix
--   given, or `Some` the list after the prefix, if it does.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-stripprefix-65866
stripPrefix :: (Eq a) => [a] -> [a] -> Optional [a]

-- | Return the prefix of the second list if its suffix matches the
--   entire first list.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-stripsuffix-23153
stripSuffix :: (Eq a) => [a] -> [a] -> Optional [a]

-- | Return the string before and after the search string or `None`
--   if the search string is not found.
--   
--   ```
--   >>> stripInfix [0,0] [1,0,0,2,0,0,3]
--   Some ([1], [2,0,0,3])
--   
--   >>> stripInfix [0,0] [1,2,0,4,5]
--   None
--   ```
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-stripinfix-68205
stripInfix :: (Eq a) => [a] -> [a] -> Optional ([a], [a])

-- | The `isPrefixOf` function takes two lists and returns `True` if
--   and only if the first is a prefix of the second.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-isprefixof-27346
isPrefixOf :: (Eq a) => [a] -> [a] -> Bool

-- | The `isSuffixOf` function takes two lists and returns `True` if
--   and only if the first list is a suffix of the second.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-issuffixof-26645
isSuffixOf :: (Eq a) => [a] -> [a] -> Bool

-- | The `isInfixOf` function takes two lists and returns `True` if
--   and only if the first list is contained anywhere within the second.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-isinfixof-7159
isInfixOf :: (Eq a) => [a] -> [a] -> Bool

-- | The `mapAccumL` function combines the behaviours of `map` and
--   `foldl`; it applies a function to each element of a list, passing
--   an accumulating parameter from left to right, and returning a final
--   value of this accumulator together with the new list.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-mapaccuml-18387
mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])

-- | A generalisation of `map`, `mapWithIndex` takes a mapping
--   function that also depends on the element's index, and applies it to every
--   element in the sequence.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-mapwithindex-75685
mapWithIndex :: (Int -> a -> b) -> [a] -> [b]

-- | The `inits` function returns all initial segments of the argument,
--   shortest first.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-inits-75071
inits :: [a] -> [[a]]

-- | The `intersperse` function takes an element and a list and
--   "intersperses" that element between the elements of the list.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-intersperse-31314
intersperse :: a -> [a] -> [a]

-- | `intercalate` inserts the list `xs` in between the lists in `xss`
--   and concatenates the result.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-intercalate-85238
intercalate :: [a] -> [[a]] -> [a]

-- | The `tails` function returns all final segments of the argument,
--   longest first.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-tails-57647
tails :: [a] -> [[a]]

-- | A version of `dropWhile` operating from the end.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-dropwhileend-92606
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | A version of `takeWhile` operating from the end.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-takewhileend-40268
takeWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | The `transpose` function transposes the rows and columns of its
--   argument.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-transpose-84171
transpose :: [[a]] -> [[a]]

-- | Break, but from the end.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-breakend-41551
breakEnd :: (a -> Bool) -> [a] -> ([a], [a])

-- | Find the first instance of `needle` in `haystack`.
--   The first element of the returned tuple is the prefix of `haystack`
--   before `needle` is matched. The second is the remainder of
--   `haystack`, starting with the match.  If you want the remainder
--   *without* the match, use `stripInfix`.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-breakon-39026
breakOn :: (Eq a) => [a] -> [a] -> ([a], [a])

-- | Similar to `breakOn`, but searches from the end of the
--   string.
--   
--   The first element of the returned tuple is the prefix of `haystack`
--   up to and including the last match of `needle`.  The second is the
--   remainder of `haystack`, following the match.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-breakonend-30980
breakOnEnd :: (Eq a) => [a] -> [a] -> ([a], [a])

-- | A variant of `lines` with a custom test. In particular, if there
--   is a trailing separator it will be discarded.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-linesby-68954
linesBy :: (a -> Bool) -> [a] -> [[a]]

-- | A variant of `words` with a custom test. In particular, adjacent
--   separators are discarded, as are leading or trailing separators.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-wordsby-74460
wordsBy :: (a -> Bool) -> [a] -> [[a]]

-- | Extract the first element of a list, which must be non-empty.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-head-92101
head :: [a] -> a

-- | Extract the elements after the head of a list, which must be
--   non-empty.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-tail-16805
tail :: [a] -> [a]

-- | Extract the last element of a list, which must be finite and
--   non-empty.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-last-56071
last :: [a] -> a

-- | Return all the elements of a list except the last one. The list
--   must be non-empty.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-init-2389
init :: [a] -> [a]

-- | Left associative fold of a list that must be non-empty.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-foldl1-60813
foldl1 :: (a -> a -> a) -> [a] -> a

-- | Right associative fold of a list that must be non-empty.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-foldr1-23463
foldr1 :: (a -> a -> a) -> [a] -> a

-- | Apply some operation repeatedly, producing an element of output
--   and the remainder of the list.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-repeatedly-9930
repeatedly :: ([a] -> (b, [a])) -> [a] -> [b]

-- | Splits a list into chunks of length @n@.
--   @n@ must be strictly greater than zero.
--   The last chunk will be shorter than @n@ in case the length of the input is
--   not divisible by @n@.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-chunksof-64138
chunksOf :: Int -> [a] -> [[a]]

-- | `delete x` removes the first occurrence of `x` from its list argument.
--   For example,
--   
--   ```
--   > delete "a" ["b","a","n","a","n","a"]
--   ["b","n","a","n","a"]
--   ```
--   
--   It is a special case of 'deleteBy', which allows the programmer to
--   supply their own equality test.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-delete-22340
delete :: (Eq a) => a -> [a] -> [a]

-- | The 'deleteBy' function behaves like 'delete', but takes a
--   user-supplied equality predicate.
--   
--   ```
--   > deleteBy (<=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   ```
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-deleteby-50465
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The `\\` function is list difference (non-associative).
--   In the result of `xs \\ ys`, the first occurrence of each element of
--   `ys` in turn (if any) has been removed from `xs`.  Thus
--   
--   ```
--   (xs ++ ys) \\ xs == ys
--   ```
--   
--   Note this function is _O(n*m)_ given lists of size _n_ and _m_.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-x-54181
(\\) :: (Eq a) => [a] -> [a] -> [a]

-- | Produce a singleton list.
--   
--   ```
--   >>> singleton True
--   [True]
--   ```
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-singleton-17649
singleton :: a -> [a]

-- | List index (subscript) operator, starting from 0.
--   For example, `xs !! 2` returns the third element in `xs`.
--   Raises an error if the index is not suitable for the given list.
--   The function has complexity _O(n)_ where _n_ is the index given,
--   unlike in languages such as Java where array indexing is _O(1)_.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-bangbang-90127
(!!) :: [a] -> Int -> a

-- | Find index of element in given list.
--   Will return `None` if not found.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-elemindex-4965
elemIndex :: (Eq a) => a -> [a] -> Optional Int

-- | Find index, given predicate, of first matching element.
--   Will return `None` if not found.
@url https://docs.daml.com/daml/stdlib/DA-List.html#function-da-list-findindex-82181
findIndex :: (a -> Bool) -> [a] -> Optional Int

-- | Note: This is only supported in Daml-LF 1.11 or later.
--   
--   This module provides variants of other standard library
--   functions that are based on the builtin Daml-LF ordering rather
--   than user-defined ordering. This is the same order also used
--   by `DA.Map`.
--   
--   These functions are usually much more efficient than their
--   `Ord`-based counterparts.
--   
--   Note that the functions in this module still require `Ord`
--   constraints. This is purely to enforce that you don’t
--   pass in values that cannot be compared, e.g., functions. The
--   implementation of those instances is not used.
@url https://docs.daml.com/daml/stdlib/DA-List-BuiltinOrder.html#module-da-list-builtinorder-49213
module DA.List.BuiltinOrder

-- | `dedup l` removes duplicate elements from a list. In particular,
--   it keeps only the first occurrence of each element.
--   
--   `dedup` is stable so the elements in the output are ordered
--   by their first occurrence in the input. If you do not need
--   stability, consider using `dedupSort` which is more efficient.
--   
--   ```
--   >>> dedup [3, 1, 1, 3]
--   [3, 1]
--   ```
@url https://docs.daml.com/daml/stdlib/DA-List-BuiltinOrder.html#function-da-list-builtinorder-dedup-38418
dedup :: (Ord a) => [a] -> [a]

-- | A version of `dedup` where deduplication is done
--   after applying the given function. Example use: `dedupOn (.employeeNo) employees`.
--   
--   `dedupOn` is stable so the elements in the output are ordered
--   by their first occurrence in the input. If you do not need
--   stability, consider using `dedupOnSort` which is more efficient.
--   
--   ```
--   >>> dedupOn fst [(3, "a"), (1, "b"), (1, "c"), (3, "d")]
--   [(3, "a"), (1, "b")]
--   ```
@url https://docs.daml.com/daml/stdlib/DA-List-BuiltinOrder.html#function-da-list-builtinorder-dedupon-23739
dedupOn :: (Ord k) => (v -> k) -> [v] -> [v]

-- | `dedupSort` is a more efficient variant of `dedup`
--   that does not preserve the order of the input elements.
--   Instead the output will be sorted acoording to the builtin Daml-LF
--   ordering.
--   
--   ```
--   >>> dedupSort [3, 1, 1, 3]
--   [1, 3]
--   ```
@url https://docs.daml.com/daml/stdlib/DA-List-BuiltinOrder.html#function-da-list-builtinorder-dedupsort-5846
dedupSort :: (Ord a) => [a] -> [a]

-- | `dedupOnSort` is a more efficient variant of `dedupOn`
--   that does not preserve the order of the input elements.
--   Instead the output will be sorted on the values returned by the function.
--   
--   For duplicates, the first element in the list will be included in the output.
--   
--   ```
--   >>> dedupOnSort fst [(3, "a"), (1, "b"), (1, "c"), (3, "d")]
--   [(1, "b"), (3, "a")]
--   ```
@url https://docs.daml.com/daml/stdlib/DA-List-BuiltinOrder.html#function-da-list-builtinorder-deduponsort-69087
dedupOnSort :: (Ord k) => (v -> k) -> [v] -> [v]

-- | Sort the list according to the Daml-LF ordering.
--   
--   Values that are identical according to the builtin Daml-LF ordering
--   are indistinguishable so stability is not relevant here.
--   
--   ```
--   >>> sort [3,1,2]
--   [1,2,3]
--   ```
@url https://docs.daml.com/daml/stdlib/DA-List-BuiltinOrder.html#function-da-list-builtinorder-sort-65819
sort :: (Ord a) => [a] -> [a]

-- | `sortOn f` is a version of sort that allows sorting
--   on the result of the given function.
--   
--   `sortOn` is stable so elements that map to the same sort key
--   will be ordered by their position in the input.
--   
--   ```
--   >>> sortOn fst [(3, "a"), (1, "b"), (3, "c"), (2, "d")]
--   [(1, "b"), (2, "d"), (3, "a"), (3, "c")]
--   ```
@url https://docs.daml.com/daml/stdlib/DA-List-BuiltinOrder.html#function-da-list-builtinorder-sorton-7978
sortOn :: (Ord b) => (a -> b) -> [a] -> [a]

-- | Returns True if and only if there are no duplicate elements in the given list.
--   
--   ```
--   >>> unique [1, 2, 3]
--   True
--   ```
@url https://docs.daml.com/daml/stdlib/DA-List-BuiltinOrder.html#function-da-list-builtinorder-unique-2492
unique :: (Ord a) => [a] -> Bool

-- | Returns True if and only if there are no duplicate elements in the given list
--   after applyng function.
--   
--   ```
--   >>> uniqueOn fst [(1, 2), (2, 42), (1, 3)]
--   False
--   ```
@url https://docs.daml.com/daml/stdlib/DA-List-BuiltinOrder.html#function-da-list-builtinorder-uniqueon-93017
uniqueOn :: (Ord k) => (a -> k) -> [a] -> Bool

@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#module-da-list-total-99663
module DA.List.Total

-- | Return the first element of a list. Return `None` if list is empty.
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-head-26095
head :: [a] -> Optional a

-- | Return all but the first element of a list. Return `None` if list is empty.
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-tail-49055
tail :: [a] -> Optional [a]

-- | Extract the last element of a list. Returns `None` if list is empty.
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-last-22829
last :: [a] -> Optional a

-- | Return all the elements of a list except the last one. Returns `None` if list is empty.
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-init-12739
init :: [a] -> Optional [a]

-- | Return the nth element of a list. Return `None` if index is out of bounds.
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-bangbang-57917
(!!) :: [a] -> Int -> Optional a

-- | Fold left starting with the head of the list.
--   For example, `foldl1 f [a,b,c] = f (f a b) c`.
--   Return `None` if list is empty.
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-foldl1-27683
foldl1 :: (a -> a -> a) -> [a] -> Optional a

-- | Fold right starting with the last element of the list.
--   For example, `foldr1 f [a,b,c] = f a (f b c)`
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-foldr1-3777
foldr1 :: (a -> a -> a) -> [a] -> Optional a

-- | Fold a non-empty list in a balanced way. Balanced means that each
--   element has approximately the same depth in the operator
--   tree. Approximately the same depth means that the difference
--   between maximum and minimum depth is at most 1. The accumulation
--   operation must be associative and commutative in order to get the
--   same result as `foldl1` or `foldr1`.
--   
--   Return `None` if list is empty.
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-foldbalanced1-85298
foldBalanced1 :: (a -> a -> a) -> [a] -> Optional a

-- | Return the least element of a list according to the given comparison function.
--   Return `None` if list  is empty.
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-minimumby-50223
minimumBy :: (a -> a -> Ordering) -> [a] -> Optional a

-- | Return the greatest element of a list according to the given comparison function.
--   Return `None` if list is empty.
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-maximumby-35485
maximumBy :: (a -> a -> Ordering) -> [a] -> Optional a

-- | Return the least element of a list when comparing by a key function.
--   For example `minimumOn (\(x,y) -> x + y) [(1,2), (2,0)] == Some (2,0)`.
--   Return `None` if list is empty.
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-minimumon-58803
minimumOn :: (Ord k) => (a -> k) -> [a] -> Optional a

-- | Return the greatest element of a list when comparing by a key function.
--   For example `maximumOn (\(x,y) -> x + y) [(1,2), (2,0)] == Some (1,2)`.
--   Return `None` if list is empty.
@url https://docs.daml.com/daml/stdlib/DA-List-Total.html#function-da-list-total-maximumon-82285
maximumOn :: (Ord k) => (a -> k) -> [a] -> Optional a

-- | Logic -  Propositional calculus.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#module-da-logic-59184
module DA.Logic

-- | A `Formula t` is a formula in propositional calculus with
--   propositions of type t.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#type-da-logic-types-formula-34794
data Formula t

-- | `Proposition p` is the formula p
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#constr-da-logic-types-proposition-6173
Proposition :: t -> Formula

-- | For a formula f, `Negation f` is ¬f
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#constr-da-logic-types-negation-48969
Negation :: Formula t -> Formula

-- | For formulas f1, ..., fn, `Conjunction [f1, ..., fn]` is f1 ∧ ... ∧ fn
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#constr-da-logic-types-conjunction-51637
Conjunction :: [Formula t] -> Formula

-- | For formulas f1, ..., fn, `Disjunction [f1, ..., fn]` is f1 ∨ ... ∨ fn
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#constr-da-logic-types-disjunction-65549
Disjunction :: [Formula t] -> Formula

-- | `&&&` is the ∧ operation of the boolean algebra of formulas, to
--   be read as "and"
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-ampampamp-55265
(&&&) :: Formula t -> Formula t -> Formula t

-- | `|||` is the ∨ operation of the boolean algebra of formulas, to
--   be read as "or"
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-pipepipepipe-30747
(|||) :: Formula t -> Formula t -> Formula t

-- | `true` is the 1 element of the boolean algebra of formulas,
--   represented as an empty conjunction.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-true-31438
true :: Formula t

-- | `false` is the 0 element of the boolean algebra of formulas,
--   represented as an empty disjunction.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-false-99028
false :: Formula t

-- | `neg` is the ¬ (negation) operation of the boolean algebra of
--   formulas.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-neg-1597
neg :: Formula t -> Formula t

-- | `conj` is a list version of `&&&`, enabled by the associativity
--   of ∧.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-conj-82504
conj :: [Formula t] -> Formula t

-- | `disj` is a list version of `|||`, enabled by the associativity
--   of ∨.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-disj-92448
disj :: [Formula t] -> Formula t

-- | `fromBool` converts `True` to `true` and `False` to `false`.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-frombool-36630
fromBool :: Bool -> Formula t

-- | `toNNF` transforms a formula to negation normal form
--   (see https://en.wikipedia.org/wiki/Negation_normal_form).
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-tonnf-87354
toNNF :: Formula t -> Formula t

-- | `toDNF` turns a formula into disjunctive normal form.
--   (see https://en.wikipedia.org/wiki/Disjunctive_normal_form).
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-todnf-90852
toDNF :: Formula t -> Formula t

-- | An implementation of `traverse` in the usual sense.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-traverse-17816
traverse :: (Applicative f) => (t -> f s) -> Formula t -> f (Formula s)

-- | `zipFormulas` takes to formulas of same shape, meaning only
--   propositions are different and zips them up.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-zipformulas-28999
zipFormulas :: Formula t -> Formula s -> Formula (t, s)

-- | `substitute` takes a truth assignment and substitutes `True` or
--   `False` into the respective places in a formula.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-substitute-65872
substitute :: (t -> Optional Bool) -> Formula t -> Formula t

-- | `reduce` reduces a formula as far as possible by:
--   1. Removing any occurrences of `true` and `false`;
--   2. Removing directly nested Conjunctions and Disjunctions;
--   3. Going to negation normal form.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-reduce-40218
reduce :: Formula t -> Formula t

-- | `isBool` attempts to convert a formula to a bool. It satisfies
--   `isBool true == Some True` and `isBool false == Some False`.
--   Otherwise, it returns `None`.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-isbool-80820
isBool :: Formula t -> Optional Bool

-- | `interpret` is a version of `toBool` that first substitutes using
--   a truth function and then reduces as far as possible.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-interpret-88386
interpret :: (t -> Optional Bool) -> Formula t -> Either (Formula t) Bool

-- | `substituteA` is a version of `substitute` that allows for truth
--   values to be obtained from an action.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-substitutea-61566
substituteA :: (Applicative f) => (t -> f (Optional Bool)) -> Formula t -> f (Formula t)

-- | `interpretA` is a version of `interpret` that allows for truth
--   values to be obtained form an action.
@url https://docs.daml.com/daml/stdlib/DA-Logic.html#function-da-logic-interpreta-14928
interpretA :: (Applicative f) => (t -> f (Optional Bool)) -> Formula t -> f (Either (Formula t) Bool)

-- | Note: This is only supported in Daml-LF 1.11 or later.
--   
--   This module exports the generic map type `Map k v` and associated
--   functions. This module should be imported qualified, for example:
--   
--   ```
--   import DA.Map (Map)
--   import DA.Map qualified as M
--   ```
--   
--   This will give access to the `Map` type, and the various operations
--   as `M.lookup`, `M.insert`, `M.fromList`, etc.
--   
--   `Map k v` internally uses the built-in order for the type `k`.
--   This means that keys that contain functions are not comparable
--   and will result in runtime errors. To prevent this, the `Ord k`
--   instance is required for most map operations. It is recommended to
--   only use `Map k v` for key types that have an `Ord k` instance
--   that is derived automatically using `deriving`:
--   
--   ```
--   data K = ...
--     deriving (Eq, Ord)
--   ```
--   
--   This includes all built-in types that aren't function types, such as
--   `Int`, `Text`, `Bool`, `(a, b)` assuming `a` and `b` have default
--   `Ord` instances, `Optional t` and `[t]` assuming `t` has a
--   default `Ord` instance, `Map k v` assuming `k` and `v` have
--   default `Ord` instances, and `Set k` assuming `k` has a
--   default `Ord` instance.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#module-da-map-69618
module DA.Map

-- | Create a map from a list of key/value pairs.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-fromlist-23400
fromList :: (Ord k) => [(k, v)] -> Map k v

-- | Create a map from a list of key/value pairs with a combining
--   function. The combining function is only used when a key appears multiple
--   times in the list and it takes two arguments: the first one is the new value
--   being inserted at that key and the second one is the value accumulated so
--   far at that key.
--   Examples:
--   
--   ```
--   >>> fromListWithL (++) [("A", [1]), ("A", [2]), ("B", [2]), ("B", [1]), ("A", [3])]
--   fromList [("A", [3, 2, 1]), ("B", [1, 2])]
--   >>> fromListWithL (++) [] == (empty : Map Text [Int])
--   True
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-fromlistwithl-71603
fromListWithL :: (Ord k) => (v -> v -> v) -> [(k, v)] -> Map k v

-- | Create a map from a list of key/value pairs like `fromListWithL`
--   with the combining function flipped. Examples:
--   
--   ```
--   >>> fromListWithR (++) [("A", [1]), ("A", [2]), ("B", [2]), ("B", [1]), ("A", [3])]
--   fromList [("A", [1, 2, 3]), ("B", [2, 1])]
--   >>> fromListWithR (++) [] == (empty : Map Text [Int])
--   True
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-fromlistwithr-67193
fromListWithR :: (Ord k) => (v -> v -> v) -> [(k, v)] -> Map k v

-- | DEPRECATED: Daml compatibility helper, use 'fromListWithR' instead of 'fromListWith'
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-fromlistwith-28620
fromListWith :: (Ord k) => (v -> v -> v) -> [(k, v)] -> Map k v

-- | Get the list of keys in the map. Keys are sorted according to the
--   built-in order for the type `k`, which matches the `Ord k` instance
--   when using `deriving Ord`.
--   
--   ```
--   >>> keys (fromList [("A", 1), ("C", 3), ("B", 2)])
--   ["A", "B", "C"]
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-keys-97544
keys :: Map k v -> [k]

-- | Get the list of values in the map. These will be in the same order as
--   their respective keys from `M.keys`.
--   
--   ```
--   >>> values (fromList [("A", 1), ("B", 2)])
--   [1, 2]
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-values-1656
values :: Map k v -> [v]

-- | Convert the map to a list of key/value pairs. These will be ordered
--   by key, as in `M.keys`.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-tolist-88193
toList :: Map k v -> [(k, v)]

-- | The empty map.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-empty-15540
empty :: Map k v

-- | Number of elements in the map.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-size-29495
size :: Map k v -> Int

-- | Is the map empty?
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-null-81379
null :: Map k v -> Bool

-- | Lookup the value at a key in the map.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-lookup-19256
lookup :: (Ord k) => k -> Map k v -> Optional v

-- | Is the key a member of the map?
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-member-48452
member :: (Ord k) => k -> Map k v -> Bool

-- | Filter the `Map` using a predicate: keep only the entries where the
--   value satisfies the predicate.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-filter-60004
filter :: (Ord k) => (v -> Bool) -> Map k v -> Map k v

-- | Filter the `Map` using a predicate: keep only the entries which
--   satisfy the predicate.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-filterwithkey-3168
filterWithKey :: (Ord k) => (k -> v -> Bool) -> Map k v -> Map k v

-- | Delete a key and its value from the map. When the key is not a
--   member of the map, the original map is returned.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-delete-97567
delete :: (Ord k) => k -> Map k v -> Map k v

-- | Create a singleton map.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-singleton-98784
singleton :: (Ord k) => k -> v -> Map k v

-- | Insert a new key/value pair in the map. If the key is already
--   present in the map, the associated value is replaced with the
--   supplied value.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-insert-53601
insert :: (Ord k) => k -> v -> Map k v -> Map k v

-- | Insert a new key/value pair in the map. If the key is already
--   present in the map, it is combined with the previous value using the given function
--   `f new_value old_value`.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-insertwith-32465
insertWith :: (Ord k) => (v -> v -> v) -> k -> v -> Map k v -> Map k v

-- | Update the value in `m` at `k` with `f`, inserting or deleting as
--   required.  `f` will be called with either the value at `k`, or `None`
--   if absent; `f` can return `Some` with a new value to be inserted in
--   `m` (replacing the old value if there was one), or `None` to remove
--   any `k` association `m` may have.
--   
--   Some implications of this behavior:
--   
--     alter identity k = identity
--     alter g k . alter f k = alter (g . f) k
--     alter (\_ -> Some v) k = insert k v
--     alter (\_ -> None) = delete
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-alter-84047
alter :: (Ord k) => (Optional v -> Optional v) -> k -> Map k v -> Map k v

-- | The union of two maps, preferring the first map when equal
--   keys are encountered.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-union-90078
union :: (Ord k) => Map k v -> Map k v -> Map k v

-- | The union of two maps using the combining function to merge values that
--   exist in both maps.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-unionwith-55674
unionWith :: (Ord k) => (v -> v -> v) -> Map k v -> Map k v -> Map k v

-- | Combine two maps, using separate functions based on whether
--   a key appears only in the first map, only in the second map,
--   or appears in both maps.
@url https://docs.daml.com/daml/stdlib/DA-Map.html#function-da-map-merge-46179
merge :: (Ord k) => (k -> a -> Optional c) -> (k -> b -> Optional c) -> (k -> a -> b -> Optional c) -> Map k a -> Map k b -> Map k c

-- | Math - Utility Math functions for `Decimal`
--   The this library is designed to give good precision, typically giving 9 correct decimal places.
--   The numerical algorithms run with many iterations to achieve that precision and are interpreted
--   by the Daml runtime so they are not performant. Their use is not advised in performance critical
--   contexts.
@url https://docs.daml.com/daml/stdlib/DA-Math.html#module-da-math-30023
module DA.Math

-- | Take a power of a number Example: `2.0 ** 3.0 == 8.0`.
@url https://docs.daml.com/daml/stdlib/DA-Math.html#function-da-math-starstar-89123
(**) :: Decimal -> Decimal -> Decimal

-- | Calculate the square root of a Decimal.
--   
--   ```
--   >>> sqrt 1.44
--   1.2
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Math.html#function-da-math-sqrt-24467
sqrt :: Decimal -> Decimal

-- | The exponential function. Example: `exp 0.0 == 1.0`
@url https://docs.daml.com/daml/stdlib/DA-Math.html#function-da-math-exp-84235
exp :: Decimal -> Decimal

-- | The natural logarithm. Example: `log 10.0 == 2.30258509299`
@url https://docs.daml.com/daml/stdlib/DA-Math.html#function-da-math-log-52192
log :: Decimal -> Decimal

-- | The logarithm of a number to a given base. Example: `log 10.0 100.0 == 2.0`
@url https://docs.daml.com/daml/stdlib/DA-Math.html#function-da-math-logbase-64267
logBase :: Decimal -> Decimal -> Decimal

-- | `sin` is the sine function
@url https://docs.daml.com/daml/stdlib/DA-Math.html#function-da-math-sin-61636
sin :: Decimal -> Decimal

-- | `cos` is the cosine function
@url https://docs.daml.com/daml/stdlib/DA-Math.html#function-da-math-cos-82859
cos :: Decimal -> Decimal

-- | `tan` is the tangent function
@url https://docs.daml.com/daml/stdlib/DA-Math.html#function-da-math-tan-54959
tan :: Decimal -> Decimal

@url https://docs.daml.com/daml/stdlib/DA-Monoid.html#module-da-monoid-95505
module DA.Monoid

-- | Boolean monoid under conjunction (&&)
@url https://docs.daml.com/daml/stdlib/DA-Monoid.html#type-da-monoid-types-all-38142
data All

@url https://docs.daml.com/daml/stdlib/DA-Monoid.html#constr-da-monoid-types-all-18981
All :: Bool -> All

getAll :: All -> Bool

-- | Boolean Monoid under disjunction (||)
@url https://docs.daml.com/daml/stdlib/DA-Monoid.html#type-da-monoid-types-any-3989
data Any

@url https://docs.daml.com/daml/stdlib/DA-Monoid.html#constr-da-monoid-types-any-54474
Any :: Bool -> Any

getAny :: Any -> Bool

-- | The monoid of endomorphisms under composition.
@url https://docs.daml.com/daml/stdlib/DA-Monoid.html#type-da-monoid-types-endo-95420
data Endo a

@url https://docs.daml.com/daml/stdlib/DA-Monoid.html#constr-da-monoid-types-endo-7873
Endo :: (a -> a) -> Endo

appEndo :: Endo -> a -> a

-- | Monoid under (*)
--   
--   ```
--   > Product 2 <> Product 3
--   Product 6
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Monoid.html#type-da-monoid-types-product-66754
data Product a

@url https://docs.daml.com/daml/stdlib/DA-Monoid.html#constr-da-monoid-types-product-4241
Product :: a -> Product

-- | Monoid under (+)
--   
--   ```
--   > Sum 1 <> Sum 2
--   Sum 3
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Monoid.html#type-da-monoid-types-sum-76394
data Sum a

@url https://docs.daml.com/daml/stdlib/DA-Monoid.html#constr-da-monoid-types-sum-82289
Sum :: a -> Sum

-- | Type and functions for non-empty lists. This module re-exports many functions with
--   the same name as prelude list functions, so it is expected to import the module qualified.
--   For example, with the following import list you will have access to the `NonEmpty` type
--   and any functions on non-empty lists will be qualified, for example as `NE.append, NE.map, NE.foldl`:
--   
--   ```
--   import DA.NonEmpty (NonEmpty)
--   import qualified DA.NonEmpty as NE
--   ```
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#module-da-nonempty-15701
module DA.NonEmpty

-- | Prepend an element to a non-empty list.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-cons-63704
cons :: a -> NonEmpty a -> NonEmpty a

-- | Append or concatenate two non-empty lists.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-append-34337
append :: NonEmpty a -> NonEmpty a -> NonEmpty a

-- | Apply a function over each element in the non-empty list.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-map-69362
map :: (a -> b) -> NonEmpty a -> NonEmpty b

-- | Turn a list into a non-empty list, if possible. Returns
--   `None` if the input list is empty, and `Some` otherwise.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-nonempty-24939
nonEmpty :: [a] -> Optional (NonEmpty a)

-- | A non-empty list with a single element.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-singleton-99101
singleton :: a -> NonEmpty a

-- | Turn a non-empty list into a list (by forgetting that it is not empty).
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-tolist-15474
toList :: NonEmpty a -> [a]

-- | Reverse a non-empty list.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-reverse-64050
reverse :: NonEmpty a -> NonEmpty a

-- | Find an element in a non-empty list.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-find-73910
find :: (a -> Bool) -> NonEmpty a -> Optional a

-- | The 'deleteBy' function behaves like 'delete', but takes a
--   user-supplied equality predicate.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-deleteby-6333
deleteBy :: (a -> a -> Bool) -> a -> NonEmpty a -> [a]

-- | Remove the first occurence of x from the non-empty list, potentially
--   removing all elements.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-delete-59160
delete :: (Eq a) => a -> NonEmpty a -> [a]

-- | Apply a function repeatedly to pairs of elements from a non-empty list,
--   from the left. For example, `foldl1 (+) (NonEmpty 1 [2,3,4]) = ((1 + 2) + 3) + 4`.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-foldl1-17561
foldl1 :: (a -> a -> a) -> NonEmpty a -> a

-- | Apply a function repeatedly to pairs of elements from a non-empty list,
--   from the right. For example, `foldr1 (+) (NonEmpty 1 [2,3,4]) = 1 + (2 + (3 + 4))`.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-foldr1-43627
foldr1 :: (a -> a -> a) -> NonEmpty a -> a

-- | Apply a function repeatedly to pairs of elements from a non-empty list,
--   from the right, with a given initial value. For example,
--   `foldr (+) 0 (NonEmpty 1 [2,3,4]) = 1 + (2 + (3 + (4 + 0)))`.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-foldr-65043
foldr :: (a -> b -> b) -> b -> NonEmpty a -> b

-- | The same as `foldr` but running an action each time.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-foldra-91227
foldrA :: (Action m) => (a -> b -> m b) -> b -> NonEmpty a -> m b

-- | The same as `foldr1` but running an action each time.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-foldr1a-13463
foldr1A :: (Action m) => (a -> a -> m a) -> NonEmpty a -> m a

-- | Apply a function repeatedly to pairs of elements from a non-empty list,
--   from the left, with a given initial value. For example,
--   `foldl (+) 0 (NonEmpty 1 [2,3,4]) = (((0 + 1) + 2) + 3) + 4`.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-foldl-91113
foldl :: (b -> a -> b) -> b -> NonEmpty a -> b

-- | The same as `foldl` but running an action each time.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-foldla-69961
foldlA :: (Action m) => (b -> a -> m b) -> b -> NonEmpty a -> m b

-- | The same as `foldl1` but running an action each time.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty.html#function-da-nonempty-foldl1a-63665
foldl1A :: (Action m) => (a -> a -> m a) -> NonEmpty a -> m a

-- | This module contains the type for non-empty lists so we can give it a stable package id.
--   This is reexported from DA.NonEmpty so you should never need to import this module.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty-Types.html#module-da-nonempty-types-38464
module DA.NonEmpty.Types

-- | `NonEmpty` is the type of non-empty lists. In other words, it is the type of lists
--   that always contain at least one element. If `x` is a non-empty list, you can obtain
--   the first element with `x.hd` and the rest of the list with `x.tl`.
@url https://docs.daml.com/daml/stdlib/DA-NonEmpty-Types.html#type-da-nonempty-types-nonempty-16010
data NonEmpty a

@url https://docs.daml.com/daml/stdlib/DA-NonEmpty-Types.html#constr-da-nonempty-types-nonempty-68983
NonEmpty :: a -> [a] -> NonEmpty

hd :: NonEmpty -> a

tl :: NonEmpty -> [a]

@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#module-da-numeric-17471
module DA.Numeric

-- | Rounding modes.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#type-da-numeric-roundingmode-53864
data RoundingMode

-- | Round away from zero.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#constr-da-numeric-roundingup-99831
RoundingUp :: RoundingMode

-- | Round towards zero.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#constr-da-numeric-roundingdown-63242
RoundingDown :: RoundingMode

-- | Round towards positive infinity.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#constr-da-numeric-roundingceiling-67218
RoundingCeiling :: RoundingMode

-- | Round towards negative infinity.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#constr-da-numeric-roundingfloor-71675
RoundingFloor :: RoundingMode

-- | Round towards the nearest neighbor unless both neighbors
--   are equidistant, in which case round away from zero.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#constr-da-numeric-roundinghalfup-22532
RoundingHalfUp :: RoundingMode

-- | Round towards the nearest neighbor unless both neighbors
--   are equidistant, in which case round towards zero.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#constr-da-numeric-roundinghalfdown-91305
RoundingHalfDown :: RoundingMode

-- | Round towards the nearest neighbor unless both neighbors
--   are equidistant, in which case round towards the even neighbor.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#constr-da-numeric-roundinghalfeven-70729
RoundingHalfEven :: RoundingMode

-- | Do not round. Raises an error if the result cannot
--   be represented without rounding at the targeted scale.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#constr-da-numeric-roundingunnecessary-42017
RoundingUnnecessary :: RoundingMode

-- | Multiply two numerics. Both inputs and the output may have
--   different scales, unlike `(*)` which forces all numeric scales
--   to be the same. Raises an error on overflow, rounds to chosen
--   scale otherwise.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#function-da-numeric-mul-81896
mul :: (NumericScale n3) => Numeric n1 -> Numeric n2 -> Numeric n3

-- | Divide two numerics. Both inputs and the output may have
--   different scales, unlike `(/)` which forces all numeric scales
--   to be the same. Raises an error on overflow, rounds to chosen
--   scale otherwise.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#function-da-numeric-div-56407
div :: (NumericScale n3) => Numeric n1 -> Numeric n2 -> Numeric n3

-- | Cast a Numeric. Raises an error on overflow or loss of precision.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#function-da-numeric-cast-54256
cast :: (NumericScale n2) => Numeric n1 -> Numeric n2

-- | Cast a Numeric. Raises an error on overflow, rounds to chosen
--   scale otherwise.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#function-da-numeric-castandround-59941
castAndRound :: (NumericScale n2) => Numeric n1 -> Numeric n2

-- | Move the decimal point left or right by multiplying the numeric
--   value by 10^(n1 - n2). Does not overflow or underflow.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#function-da-numeric-shift-13796
shift :: (NumericScale n2) => Numeric n1 -> Numeric n2

-- | The number pi.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#function-da-numeric-pi-88702
pi :: (NumericScale n) => Numeric n

-- | The minimum strictly positive value that can be represented by a numeric of scale `n`.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#function-da-numeric-epsilon-3092
epsilon :: (NumericScale n) => Numeric n

-- | Round a `Numeric` number. The value of `round n r a` is the value
--   of `a` rounded to `n` decimal places (i.e. scale), according to the rounding
--   mode `r`.
--   
--   This will fail when using the `RoundingUnnecessary` mode for a number that cannot
--   be represented exactly with at most `n` decimal places.
@url https://docs.daml.com/daml/stdlib/DA-Numeric.html#function-da-numeric-roundnumeric-41344
roundNumeric :: (NumericScale n) => Int -> RoundingMode -> Numeric n -> Numeric n

-- | The `Optional` type encapsulates an optional value. A value of type
--   `Optional a` either contains a value of type `a` (represented as `Some a`),
--   or it is empty (represented as `None`). Using `Optional` is a good way
--   to deal with errors or exceptional cases without resorting to
--   drastic measures such as error.
--   
--   The Optional type is also an action. It is a simple kind of error
--   action, where all errors are represented by `None`. A richer
--   error action can be built using the `Either` type.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#module-da-optional-38505
module DA.Optional

-- | The `fromSome` function extracts the element out of a `Some` and
--   throws an error if its argument is `None`.
--   
--   Note that in most cases you should prefer using `fromSomeNote`
--   to get a better error on failures.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#function-da-optional-fromsome-59859
fromSome :: Optional a -> a

-- | Like `fromSome` but with a custom error message.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#function-da-optional-fromsomenote-25463
fromSomeNote :: Text -> Optional a -> a

-- | The `catOptionals` function takes a list of `Optionals` and returns a
--   list of all the `Some` values.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#function-da-optional-catoptionals-11568
catOptionals :: [Optional a] -> [a]

-- | The `listToOptional` function returns `None` on an empty list or
--   `Some` a where a is the first element of the list.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#function-da-optional-listtooptional-83598
listToOptional :: [a] -> Optional a

-- | The `optionalToList` function returns an empty list when given
--   `None` or a singleton list when not given `None`.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#function-da-optional-optionaltolist-83426
optionalToList :: Optional a -> [a]

-- | The `fromOptional` function takes a default value and a `Optional`
--   value. If the `Optional` is `None`, it returns the default values
--   otherwise, it returns the value contained in the `Optional`.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#function-da-optional-fromoptional-77879
fromOptional :: a -> Optional a -> a

-- | The `isSome` function returns `True` iff its argument is of the
--   form `Some _`.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#function-da-optional-issome-25261
isSome :: Optional a -> Bool

-- | The `isNone` function returns `True` iff its argument is
--   `None`.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#function-da-optional-isnone-84783
isNone :: Optional a -> Bool

-- | The `mapOptional` function is a version of `map` which can throw out
--   elements. In particular, the functional argument returns something
--   of type `Optional b`. If this is `None`, no element is added on to
--   the result list. If it is `Some b`, then `b` is included in the
--   result list.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#function-da-optional-mapoptional-4330
mapOptional :: (a -> Optional b) -> [a] -> [b]

-- | Perform some operation on `Some`, given the field inside the
--   `Some`.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#function-da-optional-whensome-82167
whenSome :: (Applicative m) => Optional a -> (a -> m ()) -> m ()

-- | The `findOptional` returns the value of the predicate at the first
--   element where it returns `Some`. `findOptional` is similar to `find` but it
--   allows you to return a value from the predicate. This is useful both as a more
--   type safe version if the predicate corresponds to a pattern match
--   and for performance to avoid duplicating work performed in the predicate.
@url https://docs.daml.com/daml/stdlib/DA-Optional.html#function-da-optional-findoptional-83634
findOptional :: (a -> Optional b) -> [a] -> Optional b

-- | Exports the record machinery necessary to allow one to annotate
--   code that is polymorphic in the underlying record type.
@url https://docs.daml.com/daml/stdlib/DA-Record.html#module-da-record-78710
module DA.Record

-- | `HasField` is a class synonym for `GetField` and `SetField`, which
--   respectively give you getter and setter functions for each record field
--   automatically.
--   
--   **In the vast majority of use-cases, plain Record syntax should be
--   preferred**:
--   
--   ```
--   daml> let a = MyRecord 1 "hello"
--   daml> a.foo
--   1
--   daml> a.bar
--   "hello"
--   daml> a { bar = "bye" }
--   MyRecord {foo = 1, bar = "bye"}
--   daml> a with foo = 3
--   MyRecord {foo = 3, bar = "hello"}
--   daml>
--   ```
--   
--   For more on Record syntax, see https://docs.daml.com/daml/intro/3_Data.html#record.
--   
--   `GetField x r a` and `SetField x r a` are typeclasses taking three parameters. The first
--   parameter `x` is the field name, the second parameter `r` is the record type,
--   and the last parameter `a` is the type of the field in this record. For
--   example, if we define a type:
--   
--   ```
--   data MyRecord = MyRecord with
--       foo : Int
--       bar : Text
--   ```
--   
--   Then we get, for free, the following GetField and SetField instances:
--   
--   ```
--   GetField "foo" MyRecord Int
--   SetField "foo" MyRecord Int
--   GetField "bar" MyRecord Text
--   SetField "bar" MyRecord Text
--   ```
--   
--   If we want to get a value, we can use the `getField` method of class `GetField`:
--   
--   ```
--   getFoo : MyRecord -> Int
--   getFoo r = getField @"foo" r
--   
--   getBar : MyRecord -> Text
--   getBar r = getField @"bar" r
--   ```
--   
--   Note that this uses the “type application” syntax ( `f @t` ) to specify the
--   field name.
--   
--   Likewise, if we want to set the value in the field, we can use the `setField` method of class `SetField`:
--   
--   ```
--   setFoo : Int -> MyRecord -> MyRecord
--   setFoo a r = setField @"foo" a r
--   
--   setBar : Text -> MyRecord -> MyRecord
--   setBar a r = setField @"bar" a r
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Record.html#type-da-internal-record-hasfield-59910
type HasField x r a = (GetField x r a, SetField x r a)

-- | `GetField x r a` provides the getter part of `HasField`
@url https://docs.daml.com/daml/stdlib/DA-Record.html#class-da-internal-record-getfield-53979
class GetField x r a

@url https://docs.daml.com/daml/stdlib/DA-Record.html#function-da-internal-record-getfield-6942
getField :: (GetField x r a) => r -> a

-- | `SetField x r a` provides the setter part of `HasField`
@url https://docs.daml.com/daml/stdlib/DA-Record.html#class-da-internal-record-setfield-4311
class SetField x r a

@url https://docs.daml.com/daml/stdlib/DA-Record.html#function-da-internal-record-setfield-14978
setField :: (SetField x r a) => a -> r -> r

@url https://docs.daml.com/daml/stdlib/DA-Semigroup.html#module-da-semigroup-27147
module DA.Semigroup

-- | Semigroup under `max`
--   
--   ```
--   > Max 23 <> Max 42
--   Max 42
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Semigroup.html#type-da-semigroup-types-max-52699
data Max a

@url https://docs.daml.com/daml/stdlib/DA-Semigroup.html#constr-da-semigroup-types-max-20326
Max :: a -> Max

-- | Semigroup under `min`
--   
--   ```
--   > Min 23 <> Min 42
--   Min 23
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Semigroup.html#type-da-semigroup-types-min-78217
data Min a

@url https://docs.daml.com/daml/stdlib/DA-Semigroup.html#constr-da-semigroup-types-min-6532
Min :: a -> Min

-- | Note: This is only supported in Daml-LF 1.11 or later.
--   
--   This module exports the generic set type `Set k` and associated
--   functions. This module should be imported qualified, for example:
--   
--   ```
--   import DA.Set (Set)
--   import DA.Set qualified as S
--   ```
--   
--   This will give access to the `Set` type, and the various operations
--   as `S.lookup`, `S.insert`, `S.fromList`, etc.
--   
--   `Set k` internally uses the built-in order for the type `k`.
--   This means that keys that contain functions are not comparable
--   and will result in runtime errors. To prevent this, the `Ord k`
--   instance is required for most set operations. It is recommended to
--   only use `Set k` for key types that have an `Ord k` instance
--   that is derived automatically using `deriving`:
--   
--   ```
--   data K = ...
--     deriving (Eq, Ord)
--   ```
--   
--   This includes all built-in types that aren't function types, such as
--   `Int`, `Text`, `Bool`, `(a, b)` assuming `a` and `b` have default
--   `Ord` instances, `Optional t` and `[t]` assuming `t` has a
--   default `Ord` instance, `Map k v` assuming `k` and `v` have
--   default `Ord` instances, and `Set k` assuming `k` has a
--   default `Ord` instance.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#module-da-set-6124
module DA.Set

-- | The type of a set. This is a wrapper over the `Map` type.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#type-da-set-types-set-90436
data Set k

@url https://docs.daml.com/daml/stdlib/DA-Set.html#constr-da-set-types-set-78105
Set :: Map k () -> Set

map :: Set -> Map k ()

-- | The empty set.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-empty-19742
empty :: Set k

-- | The number of elements in the set.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-size-6437
size :: Set k -> Int

-- | Convert the set to a list of elements.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-tolist-26355
toList :: Set k -> [k]

-- | Create a set from a list of elements.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-fromlist-9190
fromList :: (Ord k) => [k] -> Set k

-- | Convert a `Set` into a `Map`.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-tomap-37614
toMap :: Set k -> Map k ()

-- | Create a `Set` from a `Map`.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-frommap-15501
fromMap :: Map k () -> Set k

-- | Is the element in the set?
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-member-75542
member :: (Ord k) => k -> Set k -> Bool

-- | Is the element not in the set?
--   `notMember k s` is equivalent to `not (member k s)`.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-notmember-79044
notMember :: (Ord k) => k -> Set k -> Bool

-- | Is this the empty set?
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-null-99389
null :: Set k -> Bool

-- | Insert an element in a set. If the set already contains the
--   element, this returns the set unchanged.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-insert-58479
insert :: (Ord k) => k -> Set k -> Set k

-- | Filter all elements that satisfy the predicate.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-filter-76182
filter :: (Ord k) => (k -> Bool) -> Set k -> Set k

-- | Delete an element from a set.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-delete-52281
delete :: (Ord k) => k -> Set k -> Set k

-- | Create a singleton set.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-singleton-15574
singleton :: (Ord k) => k -> Set k

-- | The union of two sets.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-union-79876
union :: (Ord k) => Set k -> Set k -> Set k

-- | The intersection of two sets.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-intersection-70017
intersection :: (Ord k) => Set k -> Set k -> Set k

-- | `difference x y` returns the set consisting of all
--   elements in `x` that are not in `y`.
--   
--   >>> fromList [1, 2, 3] `difference` fromList [1, 4]
--   fromList [2, 3]
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-difference-68545
difference :: (Ord k) => Set k -> Set k -> Set k

-- | `isSubsetOf a b` returns true if `a` is a subset of `b`,
--   that is, if every element of `a` is in `b`.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-issubsetof-34493
isSubsetOf :: (Ord k) => Set k -> Set k -> Bool

-- | `isProperSubsetOf a b` returns true if `a` is a proper subset of `b`.
--   That is, if `a` is a subset of `b` but not equal to `b`.
@url https://docs.daml.com/daml/stdlib/DA-Set.html#function-da-set-ispropersubsetof-90093
isProperSubsetOf :: (Ord k) => Set k -> Set k -> Bool

@url https://docs.daml.com/daml/stdlib/DA-Stack.html#module-da-stack-24914
module DA.Stack

-- | Location in the source code.
--   
--   Line and column are 0-based.
@url https://docs.daml.com/daml/stdlib/DA-Stack.html#type-da-stack-types-srcloc-15887
data SrcLoc

@url https://docs.daml.com/daml/stdlib/DA-Stack.html#constr-da-stack-types-srcloc-29880
SrcLoc :: Text -> Text -> Text -> Int -> Int -> Int -> Int -> SrcLoc

srcLocPackage :: SrcLoc -> Text

srcLocModule :: SrcLoc -> Text

srcLocFile :: SrcLoc -> Text

srcLocStartLine :: SrcLoc -> Int

srcLocStartCol :: SrcLoc -> Int

srcLocEndLine :: SrcLoc -> Int

srcLocEndCol :: SrcLoc -> Int

-- | Type of callstacks constructed automatically from `HasCallStack` constraints.
--   
--   Use `callStack` to get the current callstack, and use `getCallStack`
--   to deconstruct the `CallStack`.
@url https://docs.daml.com/daml/stdlib/DA-Stack.html#type-ghc-stack-types-callstack-86244
data CallStack

-- | Request a `CallStack`. Use this as a constraint in type signatures in order
--   to get nicer callstacks for error and debug messages.
--   
--   For example, instead of declaring the following type signature:
--   
--   ```
--   myFunction : Int -> Update ()
--   ```
--   
--   You can declare a type signature with the `HasCallStack` constraint:
--   
--   ```
--   myFunction : HasCallStack => Int -> Update ()
--   ```
--   
--   The function `myFunction` will still be called the same way, but it will also show up
--   as an entry in the current callstack, which you can obtain with `callStack`.
--   
--   Note that only functions with the `HasCallStack` constraint will be added to the
--   current callstack, and if any function does not have the `HasCallStack` constraint,
--   the callstack will be reset within that function.
@url https://docs.daml.com/daml/stdlib/DA-Stack.html#type-ghc-stack-types-hascallstack-63713
type HasCallStack = IP "callStack" CallStack

-- | Pretty-print a `CallStack`.
@url https://docs.daml.com/daml/stdlib/DA-Stack.html#function-da-stack-prettycallstack-78669
prettyCallStack :: CallStack -> Text

-- | Extract the list of call sites from the `CallStack`.
--   
--   The most recent call comes first.
@url https://docs.daml.com/daml/stdlib/DA-Stack.html#function-da-stack-getcallstack-34576
getCallStack :: CallStack -> [(Text, SrcLoc)]

-- | Access to the current `CallStack`.
@url https://docs.daml.com/daml/stdlib/DA-Stack.html#function-da-stack-callstack-89067
callStack :: (HasCallStack) => CallStack

-- | Functions for working with Text.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#module-da-text-83238
module DA.Text

@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-explode-24206
explode :: Text -> [Text]

@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-implode-82253
implode :: [Text] -> Text

-- | Test for emptiness.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-isempty-39554
isEmpty :: Text -> Bool

-- | Test for non-emptiness.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-isnotempty-43984
isNotEmpty :: Text -> Bool

-- | Compute the number of symbols in the text.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-length-94326
length :: Text -> Int

-- | Remove spaces from either side of the given text.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-trim-11808
trim :: Text -> Text

-- | Replace a subsequence everywhere it occurs. The first argument
--   must not be empty.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-replace-9445
replace :: Text -> Text -> Text -> Text

-- | Breaks a `Text` value up into a list of `Text`'s at newline
--   symbols. The resulting texts do not contain newline symbols.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-lines-25154
lines :: Text -> [Text]

-- | Joins lines, after appending a terminating newline to each.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-unlines-66467
unlines :: [Text] -> Text

-- | Breaks a 'Text' up into a list of words, delimited by symbols
--   representing white space.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-words-34636
words :: Text -> [Text]

-- | Joins words using single space symbols.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-unwords-40113
unwords :: [Text] -> Text

-- | A variant of `lines` with a custom test. In particular, if there
--   is a trailing separator it will be discarded.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-linesby-11211
linesBy :: (Text -> Bool) -> Text -> [Text]

-- | A variant of `words` with a custom test. In particular, adjacent
--   separators are discarded, as are leading or trailing separators.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-wordsby-15461
wordsBy :: (Text -> Bool) -> Text -> [Text]

-- | `intercalate` inserts the text argument `t` in between the items
--   in `ts` and concatenates the result.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-intercalate-63059
intercalate :: Text -> [Text] -> Text

-- | `dropPrefix` drops the given prefix from the argument. It returns
--   the original text if the text doesn't start with the given prefix.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-dropprefix-62361
dropPrefix :: Text -> Text -> Text

-- | Drops the given suffix from the argument. It returns the original
--   text if the text doesn't end with the given suffix. Examples:
--   ```
--     dropSuffix "!" "Hello World!"  == "Hello World"
--     dropSuffix "!" "Hello World!!" == "Hello World!"
--     dropSuffix "!" "Hello World."  == "Hello World."
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-dropsuffix-37682
dropSuffix :: Text -> Text -> Text

-- | Return the prefix of the second text if its suffix matches the
--   entire first text. Examples:
--   ```
--     stripSuffix "bar" "foobar" == Some "foo"
--     stripSuffix ""    "baz"    == Some "baz"
--     stripSuffix "foo" "quux"   == None
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-stripsuffix-58624
stripSuffix :: Text -> Text -> Optional Text

-- | The `stripPrefix` function drops the given prefix from the
--   argument text.  It returns `None` if the text did not start with
--   the prefix.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-stripprefix-74987
stripPrefix :: Text -> Text -> Optional Text

-- | The `isPrefixOf` function takes two text arguments and returns
--   `True` if and only if the first is a prefix of the second.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-isprefixof-82357
isPrefixOf :: Text -> Text -> Bool

-- | The `isSuffixOf` function takes two text arguments and returns
--   `True` if and only if the first is a suffix of the second.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-issuffixof-35218
isSuffixOf :: Text -> Text -> Bool

-- | The `isInfixOf` function takes two text arguments and returns
--   `True` if and only if the first is contained, wholly and intact,
--   anywhere within the second.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-isinfixof-98358
isInfixOf :: Text -> Text -> Bool

-- | The function `takeWhile`, applied to a predicate `p` and a text,
--   returns the longest prefix (possibly empty) of symbols that satisfy
--   `p`.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-takewhile-40431
takeWhile :: (Text -> Bool) -> Text -> Text

-- | The function 'takeWhileEnd', applied to a predicate `p` and a
--   'Text', returns the longest suffix (possibly empty) of elements
--   that satisfy `p`.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-takewhileend-32455
takeWhileEnd :: (Text -> Bool) -> Text -> Text

-- | `dropWhile p t` returns the suffix remaining after `takeWhile p
--   t`.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-dropwhile-46373
dropWhile :: (Text -> Bool) -> Text -> Text

-- | `dropWhileEnd p t` returns the prefix remaining after dropping
--   symbols that satisfy the predicate `p` from the end of `t`.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-dropwhileend-2917
dropWhileEnd :: (Text -> Bool) -> Text -> Text

-- | Break a text into pieces separated by the first text argument
--   (which cannot be empty), consuming the delimiter.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-spliton-44082
splitOn :: Text -> Text -> [Text]

-- | Split a text before a given position so that for `0 <= n <= length t`,
--   `length (fst (splitAt n t)) == n`.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-splitat-25614
splitAt :: Int -> Text -> (Text, Text)

-- | `take n`, applied to a text `t`, returns the prefix of `t` of
--   length `n`, or `t` itself if `n` is greater than the length of `t`.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-take-27133
take :: Int -> Text -> Text

-- | `drop n`, applied to a text `t`, returns the suffix of `t` after
--   the first `n` characters, or the empty `Text` if `n` is greater
--   than the length of `t`.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-drop-34163
drop :: Int -> Text -> Text

-- | Compute the sequence of symbols of length `l` in the argument
--   text starting at `s`.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-substring-36270
substring :: Int -> Int -> Text -> Text

-- | `isPred f t` returns `True` if `t` is not empty and `f` is `True`
--   for all symbols in `t`.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-ispred-73747
isPred :: (Text -> Bool) -> Text -> Bool

-- | `isSpace t` is `True` if `t` is not empty and consists only of
--   spaces.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-isspace-72803
isSpace :: Text -> Bool

-- | `isSpace t` is `True` if `t` is not empty and consists only of
--   newlines.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-isnewline-85831
isNewLine :: Text -> Bool

-- | `isUpper t` is `True` if `t` is not empty and consists only of
--   uppercase symbols.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-isupper-58977
isUpper :: Text -> Bool

-- | `isLower t` is `True` if `t` is not empty and consists only of
--   lowercase symbols.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-islower-60966
isLower :: Text -> Bool

-- | `isDigit t` is `True` if `t` is not empty and consists only of
--   digit symbols.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-isdigit-15622
isDigit :: Text -> Bool

-- | `isAlpha t` is `True` if `t` is not empty and consists only of
--   alphabet symbols.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-isalpha-72233
isAlpha :: Text -> Bool

-- | `isAlphaNum t` is `True` if `t` is not empty and consists only of
--   alphanumeric symbols.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-isalphanum-87978
isAlphaNum :: Text -> Bool

-- | Attempt to parse an `Int` value from a given `Text`.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-parseint-736
parseInt :: Text -> Optional Int

-- | Attempt to parse a `Numeric` value from a given `Text`.
--   To get `Some` value, the text must follow the regex
--   `(-|\+)?[0-9]+(\.[0-9]+)?`
--   In particular, the shorthands `".12"` and `"12."` do not work,
--   but the value can be prefixed with `+`.
--   Leading and trailing zeros are fine, however spaces are not.
--   Examples:
--   ```
--     parseNumeric "3.14" == Some 3.14
--     parseNumeric "+12.0" == Some 12
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-parsenumeric-9858
parseNumeric :: (NumericScale n) => Text -> Optional (Numeric n)

-- | Attempt to parse a `Decimal` value from a given `Text`.
--   To get `Some` value, the text must follow the regex
--   `(-|\+)?[0-9]+(\.[0-9]+)?`
--   In particular, the shorthands `".12"` and `"12."` do not work,
--   but the value can be prefixed with `+`.
--   Leading and trailing zeros are fine, however spaces are not.
--   Examples:
--   ```
--     parseDecimal "3.14" == Some 3.14
--     parseDecimal "+12.0" == Some 12
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-parsedecimal-57278
parseDecimal :: Text -> Optional Decimal

-- | Computes the SHA256 hash of the UTF8 bytes of the `Text`, and returns it in its hex-encoded
--   form. The hex encoding uses lowercase letters.
--   
--   This function will crash at runtime if you compile Daml to Daml-LF < 1.2.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-sha256-29291
sha256 :: Text -> Text

-- | Reverse some `Text`.
--   ```
--     reverse "Daml" == "lmaD"
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-reverse-37387
reverse :: Text -> Text

-- | Convert a `Text` into a sequence of unicode code points.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-tocodepoints-44801
toCodePoints :: Text -> [Int]

-- | Convert a sequence of unicode code points into a `Text`. Raises an
--   exception if any of the code points is invalid.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-fromcodepoints-94464
fromCodePoints :: [Int] -> Text

-- | Convert the uppercase ASCII characters of a `Text` to lowercase;
--   all other characters remain unchanged.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-asciitolower-24557
asciiToLower :: Text -> Text

-- | Convert the lowercase ASCII characters of a `Text` to uppercase;
--   all other characters remain unchanged.
@url https://docs.daml.com/daml/stdlib/DA-Text.html#function-da-text-asciitoupper-96826
asciiToUpper :: Text -> Text

-- | TextMap - A map is an associative array data type composed of a
--   collection of key/value pairs such that, each possible key appears
--   at most once in the collection.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#module-da-textmap-81719
module DA.TextMap

-- | Create a map from a list of key/value pairs.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-fromlist-19033
fromList :: [(Text, a)] -> TextMap a

-- | Create a map from a list of key/value pairs with a combining
--   function. The combining function is only used when a key appears multiple
--   times in the list and it takes two arguments: the first one is the new value
--   being inserted at that key and the second one is the value accumulated so
--   far at that key.
--   Examples:
--   
--   ```
--   >>> fromListWithL (++) [("A", [1]), ("A", [2]), ("B", [2]), ("B", [1]), ("A", [3])]
--   fromList [("A", [3, 2, 1]), ("B", [1, 2])]
--   >>> fromListWithL (++) [] == (empty : TextMap [Int])
--   True
--   ```
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-fromlistwithl-22912
fromListWithL :: (a -> a -> a) -> [(Text, a)] -> TextMap a

-- | Create a map from a list of key/value pairs like `fromListWithL`
--   with the combining function flipped. Examples:
--   
--   ```
--   >>> fromListWithR (++) [("A", [1]), ("A", [2]), ("B", [2]), ("B", [1]), ("A", [3])]
--   fromList [("A", [1, 2, 3]), ("B", [2, 1])]
--   >>> fromListWithR (++) [] == (empty : TextMap [Int])
--   True
--   ```
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-fromlistwithr-69626
fromListWithR :: (a -> a -> a) -> [(Text, a)] -> TextMap a

-- | DEPRECATED: Daml compatibility helper, use 'fromListWithR' instead of 'fromListWith'
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-fromlistwith-41741
fromListWith :: (a -> a -> a) -> [(Text, a)] -> TextMap a

-- | Convert the map to a list of key/value pairs where the keys are
--   in ascending order.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-tolist-95168
toList :: TextMap a -> [(Text, a)]

-- | The empty map.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-empty-66187
empty :: TextMap a

-- | Number of elements in the map.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-size-46150
size :: TextMap a -> Int

-- | Is the map empty?
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-null-64690
null :: TextMap v -> Bool

-- | Lookup the value at a key in the map.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-lookup-87021
lookup :: Text -> TextMap a -> Optional a

-- | Is the key a member of the map?
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-member-14417
member :: Text -> TextMap v -> Bool

-- | Filter the `TextMap` using a predicate: keep only the entries where the
--   value satisfies the predicate.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-filter-317
filter :: (v -> Bool) -> TextMap v -> TextMap v

-- | Filter the `TextMap` using a predicate: keep only the entries which
--   satisfy the predicate.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-filterwithkey-64027
filterWithKey :: (Text -> v -> Bool) -> TextMap v -> TextMap v

-- | Delete a key and its value from the map. When the key is not a
--   member of the map, the original map is returned.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-delete-54270
delete :: Text -> TextMap a -> TextMap a

-- | Create a singleton map.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-singleton-39431
singleton :: Text -> a -> TextMap a

-- | Insert a new key/value pair in the map. If the key is already
--   present in the map, the associated value is replaced with the
--   supplied value.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-insert-41312
insert :: Text -> a -> TextMap a -> TextMap a

-- | Insert a new key/value pair in the map. If the key is already
--   present in the map, it is combined with the previous value using the given function
--   `f new_value old_value`.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-insertwith-45464
insertWith :: (v -> v -> v) -> Text -> v -> TextMap v -> TextMap v

-- | The union of two maps, preferring the first map when equal
--   keys are encountered.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-union-13945
union :: TextMap a -> TextMap a -> TextMap a

-- | Merge two maps. `merge f g h x y` applies `f` to all key/value pairs
--   whose key only appears in `x`, `g` to all pairs whose key only appears
--   in `y` and `h` to all pairs whose key appears in both `x` and `y`.
--   In the end, all pairs yielding `Some` are collected as the result.
@url https://docs.daml.com/daml/stdlib/DA-TextMap.html#function-da-textmap-merge-26784
merge :: (Text -> a -> Optional c) -> (Text -> b -> Optional c) -> (Text -> a -> b -> Optional c) -> TextMap a -> TextMap b -> TextMap c

-- | This module provides a set of functions to manipulate Time values.
--   The `Time` type represents a specific datetime in UTC,
--   for example `time (date 2007 Apr 5) 14 30 05`.
--   The bounds for Time are 0001-01-01T00:00:00.000000Z and
--   9999-12-31T23:59:59.999999Z.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#module-da-time-32716
module DA.Time

-- | The `RelTime` type describes a time offset, i.e. relative time.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#type-da-time-types-reltime-23082
data RelTime

-- | `time d h m s` turns given UTC date `d` and the UTC time (given in hours, minutes, seconds)
--   into a UTC timestamp (`Time`). Does not handle leap seconds.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-internal-time-time-34667
time :: Date -> Int -> Int -> Int -> Time

-- | Adjusts `Time` with given time offset.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-addreltime-70617
addRelTime :: Time -> RelTime -> Time

-- | Returns time offset between two given instants.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-subtime-47226
subTime :: Time -> Time -> RelTime

-- | Returns the number of whole days in a time offset. Fraction of time is rounded towards zero.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-wholedays-91725
wholeDays :: RelTime -> Int

-- | A number of days in relative time.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-days-58759
days :: Int -> RelTime

-- | A number of hours in relative time.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-hours-54068
hours :: Int -> RelTime

-- | A number of minutes in relative time.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-minutes-72520
minutes :: Int -> RelTime

-- | A number of seconds in relative time.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-seconds-68512
seconds :: Int -> RelTime

-- | A number of milliseconds in relative time.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-milliseconds-28552
milliseconds :: Int -> RelTime

-- | A number of microseconds in relative time.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-microseconds-56941
microseconds :: Int -> RelTime

-- | Convert RelTime to microseconds
--   Use higher level functions instead of the internal microseconds
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-convertreltimetomicroseconds-23127
convertRelTimeToMicroseconds :: RelTime -> Int

-- | Convert microseconds to RelTime
--   Use higher level functions instead of the internal microseconds
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-convertmicrosecondstoreltime-73643
convertMicrosecondsToRelTime :: Int -> RelTime

-- | True iff the ledger time of the transaction is less than the given time.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-isledgertimelt-78120
isLedgerTimeLT :: Time -> Update Bool

-- | True iff the ledger time of the transaction is less than or equal to the given time.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-isledgertimele-50101
isLedgerTimeLE :: Time -> Update Bool

-- | True iff the ledger time of the transaction is greater than the given time.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-isledgertimegt-6233
isLedgerTimeGT :: Time -> Update Bool

-- | True iff the ledger time of the transaction is greater than or equal to the given time.
@url https://docs.daml.com/daml/stdlib/DA-Time.html#function-da-time-isledgertimege-95212
isLedgerTimeGE :: Time -> Update Bool

-- | Class of data structures that can be traversed from left to right, performing an action on each element.
--   You typically would want to import this module qualified to avoid clashes with
--   functions defined in `Prelude`. Ie.:
--   ```
--   import DA.Traversable   qualified as F
--   ```
@url https://docs.daml.com/daml/stdlib/DA-Traversable.html#module-da-traversable-75075
module DA.Traversable

-- | Functors representing data structures that can be traversed from left to right.
@url https://docs.daml.com/daml/stdlib/DA-Traversable.html#class-da-traversable-traversable-18144
class (Functor t, Foldable t) => Traversable t

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results.
@url https://docs.daml.com/daml/stdlib/DA-Traversable.html#function-da-traversable-mapa-2898
mapA :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and
--   collect the results.
@url https://docs.daml.com/daml/stdlib/DA-Traversable.html#function-da-traversable-sequence-31922
sequence :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | `forA` is `mapA` with its arguments flipped.
@url https://docs.daml.com/daml/stdlib/DA-Traversable.html#function-da-traversable-fora-19271
forA :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | Tuple - Ubiquitous functions of tuples.
@url https://docs.daml.com/daml/stdlib/DA-Tuple.html#module-da-tuple-81988
module DA.Tuple

-- | The pair obtained from a pair by application of a programmer
--   supplied function to the argument pair's first field.
@url https://docs.daml.com/daml/stdlib/DA-Tuple.html#function-da-tuple-first-48871
first :: (a -> a') -> (a, b) -> (a', b)

-- | The pair obtained from a pair by application of a programmer
--   supplied function to the argument pair's second field.
@url https://docs.daml.com/daml/stdlib/DA-Tuple.html#function-da-tuple-second-48360
second :: (b -> b') -> (a, b) -> (a, b')

-- | The pair obtained from a pair by application of a programmer
--   supplied function to both the argument pair's first and second
--   fields.
@url https://docs.daml.com/daml/stdlib/DA-Tuple.html#function-da-tuple-both-63511
both :: (a -> b) -> (a, a) -> (b, b)

-- | The pair obtained from a pair by permuting the order of the
--   argument pair's first and second fields.
@url https://docs.daml.com/daml/stdlib/DA-Tuple.html#function-da-tuple-swap-76115
swap :: (a, b) -> (b, a)

-- | Duplicate a single value into a pair.
--   
--   > dupe 12 == (12, 12)
@url https://docs.daml.com/daml/stdlib/DA-Tuple.html#function-da-tuple-dupe-14430
dupe :: a -> (a, a)

-- | Extract the 'fst' of a triple.
@url https://docs.daml.com/daml/stdlib/DA-Tuple.html#function-da-tuple-fst3-84676
fst3 :: (a, b, c) -> a

-- | Extract the 'snd' of a triple.
@url https://docs.daml.com/daml/stdlib/DA-Tuple.html#function-da-tuple-snd3-63950
snd3 :: (a, b, c) -> b

-- | Extract the final element of a triple.
@url https://docs.daml.com/daml/stdlib/DA-Tuple.html#function-da-tuple-thd3-58697
thd3 :: (a, b, c) -> c

-- | Converts an uncurried function to a curried function.
@url https://docs.daml.com/daml/stdlib/DA-Tuple.html#function-da-tuple-curry3-2900
curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d

-- | Converts a curried function to a function on a triple.
@url https://docs.daml.com/daml/stdlib/DA-Tuple.html#function-da-tuple-uncurry3-51859
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d

-- | `Validation` type and associated functions.
@url https://docs.daml.com/daml/stdlib/DA-Validation.html#module-da-validation-69700
module DA.Validation

-- | A `Validation` represents eithor a non-empty list of errors, or a successful value.
--   This generalizes `Either` to allow more than one error to be collected.
@url https://docs.daml.com/daml/stdlib/DA-Validation.html#type-da-validation-types-validation-39644
data Validation err a

@url https://docs.daml.com/daml/stdlib/DA-Validation.html#constr-da-validation-types-errors-73825
Errors :: NonEmpty err -> Validation

@url https://docs.daml.com/daml/stdlib/DA-Validation.html#constr-da-validation-types-success-12286
Success :: a -> Validation

-- | Fail for the given reason.
@url https://docs.daml.com/daml/stdlib/DA-Validation.html#function-da-validation-invalid-71114
invalid :: err -> Validation err a

-- | Succeed with the given value.
@url https://docs.daml.com/daml/stdlib/DA-Validation.html#function-da-validation-ok-57346
ok :: a -> Validation err a

-- | Turn an `Either` into a `Validation`.
@url https://docs.daml.com/daml/stdlib/DA-Validation.html#function-da-validation-validate-15676
validate :: Either err a -> Validation err a

-- | Convert a `Validation err a` value into an `Either`,
--   taking the non-empty list of errors as the left value.
@url https://docs.daml.com/daml/stdlib/DA-Validation.html#function-da-validation-run-73024
run :: Validation err a -> Either (NonEmpty err) a

-- | Convert a `Validation err a` value into an `Either`,
--   taking just the first error as the left value.
@url https://docs.daml.com/daml/stdlib/DA-Validation.html#function-da-validation-run1-16566
run1 :: Validation err a -> Either err a

-- | Run a `Validation err a` with a default value in case of errors.
@url https://docs.daml.com/daml/stdlib/DA-Validation.html#function-da-validation-runwithdefault-81974
runWithDefault :: a -> Validation err a -> a

-- | Convert an `Optional t` into a `Validation err t`, or
--   more generally into an `m t` for any `ActionFail` type `m`.
@url https://docs.daml.com/daml/stdlib/DA-Validation.html#function-da-validation-ltwhatgt-24976
(<?>) :: Optional b -> err -> Validation err b

@url https://docs.daml.com/daml/stdlib/GHC-Show-Text.html#module-ghc-show-text-13336
module GHC.Show.Text

@url https://docs.daml.com/daml/stdlib/GHC-Show-Text.html#function-ghc-show-text-showsprectext-69636
showsPrecText :: Int -> Text -> ShowS

@url https://docs.daml.com/daml/stdlib/GHC-Tuple-Check.html#module-ghc-tuple-check-92032
module GHC.Tuple.Check

@url https://docs.daml.com/daml/stdlib/GHC-Tuple-Check.html#function-ghc-tuple-check-userwrittentuple-58630
userWrittenTuple :: a -> a



-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Script.Internal
  ( Question (..)
  , IsQuestion (..)
  , Script (..)
  , LedgerValue
  , ScriptF (..)
  , lift
  , script
  , fromLedgerValue
  , toLedgerValue
  ) where

import Daml.Script.Free (Free(..))
import qualified Daml.Script.Free as Free
import DA.Stack
import DA.Text (isPrefixOf)

-- Everything is a question, which has a continuation, as well as input/putput types and callstack
-- Note that res and a are _NOT_ the same, as this must be a functor, and res is contravariant
data Question req res a = Question with
    payload : req
    locations : [(Text, SrcLoc)]
    continue : res -> a
  deriving Functor

-- We relate question requests to replies with this class, and build using the method.
class IsQuestion req res where
  makeQuestion : HasCallStack => req -> Question req res res
  makeQuestion req = Question req (dropInternalFrames $ getCallStack callStack) identity

-- Drop any stack frames that reference Daml Script internals
dropInternalFrames : [(Text, SrcLoc)] -> [(Text, SrcLoc)]
dropInternalFrames = dropWhile $ isInternalSrcLoc . snd

isInternalSrcLoc : SrcLoc -> Bool
isInternalSrcLoc SrcLoc {srcLocPackage, srcLocModule} =
  "daml3-script-" `isPrefixOf` srcLocPackage && "Daml.Script" `isPrefixOf` srcLocModule

-- We don't care about the type information once its a full ScriptF, as scala side will work that out.
-- So, we use our danger cast to turn the req and res into LedgerValues
castQuestion : Question req res a -> Question LedgerValue LedgerValue a
castQuestion = dangerousCast

-- Our entire scriptF type now is just a question from LedgerValue to LedgerValue, returning a
newtype ScriptF a = ScriptF (Question LedgerValue LedgerValue a) deriving Functor

-- Build our question and cast to a ScriptF
makeScriptF : (HasCallStack, IsQuestion req res) => req -> ScriptF res
makeScriptF = ScriptF . castQuestion . makeQuestion

-- | This is the type of A Daml script. `Script` is an instance of `Action`,
-- so you can use `do` notation.
data Script a = Script with
    runScript : () -> Free ScriptF (a, ())
    -- We use an inlined StateT () to separate evaluation of
    -- something of type Script from execution and to ensure
    -- proper sequencing of evaluation. This is mainly so that `debug` does something
    -- slightly more sensible.
    dummy : ()
    -- Dummy field to make sure damlc does not consider this an old-style
    -- typeclass.
  deriving Functor

instance CanAbort Script where
  abort s = Script (\_ -> error s) ()

instance ActionFail Script where
  fail = abort

instance Applicative Script where
    pure a = Script (\s -> return (a, s)) ()

    Script mf _ <*> Script mx _ = Script with
      runScript = \ s -> do
        (f, s') <- mf s
        (x, s'') <- mx s'
        return (f x, s'')
      dummy = ()

instance Action Script where
    m >>= k  = Script with
      runScript = \ s -> do
        (a, s') <- runScript m s
        runScript (k a) s'
      dummy = ()

liftScript : Free ScriptF a -> Script a
liftScript m = Script with
  runScript = \s -> do
    a <- m
    pure (a, s)
  dummy = ()

lift : (HasCallStack, IsQuestion req res) => req -> Script res
lift = liftScript . Free.lift . makeScriptF

-- | Convenience helper to declare you are writing a Script.
--
-- This is only useful for readability and to improve type inference.
-- Any expression of type `Script a` is a valid script regardless of whether
-- it is implemented using `script` or not.
script : Script a -> Script a
script = identity

dangerousCast : a -> b
dangerousCast = error "Non-replaced call to internal-only dangerousCast. Are you using the Script runner? " -- gets replaced by the identity-function in script/Runner.scala

data LedgerValue = LedgerValue {}

fromLedgerValue : LedgerValue -> a
fromLedgerValue = dangerousCast

toLedgerValue : a -> LedgerValue
toLedgerValue = dangerousCast

-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE InstanceSigs #-}

module Daml.Script.Questions.Submit
  ( module Daml.Script.Questions.Submit
  , module Daml.Script.Questions.Submit.Error
  ) where

import Daml.Script.Internal
import Daml.Script.Questions.Commands
import Daml.Script.Questions.Submit.Error
import Daml.Script.Questions.TransactionTree
import DA.NonEmpty
import DA.Stack
import DA.Functor (void)
import DA.Bifunctor (first)
import DA.Optional (fromOptional)
import DA.Either (fromLeft, fromRight)

data SubmitConcurrentInternal = SubmitConcurrentInternal with
  submissions : [Submission]
instance IsQuestion SubmitConcurrentInternal [Either (Optional SubmitError) ([CommandResult], Optional TransactionTree)] where command = "SubmitConcurrentInternal"

data Submission = Submission with
  sActAs : NonEmpty Party
  sReadAs : [Party]
  sDisclosures : [Disclosure]
  sErrorBehaviour : ErrorBehaviour
  sCommands : [Command]

data ErrorBehaviour = MustSucceed | MustFail | Try

-- | Options to detemine the stakeholders of a transaction, as well as disclosures.
-- Intended to be specified using the `actAs`, `readAs` and `disclose` builders, combined using the Semigroup concat `(<>)` operator.
-- ```
-- actAs alice <> readAs [alice, bob] <> disclose myContract
-- ```
-- Note that actAs and readAs follows the same party derivation rules as `signatory`, see their docs for examples.
-- All submissions must specify at least one `actAs` party, else a runtime error will be thrown.
-- A minimum submission may look like
-- ```
-- submit (actAs alice) $ createCmd MyContract with party = alice
-- ```
data SubmitOptions = SubmitOptions with
  soActAs : [Party]
  soReadAs : [Party]
  soDisclosures : [Disclosure]

-- | Semigroup instance allowing for combination via (<>)
instance Semigroup SubmitOptions where
  SubmitOptions a b c <> SubmitOptions a' b' c' = SubmitOptions (a <> a') (b <> b') (c <> c')

-- | Builds a SubmitOptions with given actAs parties.
-- Any given submission must include at least one actAs party.
-- Note that the parties type is constrainted by `IsParties`, allowing for specifying parties as any of the following:
-- ```
-- Party
-- [Party]
-- NonEmpty Party
-- Set Party
-- Optional Party
-- ```
actAs : IsParties p => p -> SubmitOptions
actAs p = SubmitOptions (toParties p) [] []

-- | Builds a SubmitOptions with given readAs parties.
-- A given submission may omit any readAs parties and still be valid.
-- Note that the parties type is constrainted by `IsParties`, allowing for specifying parties as any of the following:
-- ```
-- Party
-- [Party]
-- NonEmpty Party
-- Set Party
-- Optional Party
-- ```
readAs : IsParties p => p -> SubmitOptions
readAs p = SubmitOptions [] (toParties p) []

-- | Provides an Explicit Disclosure to the transaction.
disclose : Disclosure -> SubmitOptions
disclose d = SubmitOptions [] [] [d]

-- | Defines a type that can be transformed into a SubmitOptions
class IsSubmitOptions a where
  toSubmitOptions : a -> SubmitOptions

-- Even though `IsParties SubmitOptions` doesn't exist, ghc doesn't consider context in instance selection.
instance {-# OVERLAPS #-} IsSubmitOptions SubmitOptions where
  toSubmitOptions = identity

-- | Allows a single (or many) parties to be directly provided as actAs parties.
-- This gives rise to the familiar syntax of
-- ```
-- alice `submit` createCmd MyContract with party = alice
-- ```
instance IsParties p => IsSubmitOptions p where
  toSubmitOptions = actAs

-- | Defines an applicative that can run transaction submissions. Usually this is simply `Script`.
class Applicative m => ScriptSubmit m where
  submitInternal : HasCallStack => SubmitOptions -> ErrorBehaviour -> Commands a -> m (Either (Optional SubmitError) (a, Optional TransactionTree))

-- | Applicative that allows for multiple concurrent transaction submissions
-- See `concurrently` for usage of this type.
data ConcurrentSubmits a = ConcurrentSubmits with
    submits : [Submission]
    continue : [Either (Optional SubmitError) ([CommandResult], Optional TransactionTree)] -> a
  deriving Functor

instance Applicative ConcurrentSubmits where
  pure : a -> ConcurrentSubmits a
  pure x = ConcurrentSubmits [] (const x)

  liftA2 : (a -> b -> c) -> ConcurrentSubmits a -> ConcurrentSubmits b -> ConcurrentSubmits c
  liftA2 f a b = ConcurrentSubmits
    { submits = a.submits <> b.submits
    , continue = \results -> 
        let (aResults, bResults) = splitAt (length a.submits) results
        in f (a.continue aResults) (b.continue bResults)
    }

actAsNonEmpty : [Party] -> NonEmpty Party
actAsNonEmpty ps = case ps of
  [] -> error "actAs must be non-empty"
  p :: ps -> NonEmpty p ps

instance ScriptSubmit ConcurrentSubmits where
  submitInternal : HasCallStack => SubmitOptions -> ErrorBehaviour -> Commands a -> ConcurrentSubmits (Either (Optional SubmitError) (a, Optional TransactionTree))
  submitInternal opts errorBehaviour cmds = ConcurrentSubmits with
    submits =
      [ Submission with
          sActAs = actAsNonEmpty opts.soActAs
          sReadAs = opts.soReadAs
          sDisclosures = opts.soDisclosures
          sErrorBehaviour = errorBehaviour
          sCommands = cmds.commands
      ]
    continue = \case
      [res] -> fmap (first cmds.continue) res
      _ -> error "CRASH! Incorrect number of submission results returned from ConcurrentSubmit!"

-- | Allows for concurrent submission of transactions, using an applicative, similar to Commands.
-- Concurrently takes a computation in `ConcurrentSubmits`, which supports all the existing `submit` functions
-- that `Script` supports. It however does not implement `Action`, and thus does not support true binding and computation interdependence
concurrently : ConcurrentSubmits a -> Script a
concurrently submissions = fmap submissions.continue $ lift $ SubmitConcurrentInternal with
  submissions = submissions.submits

instance ScriptSubmit Script where
  submitInternal : HasCallStack => SubmitOptions -> ErrorBehaviour -> Commands a -> Script (Either (Optional SubmitError) (a, Optional TransactionTree))
  submitInternal opts errorBehaviour cmds = concurrently $ submitInternal opts errorBehaviour cmds

-- ##### Main API #####
-- | Equivalent to `submit` but returns the result and the full transaction tree.
submitResultAndTree : (HasCallStack, ScriptSubmit m, IsSubmitOptions o) => o -> Commands a -> m (a, Optional TransactionTree)
submitResultAndTree opts cmds = fromRight (error "MustSucceed Failed") <$> submitInternal (toSubmitOptions opts) MustSucceed cmds

-- | Equivalent to `trySubmit` but returns the result and the full transaction tree.
trySubmitResultAndTree : (HasCallStack, ScriptSubmit m, IsSubmitOptions o) => o -> Commands a -> m (Either SubmitError (a, Optional TransactionTree))
trySubmitResultAndTree opts cmds = first getError <$> submitInternal (toSubmitOptions opts) Try cmds

-- | Equivalent to `submitMustFail` but returns the error thrown.
submitWithError : (HasCallStack, ScriptSubmit m, IsSubmitOptions o) => o -> Commands a -> m SubmitError
submitWithError opts cmds = getError . fromLeft (error "MustFail Succeeded") <$> submitInternal (toSubmitOptions opts) MustFail cmds

getTransactionTree : Optional TransactionTree -> TransactionTree
getTransactionTree = fromOptional (error "No transaction tree returned! The JSON Ledger Client does not support submitTree.")

getError : Optional SubmitError -> SubmitError
getError = fromOptional (error "No transaction tree returned! The JSON Ledger Client does not support submitTree.")

-- | `submit p cmds` submits the commands `cmds` as a single transaction
-- from party `p` and returns the value returned by `cmds`.
--
-- If the transaction fails, `submit` also fails.
submit : (HasCallStack, ScriptSubmit m, IsSubmitOptions o) => o -> Commands a -> m a
submit opts cmds = fst <$> submitResultAndTree opts cmds

-- | Equivalent to `submit` but returns the full transaction tree.
submitTree : (HasCallStack, ScriptSubmit m, IsSubmitOptions o) => o -> Commands a -> m TransactionTree
submitTree opts cmds = getTransactionTree . snd <$> submitResultAndTree opts cmds

-- | Submit a transaction and recieve back either the result, or a `SubmitError`.
-- In the majority of failures, this will not crash at runtime.
trySubmit : (HasCallStack, ScriptSubmit m, IsSubmitOptions o) => o -> Commands a -> m (Either SubmitError a)
trySubmit opts cmds = fmap fst <$> trySubmitResultAndTree opts cmds

-- | Equivalent to `trySubmit` but returns the full transaction tree.
trySubmitTree : (HasCallStack, ScriptSubmit m, IsSubmitOptions o) => o -> Commands a -> m (Either SubmitError TransactionTree)
trySubmitTree opts cmds = fmap (getTransactionTree . snd) <$> trySubmitResultAndTree opts cmds

-- | `submitMustFail p cmds` submits the commands `cmds` as a single transaction
-- from party `p`.
--
-- It only succeeds if the submitting the transaction fails.
submitMustFail : (HasCallStack, ScriptSubmit m, IsSubmitOptions o) => o -> Commands a -> m ()
submitMustFail opts cmds = void $ submitWithError opts cmds

-- ##### Old compatibility conveniences #####

-- | `submitMulti actAs readAs cmds` submits `cmds` as a single transaction
-- authorized by `actAs`. Fetched contracts must be visible to at least
-- one party in the union of actAs and readAs.
-- 
-- Note: This behaviour can be achieve used `submit (actAs actors <> readAs readers) cmds`
-- and is only provided for backwards compatibility.
submitMulti : (HasCallStack, ScriptSubmit m) => [Party] -> [Party] -> Commands a -> m a
submitMulti actors readers cmds = submit (actAs actors <> readAs readers) cmds

-- | `submitMultiMustFail actAs readAs cmds` behaves like `submitMulti actAs readAs cmds`
-- but fails when `submitMulti` succeeds and the other way around.
--
-- Note: This behaviour can be achieve used `submitMustFail (actAs actors <> readAs readers) cmds`
-- and is only provided for backwards compatibility.
submitMultiMustFail : (HasCallStack, ScriptSubmit m) => [Party] -> [Party] -> Commands a -> m ()
submitMultiMustFail actors readers cmds = submitMustFail (actAs actors <> readAs readers) cmds

-- | Equivalent to `submitMulti` but returns the full transaction tree.
-- 
-- Note: This behaviour can be achieve used `submitTree (actAs actors <> readAs readers) cmds`
-- and is only provided for backwards compatibility.
submitTreeMulti : (HasCallStack, ScriptSubmit m) => [Party] -> [Party] -> Commands a -> m TransactionTree
submitTreeMulti actors readers cmds = submitTree (actAs actors <> readAs readers) cmds

-- | Alternate version of `trySubmit` that allows specifying the actAs and readAs parties.
-- 
-- Note: This behaviour can be achieve used `trySubmit (actAs actors <> readAs readers) cmds`
-- and is only provided for backwards compatibility.
trySubmitMulti : (HasCallStack, ScriptSubmit m) => [Party] -> [Party] -> Commands a -> m (Either SubmitError a)
trySubmitMulti actors readers cmds = trySubmit (actAs actors <> readAs readers) cmds

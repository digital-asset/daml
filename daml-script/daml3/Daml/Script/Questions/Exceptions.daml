-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE CPP #-}
{-# LANGUAGE InstanceSigs #-}

module Daml.Script.Questions.Exceptions where

#ifdef DAML_EXCEPTIONS
import DA.Bifunctor (first)
import DA.Exception
import DA.Optional
import Daml.Script.Internal
import Daml.Script.Free (Free (..))

data Catch = Catch with
  act : () -> Free ScriptF (LedgerValue, ())
  dummy : ()
instance IsQuestion Catch (Either AnyException x)

tryToEither : forall t. (() -> Script t) -> Script (Either AnyException t)
tryToEither act = lift Catch with act = \() -> fmap (first toLedgerValue) $ runScript (act ()) (), dummy = ()

instance ActionCatch Script where
  _tryCatch : forall t. (() -> Script t) -> (AnyException -> Optional (Script t)) -> Script t
  _tryCatch act handle = do
    res <- tryToEither act
    case res of
      Right t -> pure t
      Left e -> fromOptional (throwAnyException e) $ handle e

-- TODO: Throw discards the stacktrace, such that it can't be passed back to `tryToEither` and provided when it rethrows
-- Consider reworking how the ghc stack traces are passed around in this file
data Throw = Throw with
  exc: AnyException
instance IsQuestion Throw t

instance ActionThrow Script where
  throw e = throwAnyException $ toAnyException e

throwAnyException : AnyException -> Script t
throwAnyException = lift . Throw

instance CanAssert Script where
  assertFail m = throw (AssertionFailed m)
#else
instance CanAssert Script where
  assertFail = abort
#endif

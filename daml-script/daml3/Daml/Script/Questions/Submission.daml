  
{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Script.Questions.Submission where

import DA.NonEmpty
import Daml.Script.Internal 

data RootCreate = RootCreate with
  argC : AnyTemplate

instance IsQuestion RootCreate (ContractId ()) where command = "RootCreate"

rootCreate : (Template t, HasAgreement t) => t -> Script (ContractId t)
rootCreate arg = do
   cid <- lift $ RootCreate (toAnyTemplate arg)
   pure $ coerceContractId @() cid

data RootExercise = RootExercise with
   tplId : TemplateTypeRep
   cId : ContractId ()
   argE : AnyChoice

instance IsQuestion RootExercise LedgerValue where command = "RootExercise"

rootExercise : forall t c r. Choice t c r  => ContractId t -> c -> Script r
rootExercise cId arg = do
  ledgerValue <- lift $ RootExercise (templateTypeRep @t) (coerceContractId cId) (toAnyChoice @t arg)
  pure $ fromLedgerValue ledgerValue

rootCreateAndExercise: forall t c r. (HasAgreement t, Choice t c r) => t -> c -> Script (ContractId t, r)
rootCreateAndExercise arg choiceArg = do
  cid <- rootCreate arg
  r <- rootExercise cid choiceArg
  pure (cid, r)

--class IsSubmissionScript req res | req -> res where
--  scriptName : Text
--  submissionScript: req -> Script res   

data SubmitScript req res = SubmitScript with 
   actAs : NonEmpty Party
   readAs : [Party]
   name : Text
   arg : req 

instance IsQuestion (SubmitScript req res) res where command = "SubmitScript"  
   
submitScript: forall req res. NonEmpty Party -> [Party] -> Text -> req -> Script res 
submitScript actAs readAs name arg = do
  lift $ SubmitScript @req @res actAs readAs name arg 

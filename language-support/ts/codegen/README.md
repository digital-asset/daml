# daml2js

This is a code generator for a TypeScript interface to a Daml package. To run it, you must execute
```console
$ bazel run //:daml2js
Usage: daml2js DAR-FILE -o DIR
  Generate TypeScript bindings from a DAR
```
somewhere in this repository. The `DAR-FILE` is the DAR for which you want to
generate the TypeScript interface.  `daml2js` will generate interfaces for
all DALFs in that DAR. The output will be written into the directory `DIR`
you specify via the `-o` option.

Currently, the generated interfaces are tailored towards the
[`ledger.ts`](https://github.com/digital-asset/davl/blob/main/ui/src/ledger/ledger.ts)
module of DAVL.

## How to develop daml2js

The full test suite is started via
```
bazel test //language-support/ts/codegen/tests/...
```

Unfortunately, this is a bit slow and not suitable for repeated running during
development. To make things more responsive, you can run the following
trinity of shell scripts, all in parallel and each in its own terminal:
- `./tests/watch-damlc.sh`: Build a DAR out of the `.daml` files in
  `./tests/daml` whenever they change.
- `./tests/watch-daml2js.sh`: Re-interpret `daml2js` and run it on the DAR
  produced by `./tests/watch-damlc.sh`.
- `./tests/watch-yarn`: Build all the TypeScript libraries in dependency
  order and run the TypeScript compiler in watch mode on the TypeScript
  generated by `./tests/watch-daml2js.sh`. This script does not recompile
  any changes made to the TypeScript libraries `@daml/types` or
  `@daml/ledger`. Changes to these libraries must be manually
  recompiled using `yarn build` in the respective directories. (You can also
  use `yarn build:watch` to run the TypeScript compiler in watch mode.)

All these steps only check that everything compiles. They do _not_ run any
tests. To run the tests suite, you need to issue the command above.

### How to run daml2js on a set of DARs from bazel

Running the code-generator outside of the SDK means having to take
into account the dependency of daml2js generated packages on a version
of `daml-types` that is not available on NPM. The folllowing recipe
shows how it's done (obviously you'll need to adapt paths in the below
to your own environment).
```bash
mkdir -p ~/tmp/davl
cd ~/tmp/davl
cat > package.json<<EOF
{
  "private": true,
  "workspaces": ["daml2js"],
  "resolutions": {
    "@daml/types": "file:daml-types",
    "@daml/ledger": "file:daml-ledger"
  }
}
EOF
cd ~/project/daml.git
bazel build //language-support/ts/daml-types:npm_package
bazel build //language-support/ts/daml-ledger:npm_package
cp -R bazel-bin/language-support/ts/daml-types/npm_package ~/tmp/davl/daml-types
cp -R bazel-bin/language-support/ts/daml-leger/npm_package ~/tmp/davl/daml-ledger
bazel run //language-support/ts/codegen:daml2js -- -o ~/tmp/davl/daml2js ~/project/davl.git/released/*.dar
```

## What `daml2js` generates

The Daml SDK documentation contains [a page](https://github.com/digital-asset/daml/tree/main/docs/source/daml2js) on `daml2js`. It is recommended that you start with this. The remainder of this section contains additional detail (mostly about serialization code). The code that `daml2js` generates uses the  [@daml/types](https://github.com/digital-asset/daml/tree/main/language-support/ts/daml-types) and [@mojotech/json-type-validation](https://github.com/mojotech/json-type-validation) libraries. All TypeScript modules generated by `daml2js` begin with the following fragment:
```typescript
import * as jtv from '@mojotech/json-type-validation';
import * as daml from '@daml/types';

```

### Primitives: @daml/types

#### Types

See the [SDK docs](https://github.com/digital-asset/daml/tree/main/docs/source/daml2js).

#### Typescript Interfaces

- `Serializable<T>`
  - An object that implements the `Serializable<T>` interface has a field `decoder: () => jtv.Decoder<T>`;
- `Template<T extends object, K = unknown>`
  - An object that implements the `Template<T, K>` interface has fields `templateId: string`, `keyDecoder: ()=> jtv.Decoder<K>`, `Archive: Choice<T, {}, {}>` and implements `Serializable<T>`;
- `Choice<T extends object, C, R, K = unknown>`
  - An object that implements the `Choice<T, C, R, K>` interface has fields `template: () => Template<T, K>`, `argumentDecoder: () => jtv.Decoder<C>`, `resultDecoder: () => jtv.Decoder<R>` and `choiceName: string`.

### Mappings

#### Records

In Daml, define `Person` like so.

```haskell
data Person =
  Person with
    name: Text
    party: Party
    age: Int
```

The generated TypeScript code will be as follows.
```typescript
export type Person = {
  name: string;
  party: daml.Party;
  age: daml.Int;
}

export const Person: daml.Serializable<Person> = ({
  decoder: () => jtv.object({
    name: daml.Text.decoder(),
    party: daml.Party.decoder(),
    age: daml.Int.decoder(),
  }),
})
```
Two elements have been generated from the Daml type definition : (1) a TypeScript equivalent type and (2) a companion object for type-validating serialization over the json-api.

#### Variants

A type of additive expressions in Daml.
```haskell
data Expr a =
    Lit a
  | Var Text
  | Add (Expr a, Expr a)
```

Since `Expr a` is polymorphic in `A`, in addition to the TypeScript equivalent type, a companion function rather than a companion object is produced.

```typescript
export type Expr<a_a1vq> =
  |  { tag: 'Lit'; value: a_a1vq }
  |  { tag: 'Var'; value: string }
  |  { tag: 'Add'; value: DA_Types.Tuple2<Expr<a_a1vq>, Expr<a_a1vq>> }

export const Expr = <a_a1vq>(a_a1vq: daml.Serializable<a_a1vq>): daml.Serializable<Expr<a_a1vq>> => ({
  decoder: () => jtv.oneOf<E<a_a1vq>>(
    jtv.object({tag: jtv.constant('Lit'), value: jtv.lazy(() => a_a1vq.decoder())}),
    jtv.object({tag: jtv.constant('Var'), value: jtv.lazy(() => daml.Text.decoder())}),
    jtv.object({tag: jtv.constant('Add'), value: jtv.lazy(() => DA_Types.Tuple2(Expr(a_a1vq), Expr(a_a1vq)).decoder())}),
  ),
});
```

The tuple in the `Add` case has been expressed in terms of TypeScript generated from the daml-prim `DA/Types` module:

```haskell
data Tuple2 a b =
    Tuple2{_1 : a; _2 : b}
```
That definition leads to the following TypeScript in `DA/Types.hs`.

```typescript
export type Tuple2<t1, t2> = {
  _1: t1;
  _2: t2;
}

export const Tuple2 = <t1, t2>(t1: daml.Serializable<t1>, t2: daml.Serializable<t2>): daml.Serializable<Tuple2<t1, t2>> => ({
  decoder: () => jtv.object({
    _1: t1.decoder(),
    _2: t2.decoder(),
  }),
})
```

#### Sum-of-products

Slightly modifying `Expr`.

```haskell
data Expr2 a =
    Lit2 a
  | Var2 Text
  | Add2 {lhs : Expr2 a, rhs: Expr2 a}
```

Note the difference in the `Add2` case from the preceding section. The TypeScript in this case reads as follows.

```typescript
export type Expr2<a_a1vt> =
  |  { tag: 'Lit2'; value: a_a1vt }
  |  { tag: 'Var2'; value: string }
  |  { tag: 'Add2'; value: Expr2.Add2<a_a1vt> }

export const Expr2 = <a_a1vt>(a_a1vt: daml.Serializable<a_a1vt>): daml.Serializable<Expr2<a_a1vt>> => ({
  decoder: () => jtv.oneOf<Expr2<a_a1vt>>(
    jtv.object({tag: jtv.constant('Lit2'), value: jtv.lazy(() => a_a1vt.decoder())}),
    jtv.object({tag: jtv.constant('Var2'), value: jtv.lazy(() => daml.Text.decoder())}),
    jtv.object({tag: jtv.constant('Add2'), value: jtv.lazy(() => Expr2.Add2(a_a1vt).decoder())}),
  ),
});
Expr2.Add2 = <a_a1vt>(a_a1vt: daml.Serializable<a_a1vt>): daml.Serializable<Expr2.Add2<a_a1vt>> => ({
  decoder: () => jtv.object({
    lhs: Expr2(a_a1vt).decoder(),
    rhs: Expr2(a_a1vt).decoder(),
  }),
});

export namespace Expr2 {
  export type Add2<a_a1vt> = {
    lhs: Expr2<a_a1vt>;
    rhs: Expr2<a_a1vt>;
  }
} //namespace Expr2
```
Corresponding to the `Add2` constructor we see the definition of an `Add2` type in the `Expr2` namespace. We see the definition of a companion function for the `Add2` record expressed as a property of the `Expr2` companion function (functions are "callable objects" in TypeScript and can thus have properties).

#### Enums

A Daml enumeration.

```haskell
data Color = Red | Blue | Yellow
```

In TypeScript, `daml2js` produces this.

```typescript
export enum Color {
  Red = 'Red',
  Blue = 'Blue',
  Yellow = 'Yellow',
}
daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<Color>(Color)

export namespace Color {
  export const decoder = () => jtv.oneOf<Color>(
    jtv.constant(Color.Red),
    jtv.constant(Color.Blue),
    jtv.constant(Color.Yellow),
  );
}
```
This time a companion function, `decoder`, has been generated in the `Color` namespace.

#### Templates and choices

A stripped down `Iou` template.

```haskell
template Iou
  with
    issuer: Party
    owner: Party
    currency: Text
    amount: Decimal
  where
    signatory issuer
    key owner : Party
    maintainer key
    choice Transfer: ContractId Iou
      with
        newOwner: Party
      controller owner
      do
        create this with owner = newOwner
```
The generated TypeScript follows.

```typescript
export type Transfer = {
  newOwner: daml.Party;
}

export const Transfer: daml.Serializable<Transfer> = ({
  decoder: () => jtv.object({
    newOwner: daml.Party.decoder(),
  }),
})

export type Iou = {
  issuer: daml.Party;
  owner: daml.Party;
  currency: string;
  amount: daml.Numeric;
}

export interface IouInterface = {
  Archive: daml.Choice<Iou, DA_Internal_Template.Archive, {}, Iou.Key>;
  Transfer: daml.Choice<Iou, Transfer, daml.ContractId<Iou>, Iou.Key>;
}

export const Iou: daml.Template<Iou, Iou.Key, 'Iou:Iou'> & IouInterface
 = {
  templateId: 'Iou:Iou',
  keyDecoder: () => daml.Party.decoder(),
  decoder: () => jtv.object({
    issuer: daml.Party.decoder(),
    owner: daml.Party.decoder(),
    currency: daml.Text.decoder(),
    amount: daml.Numeric(10).decoder(),
  }),
  Archive: {
    template: () => Iou,
    choiceName: 'Archive',
    argumentDecoder: DA_Internal_Template.Archive.decoder,
    resultDecoder: () => daml.Unit.decoder(),
  },
  Transfer: {
    template: () => Iou,
    choiceName: 'Transfer',
    argumentDecoder: Transfer.decoder,
    resultDecoder: () => daml.ContractId(Iou).decoder(),
  },
};

export namespace Iou {
  export type Key = daml.Party
}

daml.registerTemplate(Iou);
```

`daml2js` has produced:
  - Type definitions corresponding to the `Transfer` choice, the `Iou` template and the
    `IouInterface` consisting of its declared choices;
  - Companion objects for those types;
  - An `Iou` template associated type definition `Key` in the `Iou` namespace;
  - A module scoped function call to `registerTemplate` to add the `Iou` object to a central registry.

#### Daml Interfaces

An `Asset` interface.

```haskell
interface Asset where
  getAmount : Int
  choice Transfer : ContractId Asset
    with
      newOwner : Party

A Daml interface is translated to a TypeScript interface as follows. 

```typescript
export declare interface AssetInterface <T extends object>{
  Transfer: damlTypes.Choice<T, Transfer, damlTypes.ContractId<AssetInterface<T>>, undefined>;
}
export declare const Asset: damlTypes.Template<object, undefined, 'Asset'> & AssetInterface<object>;
```

Note that pure methods of the interface are omitted since they are not serializable. The following
is a template implementing the `Asset` interface and a `Other` interface.

```haskell
template Iou
  with
    issuer: Party
    owner: Party
    currency: Text
    amount: Decimal
  where
    signatory issuer
    key owner : Party
    maintainer key

    implements Asset where

      let getAmount = amount

      choice Transfer: ContractId Iou
        with
          newOwner: Party
        controller owner
        do
          create this with owner = newOwner

    implements Other where
      choice SomethingElse : ()
        controller owner
        do
          ...
```

The implementation is reflected in an extension of the `IouInterface` with `AssetInterface` and `OtherInterface`.

```typescript
export interface IouInterface extends AssetInterface<Iou>, OtherInterface<Iou>  = {
  Archive: daml.Choice<Iou, DA_Internal_Template.Archive, {}, Iou.Key>;
  Transfer: daml.Choice<Iou, Transfer, daml.ContractId<AssetInterface<Iou> & OtherInterface<Iou>>, Iou.Key>;
}
```

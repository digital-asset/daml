// Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.digitalasset.canton.participant.protocol.submission

import cats.syntax.option.*
import com.digitalasset.canton.ProtoDeserializationError.FieldNotSet
import com.digitalasset.canton.data.CantonTimestamp
import com.digitalasset.canton.error.TransactionError
import com.digitalasset.canton.ledger.participant.state.v2.CompletionInfo
import com.digitalasset.canton.logging.pretty.{Pretty, PrettyPrinting}
import com.digitalasset.canton.logging.{ErrorLoggingContext, HasLoggerName, NamedLoggingContext}
import com.digitalasset.canton.participant.protocol.{ProcessingSteps, TransactionProcessor, v0}
import com.digitalasset.canton.participant.store.{
  SerializableCompletionInfo,
  SerializableRejectionReasonTemplate,
}
import com.digitalasset.canton.participant.sync.LedgerSyncEvent
import com.digitalasset.canton.participant.sync.LedgerSyncEvent.CommandRejected
import com.digitalasset.canton.serialization.ProtoConverter
import com.digitalasset.canton.serialization.ProtoConverter.ParsingResult
import com.digitalasset.canton.topology.DomainId
import com.digitalasset.canton.version.{
  HasProtocolVersionedCompanion,
  HasProtocolVersionedWrapper,
  ProtoVersion,
  ProtocolVersion,
  ProtocolVersionedCompanionDbHelpers,
  ReleaseProtocolVersion,
  RepresentativeProtocolVersion,
}
import com.google.protobuf.empty.Empty
import com.google.rpc.status.Status

/** The data of an in-flight unsequenced submission that suffices to produce a rejection reason.
  * This data is persisted in the [[com.digitalasset.canton.participant.store.InFlightSubmissionStore]]
  * for unsequenced submissions and updated when the corresponding
  * a [[com.digitalasset.canton.sequencing.protocol.DeliverError]] is processed
  * or the submission could not be sent to the sequencer.
  */
trait SubmissionTrackingData
    extends Product
    with Serializable
    with HasProtocolVersionedWrapper[SubmissionTrackingData]
    with PrettyPrinting {

  @transient override protected lazy val companionObj: SubmissionTrackingData.type =
    SubmissionTrackingData

  protected def toProtoV0: v0.SubmissionTrackingData

  /** Produce a rejection event for the unsequenced submission using the given record time. */
  def rejectionEvent(recordTime: CantonTimestamp)(implicit
      loggingContext: NamedLoggingContext
  ): LedgerSyncEvent

  /** Update the tracking data so that the deliver error [[com.google.rpc.status.Status]]
    * can be taken into account by [[rejectionEvent]].
    *
    * @param timestamp The sequencer timestamp of the [[com.digitalasset.canton.sequencing.protocol.DeliverError]].
    * @param reason The reason for the deliver error generated by the sequencer.
    */
  def updateOnNotSequenced(timestamp: CantonTimestamp, reason: Status)(implicit
      loggingContext: NamedLoggingContext
  ): Option[UnsequencedSubmission]
}

object SubmissionTrackingData
    extends HasProtocolVersionedCompanion[SubmissionTrackingData]
    with ProtocolVersionedCompanionDbHelpers[SubmissionTrackingData] {

  val supportedProtoVersions = SupportedProtoVersions(
    ProtoVersion(0) -> VersionedProtoConverter
      .storage(ReleaseProtocolVersion(ProtocolVersion.v30), v0.SubmissionTrackingData)(
        supportedProtoVersion(_)(fromProtoV0),
        _.toProtoV0.toByteString,
      )
  )

  override def name: String = "submission tracking data"

  def fromProtoV0(
      submissionTrackingP: v0.SubmissionTrackingData
  ): ParsingResult[SubmissionTrackingData] = {
    val v0.SubmissionTrackingData(tracking) = submissionTrackingP
    tracking match {
      case v0.SubmissionTrackingData.Tracking.Transaction(transactionSubmissionTracking) =>
        TransactionSubmissionTrackingData.fromProtoV0(transactionSubmissionTracking)
      case v0.SubmissionTrackingData.Tracking.Empty => Left(FieldNotSet("tracking"))
    }
  }
}

/** Tracking data for transactions */
final case class TransactionSubmissionTrackingData(
    completionInfo: CompletionInfo,
    rejectionCause: TransactionSubmissionTrackingData.RejectionCause,
    domainId: DomainId,
)(
    override val representativeProtocolVersion: RepresentativeProtocolVersion[
      SubmissionTrackingData.type
    ]
) extends SubmissionTrackingData
    with HasLoggerName {

  override def rejectionEvent(
      recordTime: CantonTimestamp
  )(implicit loggingContext: NamedLoggingContext): LedgerSyncEvent = {

    val reasonTemplate = rejectionCause.asFinalReason(recordTime)
    CommandRejected(
      recordTime.toLf,
      completionInfo,
      reasonTemplate,
      ProcessingSteps.RequestType.Transaction,
      domainId,
    )
  }

  override def updateOnNotSequenced(timestamp: CantonTimestamp, reason: Status)(implicit
      loggingContext: NamedLoggingContext
  ): Option[UnsequencedSubmission] = {
    UnsequencedSubmission(
      timestamp,
      this.copy(rejectionCause = TransactionSubmissionTrackingData.CauseWithTemplate(reason))(
        representativeProtocolVersion
      ),
    ).some
  }

  protected def toProtoV0: v0.SubmissionTrackingData = {
    val completionInfoP = SerializableCompletionInfo(completionInfo).toProtoV0
    val transactionTracking = v0.TransactionSubmissionTrackingData(
      completionInfo = completionInfoP.some,
      rejectionCause = rejectionCause.toProtoV0.some,
      domainId = domainId.toProtoPrimitive,
    )
    v0.SubmissionTrackingData(v0.SubmissionTrackingData.Tracking.Transaction(transactionTracking))
  }

  override def pretty: Pretty[TransactionSubmissionTrackingData] = prettyOfClass(
    param("completion info", _.completionInfo),
    param("rejection cause", _.rejectionCause),
  )
}

object TransactionSubmissionTrackingData {
  def apply(
      completionInfo: CompletionInfo,
      rejectionCause: TransactionSubmissionTrackingData.RejectionCause,
      domainId: DomainId,
      protocolVersion: ProtocolVersion,
  ): TransactionSubmissionTrackingData =
    TransactionSubmissionTrackingData(completionInfo, rejectionCause, domainId)(
      SubmissionTrackingData.protocolVersionRepresentativeFor(protocolVersion)
    )

  def fromProtoV0(
      tracking: v0.TransactionSubmissionTrackingData
  ): ParsingResult[TransactionSubmissionTrackingData] = {
    val v0.TransactionSubmissionTrackingData(completionInfoP, causeP, domainIdP) = tracking
    for {
      completionInfo <- ProtoConverter.parseRequired(
        SerializableCompletionInfo.fromProtoV0,
        "completion info",
        completionInfoP,
      )
      cause <- ProtoConverter.parseRequired(RejectionCause.fromProtoV0, "rejection cause", causeP)
      domainId <- DomainId.fromProtoPrimitive(domainIdP, "domain_id")
    } yield TransactionSubmissionTrackingData(
      completionInfo,
      cause,
      domainId,
    )(
      SubmissionTrackingData.protocolVersionRepresentativeFor(ProtoVersion(0))
    )
  }

  trait RejectionCause extends Product with Serializable with PrettyPrinting {

    def asFinalReason(observedTimestamp: CantonTimestamp)(implicit
        loggingContext: ErrorLoggingContext
    ): CommandRejected.FinalReason

    def toProtoV0: v0.TransactionSubmissionTrackingData.RejectionCause
  }

  object RejectionCause {
    def fromProtoV0(
        proto: v0.TransactionSubmissionTrackingData.RejectionCause
    ): ParsingResult[RejectionCause] = {
      val v0.TransactionSubmissionTrackingData.RejectionCause(cause) = proto
      cause match {
        case v0.TransactionSubmissionTrackingData.RejectionCause.Cause.Timeout(empty) =>
          TimeoutCause.fromProtoV0(empty)
        case v0.TransactionSubmissionTrackingData.RejectionCause.Cause
              .RejectionReasonTemplate(template) =>
          CauseWithTemplate.fromProtoV0(template)
        case v0.TransactionSubmissionTrackingData.RejectionCause.Cause.Empty =>
          Left(FieldNotSet("TransactionSubmissionTrackingData.RejectionCause.cause"))
      }
    }
  }

  case object TimeoutCause extends RejectionCause {

    override def asFinalReason(
        observedTimestamp: CantonTimestamp
    )(implicit loggingContext: ErrorLoggingContext): CommandRejected.FinalReason = {
      val error = TransactionProcessor.SubmissionErrors.TimeoutError.Error(observedTimestamp)
      error.logWithContext()
      CommandRejected.FinalReason(error.rpcStatus())
    }

    override def toProtoV0: v0.TransactionSubmissionTrackingData.RejectionCause =
      v0.TransactionSubmissionTrackingData.RejectionCause(
        cause = v0.TransactionSubmissionTrackingData.RejectionCause.Cause.Timeout(Empty())
      )

    override def pretty: Pretty[TimeoutCause.type] = prettyOfObject[TimeoutCause.type]

    def fromProtoV0(_empty: Empty): ParsingResult[TimeoutCause.type] = Right(
      this
    )
  }

  final case class CauseWithTemplate(template: CommandRejected.FinalReason) extends RejectionCause {
    override def asFinalReason(_observedTimestamp: CantonTimestamp)(implicit
        loggingContext: ErrorLoggingContext
    ): CommandRejected.FinalReason = template

    override def toProtoV0: v0.TransactionSubmissionTrackingData.RejectionCause =
      v0.TransactionSubmissionTrackingData.RejectionCause(
        cause = v0.TransactionSubmissionTrackingData.RejectionCause.Cause.RejectionReasonTemplate(
          SerializableRejectionReasonTemplate(template).toProtoV0
        )
      )

    override def pretty: Pretty[CauseWithTemplate] = prettyOfClass(
      unnamedParam(_.template)
    )
  }

  object CauseWithTemplate {

    /** Log the `error` and then convert it into a
      * [[com.digitalasset.canton.participant.sync.LedgerSyncEvent.CommandRejected.FinalReason]]
      */
    def apply(
        error: TransactionError
    )(implicit loggingContext: ErrorLoggingContext): CauseWithTemplate = {
      error.logWithContext()
      CauseWithTemplate(CommandRejected.FinalReason(error.rpcStatus()))
    }

    /** Log the `status` and then convert it into a
      * [[com.digitalasset.canton.participant.sync.LedgerSyncEvent.CommandRejected.FinalReason]]
      */
    def apply(
        status: Status
    )(implicit loggingContext: ErrorLoggingContext): CauseWithTemplate = {
      loggingContext.info(status.message)
      CauseWithTemplate(CommandRejected.FinalReason(status))
    }

    def fromProtoV0(
        templateP: v0.CommandRejected.GrpcRejectionReasonTemplate
    ): ParsingResult[CauseWithTemplate] =
      for {
        template <- SerializableRejectionReasonTemplate.fromProtoV0(templateP)
      } yield CauseWithTemplate(template)
  }
}

-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Main (main) where

import Control.Concurrent.Async
import Control.Lens (view)
import Crypto.Hash (hashlazy, Digest, SHA256)
import Data.Aeson
import Data.ByteArray.Encoding (Base(Base16), convertToBase)
import Data.ByteString (ByteString)
import Data.Either (fromRight)
import qualified Data.HashMap.Strict as HashMap
import Data.Map (Map)
import qualified Data.Map.Strict as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.SemVer (Version)
import qualified Data.SemVer as SemVer
import qualified Data.Text as T
import Network.HTTP.Client (responseTimeout, responseTimeoutMicro)
import Network.HTTP.Simple
import Options.Applicative
import System.IO.Extra

newtype Versions = Versions { getVersions :: Set Version }
    deriving Show

instance Semigroup Versions where
    Versions a <> Versions b = Versions (a <> b)

instance FromJSON Versions where
    parseJSON = withObject "version object" $ \obj ->
        either fail (pure . Versions . Set.fromList) $
        traverse SemVer.fromText $ HashMap.keys obj

minimumVersion :: Version
minimumVersion = SemVer.incrementMajor SemVer.initial

headVersion :: Version
headVersion = SemVer.initial

-- We include this here so buildifier does not modify this file.
copyrightHeader :: [T.Text]
copyrightHeader =
    [ "# Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved."
    , "# SPDX-License-Identifier: Apache-2.0"
    ]

renderVersionsFile :: Versions -> Map Version Checksums -> T.Text
renderVersionsFile (Versions (Set.toAscList -> versions)) checksums =
    T.unlines $ concat
        [ copyrightHeader
        , [ "# This file is autogenerated and should not be modified manually."
          , "# Update versions/UpdateVersions.hs instead."
          ]
        , [ "sdk_versions = [" ]
        , map renderVersion (versions <> [headVersion])
        , [ "]"]
        , [ "platform_versions = [" ]
        , map renderVersion (versions <> [headVersion])
        , [ "]" ]
        , [ "stable_versions = [" ]
        , map renderVersion (stableVersions <> [headVersion])
        , [ "]" ]
        , [ "latest_stable_version = \"" <> SemVer.toText (last stableVersions) <> "\"" ]
        , [ "version_sha256s = {"]
        , concatMap renderChecksums (Map.toList checksums)
        , [ "}" ]
        ]
  where
    renderChecksums (ver, Checksums{..}) = concat
      [ [ "    \"" <> SemVer.toText ver <> "\": {"
        , "        \"linux\": " <> renderDigest linuxHash <> ","
        , "        \"macos\": " <> renderDigest macosHash <> ","
        , "        \"windows\": " <> renderDigest windowsHash <> ","
        , "        \"test_tool\": " <> renderDigest testToolHash <> ","
        , "        \"daml_types\": " <> renderDigest damlTypesHash <> ","
        , "        \"daml_ledger\": " <> renderDigest damlLedgerHash <> ","
        , "        \"daml_react\": " <> renderDigest damlReactHash <> ","
        ]
      , [ "        \"create_daml_app_patch\": " <> renderDigest hash <> ","
        | Just hash <- [mbCreateDamlAppPatchHash]
        ]
      , [ "    }," ]
      ]
    renderDigest digest = T.pack $ show (convertToBase Base16 digest :: ByteString)
    renderVersion ver = "    \"" <> SemVer.toText ver <> "\","
    stableVersions = filter (null . view SemVer.release) versions

data Opts = Opts
  { outputFile :: FilePath
  } deriving Show

data Checksums = Checksums
  { linuxHash :: Digest SHA256
  , macosHash :: Digest SHA256
  , windowsHash :: Digest SHA256
  , testToolHash :: Digest SHA256
  , damlTypesHash :: Digest SHA256
  , damlLedgerHash :: Digest SHA256
  , damlReactHash :: Digest SHA256
  , mbCreateDamlAppPatchHash :: Maybe (Digest SHA256)
  -- ^ Nothing for older versions
  }

-- | The messaging patch wasnâ€™t included in 1.0.0 directly
-- but only added later.
-- However, the code did not change and we can apply
-- the later patch on the older versions.
-- Therefore we fallback to using the patch from this version
-- for releases before this one.
firstMessagingPatch :: Version
firstMessagingPatch =
    fromRight (error "Invalid version") $
    SemVer.fromText "1.1.0-snapshot.20200422.3991.0.6391ee9f"

getChecksums :: Version -> IO Checksums
getChecksums ver = do
    putStrLn ("Requesting hashes for " <> SemVer.toString ver)
    [ linuxHash, macosHash, windowsHash, testToolHash,
      damlTypesHash, damlLedgerHash, damlReactHash] <-
        forConcurrently
            [ sdkUrl "linux", sdkUrl "macos", sdkUrl "windows"
            , testToolUrl
            , tsLib "types"
            , tsLib "ledger"
            , tsLib "react"
            ] getHash
    mbCreateDamlAppPatchHash <- traverse getHash mbCreateDamlAppUrl
    pure Checksums {..}
  where sdkUrl platform =
            "https://github.com/digital-asset/daml/releases/download/v" <>
            SemVer.toString ver <> "/" <>
            "daml-sdk-" <> SemVer.toString ver <> "-" <> platform <> ".tar.gz"
        testToolUrl =
            "https://repo1.maven.org/maven2/com/daml/ledger-api-test-tool/" <>
            SemVer.toString ver <> "/ledger-api-test-tool-" <> SemVer.toString ver <> ".jar"
        tsLib name =
            "https://registry.npmjs.org/@daml/" <> name <>
            "/-/" <> name <> "-" <> SemVer.toString ver <> ".tgz"
        mbCreateDamlAppUrl
          | ver >= firstMessagingPatch =
             Just $
               "https://raw.githubusercontent.com/digital-asset/daml/v" <> SemVer.toString ver
               <> "/templates/create-daml-app-test-resources/messaging.patch"
          | otherwise = Nothing
        getHash url = do
          req <- parseRequestThrow url
          bs <- httpLbs req { responseTimeout = responseTimeoutMicro (60 * 10 ^ (6 :: Int) ) }
          let !hash = hashlazy (getResponseBody bs)
          pure hash

optsParser :: Parser Opts
optsParser = Opts
  <$> strOption (short 'o' <> help "Path to output file")

main :: IO ()
main = do
    Opts{..} <- execParser (info optsParser fullDesc)
    versionsReq <- parseRequestThrow "https://docs.daml.com/versions.json"
    snapshotsReq <- parseRequestThrow "https://docs.daml.com/snapshots.json"
    versionsResp <- httpJSON versionsReq
    snapshotsResp <- httpJSON snapshotsReq
    let allVersions = Versions (Set.filter (>= minimumVersion) (getVersions (getResponseBody versionsResp <> getResponseBody snapshotsResp)))
    checksums <- mapM (\ver -> (ver,) <$> getChecksums ver) (Set.toList $ getVersions allVersions)
    writeFileUTF8 outputFile (T.unpack $ renderVersionsFile allVersions $ Map.fromList checksums)


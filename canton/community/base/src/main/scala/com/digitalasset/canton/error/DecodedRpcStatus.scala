// Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.digitalasset.canton.error

import cats.syntax.either.*
import com.daml.error.{ErrorCategory, ErrorResource}
import io.grpc.StatusRuntimeException

import java.util.concurrent.TimeUnit
import scala.concurrent.duration.{Duration, FiniteDuration}

/** Decoded form of com.google.rpc.Status as generated by our errors
  *
  * We use com.google.rpc.Status (java) and com.google.rpc.status.Status (scala) to store
  * and ship error information via GRPC. However, extracting this information from the
  * object is a bit cumbersome.
  *
  * Therefore, we support the UX by providing a set of conversion utilities to make the information
  * stored better accessible.
  */
final case class DecodedRpcStatus(
    id: String,
    category: ErrorCategory,
    correlationId: Option[String],
    retryIn: Option[FiniteDuration],
    context: Map[String, String],
    resources: Map[ErrorResource, Seq[String]],
) {

  def isRetryable: Boolean = retryIn.nonEmpty

}

object DecodedRpcStatus {

  private val empty = (
    None: Option[ErrorCategory],
    DecodedRpcStatus("", ErrorCategory.SystemInternalAssumptionViolated, None, None, Map(), Map()),
  )

  private def accumulateRetryInfo(categoryO: Option[ErrorCategory], acc: DecodedRpcStatus)(
      retrySecsAndNanos: Option[(Long, Int)]
  ): (Option[ErrorCategory], DecodedRpcStatus) =
    retrySecsAndNanos match {
      case Some((seconds, nanos)) =>
        val dr = Duration.fromNanos(TimeUnit.SECONDS.toNanos(seconds) + nanos.toLong)
        (categoryO, acc.copy(retryIn = Some(dr)))
      case None => (categoryO, acc)
    }

  private def accumulateResourceInfo(
      categoryO: Option[ErrorCategory],
      acc: DecodedRpcStatus,
  )(resourceType: String, resourceName: String): (Option[ErrorCategory], DecodedRpcStatus) =
    CantonErrorResource.fromString(resourceType).fold((categoryO, acc)) { resourceType =>
      val resourceItems = acc.resources.getOrElse(resourceType, Seq()) :+ resourceName
      (categoryO, acc.copy(resources = acc.resources + (resourceType -> resourceItems)))
    }

  private def accumulateErrorInfo(
      categoryO: Option[ErrorCategory],
      acc: DecodedRpcStatus,
  )(reason: String, metadata: Map[String, String]): (Option[ErrorCategory], DecodedRpcStatus) = {
    if (reason.nonEmpty) {
      val category = (for {
        catS <- metadata.get("category")
        catI <- Either.catchOnly[NumberFormatException](catS.toInt).toOption
        cat <- ErrorCategory.fromInt(catI)
      } yield cat)
      (category, acc.copy(id = reason, context = metadata.filterNot(_._1 == "category")))
    } else (categoryO, acc)
  }

  private def finaliseDecoding(
      acc: (Option[ErrorCategory], DecodedRpcStatus)
  ): Option[DecodedRpcStatus] =
    (acc match {
      case (categoryO, status) =>
        categoryO.map(ct => status.copy(category = ct))
    }).filter(_.id.nonEmpty)

  def fromScalaStatus(status: com.google.rpc.status.Status): Option[DecodedRpcStatus] =
    finaliseDecoding(
      status.details
        .foldLeft(empty) {
          case ((categoryO, acc), e) if e.is(com.google.rpc.error_details.ResourceInfo) =>
            val ri = e.unpack(com.google.rpc.error_details.ResourceInfo)
            accumulateResourceInfo(categoryO, acc)(ri.resourceType, ri.resourceName)
          case ((categoryO, acc), e) if e.is(com.google.rpc.error_details.ErrorInfo) =>
            val ei = e.unpack(com.google.rpc.error_details.ErrorInfo)
            accumulateErrorInfo(categoryO, acc)(ei.reason, ei.metadata)
          case ((categoryO, acc), e) if e.is(com.google.rpc.error_details.RetryInfo) =>
            val ei = e.unpack(com.google.rpc.error_details.RetryInfo)
            accumulateRetryInfo(categoryO, acc)(ei.retryDelay.map(x => (x.seconds, x.nanos)))
          case ((categoryO, acc), e) if e.is(com.google.rpc.error_details.RequestInfo) =>
            val ri = e.unpack(com.google.rpc.error_details.RequestInfo)
            (categoryO, acc.copy(correlationId = Some(ri.requestId)))
          case (acc, _) => acc
        }
    )

  def fromStatusRuntimeException(ex: StatusRuntimeException): Option[DecodedRpcStatus] = {

    Either
      .catchOnly[IllegalArgumentException](io.grpc.protobuf.StatusProto.fromThrowable(ex))
      .toOption
      // fromThrowable might return null
      .flatMap(s => Option(s))
      .flatMap { status =>
        import scala.jdk.CollectionConverters.*
        finaliseDecoding(status.getDetailsList.asScala.foldLeft(empty) {

          // extract retry interval
          case ((categoryO, acc), e) if e.is(classOf[com.google.rpc.RetryInfo]) =>
            val retryInfo = e.unpack(classOf[com.google.rpc.RetryInfo])
            val retryDelay = if (retryInfo.hasRetryDelay) {
              val dl = retryInfo.getRetryDelay
              Some((dl.getSeconds, dl.getNanos))
            } else None
            accumulateRetryInfo(categoryO, acc)(retryDelay)

          // extract error info
          case ((categoryO, acc), e) if e.is(classOf[com.google.rpc.ErrorInfo]) =>
            val errorInfo = e.unpack(classOf[com.google.rpc.ErrorInfo])
            accumulateErrorInfo(categoryO, acc)(
              errorInfo.getReason,
              errorInfo.getMetadataMap.asScala.toMap,
            )

          // extract correlation-id
          case ((categoryO, acc), e) if e.is(classOf[com.google.rpc.RequestInfo]) =>
            val ri = e.unpack(classOf[com.google.rpc.RequestInfo])
            (categoryO, acc.copy(correlationId = Some(ri.getRequestId)))

          // extract resource info
          case ((categoryO, acc), e) if e.is(classOf[com.google.rpc.ResourceInfo]) =>
            val ri = e.unpack(classOf[com.google.rpc.ResourceInfo])
            accumulateResourceInfo(categoryO, acc)(ri.getResourceType, ri.getResourceName)
          case (acc, _) => acc
        })

      }

  }

}

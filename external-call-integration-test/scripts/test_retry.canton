// Retry logic tests - 503 retry, max retries, rate limiting

import com.digitalasset.canton.protocol.LfContractId

println("=" * 60)
println("External Call Retry Logic Tests")
println("=" * 60)

println("\n[Phase 1] Bootstrapping...")

nodes.local.start()

bootstrap.synchronizer(
  "da",
  sequencers = Seq(sequencer1),
  mediators = Seq(mediator1),
  synchronizerOwners = Seq(sequencer1),
  synchronizerThreshold = PositiveInt.one,
  staticSynchronizerParameters = StaticSynchronizerParameters.defaultsWithoutKMS(ProtocolVersion.dev),
)

participant1.synchronizers.connect_local(sequencer1, alias = "da")
participant2.synchronizers.connect_local(sequencer1, alias = "da")

utils.retry_until_true {
  participant1.synchronizers.active("da") &&
  participant2.synchronizers.active("da")
}
println("Participants connected.")

val alice = participant1.parties.enable("Alice")
val bob = participant2.parties.enable("Bob")
println(s"Alice: $alice")
println(s"Bob: $bob")

val darPath = Option(System.getProperty("dar.path"))
  .getOrElse("external-call-integration-test/.daml/dist/external-call-integration-test-1.0.0.dar")
val synchronizerId = participant1.synchronizers.id_of(SynchronizerAlias.tryCreate("da"))
participant1.dars.upload(darPath, synchronizerId = synchronizerId)
participant2.dars.upload(darPath, synchronizerId = synchronizerId)
println("DAR uploaded.")

val pkg = participant1.packages.find_by_module("ExternalCallIntegrationTest").headOption
  .getOrElse(sys.error("Package not found"))
println(s"Package: ${pkg.packageId}")

import scala.sys.process._
try { "curl -s http://127.0.0.1:8080/reset".!! } catch { case _: Throwable => }

// Helpers

def createTestContract(): String = {
  val createCmd = ledger_api_utils.create(
    pkg.packageId,
    "ExternalCallIntegrationTest",
    "ObservedExternalCall",
    Map("signatory_" -> alice, "observer_" -> bob)
  )
  participant1.ledger_api.commands.submit(Seq(alice), Seq(createCmd), synchronizerId = Some(synchronizerId))
  Thread.sleep(1000)

  val contracts = participant1.ledger_api.state.acs.of_party(alice)
    .filter(_.templateId.toString.contains("ObservedExternalCall"))
  contracts.head.contractId
}

def getMockCounts(): String = {
  try { "curl -s http://127.0.0.1:8080/counts".!! } catch { case _: Throwable => "error" }
}

def resetMock(): Unit = {
  try { "curl -s http://127.0.0.1:8080/reset".!! } catch { case _: Throwable => }
}

def getAllCauses(e: Throwable): String = {
  val sb = new StringBuilder()
  var current: Throwable = e
  while (current != null) {
    if (sb.nonEmpty) sb.append(" | ")
    sb.append(current.toString)
    current = current.getCause
  }
  sb.toString
}

// Tests

var passed = 0
var failed = 0

// T4.1 - Retry on 503 Success
println("\n" + "-" * 60)
println("T4.1: Retry on 503 Success")
println("-" * 60)
println("Expected: First call returns 503, retry succeeds with 200")
resetMock()

val contractId1 = createTestContract()
val contracts1 = participant1.ledger_api.state.acs.of_party(alice)
  .filter(_.contractId == contractId1)

val exerciseCmd1 = ledger_api_utils.exercise(
  "TestRetryOnce",
  Map("inputHex" -> "aabbccdd"),
  contracts1.head.event
)

val result1: Option[String] = try {
  participant1.ledger_api.commands.submit(Seq(alice), Seq(exerciseCmd1), synchronizerId = Some(synchronizerId))
  None
} catch {
  case e: Throwable => Some(getAllCauses(e))
}

result1 match {
  case None =>
    println("PASS: Transaction succeeded after retry")
    val counts = getMockCounts()
    if (counts.contains("retry-once")) {
      println("Verified: Mock received retry-once requests")
    }
    passed += 1
  case Some(errorMsg) =>
    println(s"FAIL: Transaction failed unexpectedly")
    println(s"Error: ${errorMsg.take(300)}...")
    failed += 1
}

// T4.3 - Max Retries Exceeded
println("\n" + "-" * 60)
println("T4.3: Max Retries Exceeded")
println("-" * 60)
println("Expected: Mock always returns 503, transaction fails after max retries")
resetMock()

val contractId2 = createTestContract()
val contracts2 = participant1.ledger_api.state.acs.of_party(alice)
  .filter(_.contractId == contractId2)

val exerciseCmd2 = ledger_api_utils.exercise(
  "TestRetryAlways",
  Map("inputHex" -> "11223344"),
  contracts2.head.event
)

val result2: Option[String] = try {
  participant1.ledger_api.commands.submit(Seq(alice), Seq(exerciseCmd2), synchronizerId = Some(synchronizerId))
  None
} catch {
  case e: Throwable => Some(getAllCauses(e))
}

result2 match {
  case None =>
    println("FAIL: Expected transaction to fail but it succeeded")
    failed += 1
  case Some(errorMsg) =>
    val msg = errorMsg.toLowerCase
    val hasExpectedError = msg.contains("service unavailable") || msg.contains("503") || msg.contains("retries")
    val hasExternalCallFailed = msg.contains("external call failed") ||
                                 msg.contains("interpretation_user_error") ||
                                 msg.contains("commandfailure")
    if (hasExpectedError || hasExternalCallFailed) {
      println("PASS: Transaction failed after max retries as expected")
      passed += 1
    } else {
      println(s"FAIL: Wrong error type")
      println(s"Error: ${errorMsg.take(500)}")
      failed += 1
    }
}

// T4.5 - Rate Limit (429)
println("\n" + "-" * 60)
println("T4.5: Rate Limit (429 with Retry-After)")
println("-" * 60)
println("Expected: Mock returns 429 with Retry-After, retries and fails")
resetMock()

val contractId3 = createTestContract()
val contracts3 = participant1.ledger_api.state.acs.of_party(alice)
  .filter(_.contractId == contractId3)

val exerciseCmd3 = ledger_api_utils.exercise(
  "TestRateLimit",
  Map("inputHex" -> "55667788"),
  contracts3.head.event
)

val result3: Option[String] = try {
  participant1.ledger_api.commands.submit(Seq(alice), Seq(exerciseCmd3), synchronizerId = Some(synchronizerId))
  None
} catch {
  case e: Throwable => Some(getAllCauses(e))
}

result3 match {
  case None =>
    println("FAIL: Expected transaction to fail but it succeeded")
    failed += 1
  case Some(errorMsg) =>
    val msg = errorMsg.toLowerCase
    val hasExpectedError = msg.contains("rate limit") || msg.contains("429") || msg.contains("exceeded")
    val hasExternalCallFailed = msg.contains("external call failed") ||
                                 msg.contains("interpretation_user_error") ||
                                 msg.contains("commandfailure")
    if (hasExpectedError || hasExternalCallFailed) {
      println("PASS: Transaction failed due to rate limiting as expected")
      passed += 1
    } else {
      println(s"FAIL: Wrong error type")
      println(s"Error: ${errorMsg.take(500)}")
      failed += 1
    }
}

// Summary

println("\n" + "=" * 60)
println("RETRY LOGIC TEST SUMMARY")
println("=" * 60)
println(s"  Passed: $passed")
println(s"  Failed: $failed")
println(s"  Total:  ${passed + failed}")

println("\nFinal mock service stats:")
println(getMockCounts().take(500))

if (failed > 0) {
  println("\nSOME TESTS FAILED")
} else {
  println("\nALL RETRY LOGIC TESTS PASSED")
}
